<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gush Helka Map - כפר חב"ד</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
<style>
/* ── RESET & VARS ── */
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --primary:#1e293b;--accent:#d4a843;--accent-light:#fef9e7;
  --bg:#f1f5f9;--surface:#fff;--text:#1e293b;--text2:#64748b;
  --border:#e2e8f0;--hover:#f8fafc;--danger:#ef4444;
  --sidebar-w:400px;--strip-w:48px;--topbar-h:48px;
  --radius:8px;--shadow:0 1px 3px rgba(0,0,0,.08);
}
html,body{height:100%;font-family:'Segoe UI',Tahoma,Arial,sans-serif;background:var(--bg);color:var(--text)}

/* ── LAYOUT ── */
#app{display:flex;flex-direction:column;height:100vh;overflow:hidden}
#topbar{height:var(--topbar-h);background:var(--primary);color:#fff;display:flex;align-items:center;padding:0 16px;gap:12px;z-index:2000;flex-shrink:0}
.topbar-logo{font-size:18px;font-weight:700;display:flex;align-items:center;gap:8px;white-space:nowrap}
.topbar-logo i{color:var(--accent);font-size:20px}
.topbar-sep{width:1px;height:24px;background:rgba(255,255,255,.2);margin:0 4px}
.topbar-sub{font-size:13px;color:#94a3b8;white-space:nowrap}
.topbar-spacer{flex:1}
.topbar-btn{background:none;border:1px solid rgba(255,255,255,.2);color:#fff;padding:6px 14px;border-radius:6px;cursor:pointer;font-size:12px;display:flex;align-items:center;gap:6px;transition:.2s}
.topbar-btn:hover{background:rgba(255,255,255,.1)}
.topbar-btn i{font-size:13px}

#main{flex:1;display:flex;position:relative;overflow:hidden}

/* ── MAP ── */
#map-wrap{flex:1;position:relative;direction:ltr}
#map{width:100%;height:100%}
.leaflet-control-zoom{direction:ltr}
#map-info{position:absolute;bottom:12px;left:12px;background:rgba(30,41,59,.85);color:#fff;padding:6px 12px;border-radius:6px;font-size:12px;z-index:1000;direction:rtl;display:flex;gap:16px}
#map-info span{display:flex;align-items:center;gap:4px}
#map-info i{color:var(--accent);font-size:11px}

/* ── SCALE WIDGET ── */
#scale-widget{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);z-index:1100;direction:ltr;display:flex;flex-direction:column;align-items:center;gap:4px;pointer-events:none}#scale-bar-wrap{pointer-events:all;background:rgba(30,41,59,.88);color:#fff;border-radius:8px;padding:5px 12px;display:flex;flex-direction:column;align-items:center;gap:3px;cursor:pointer;user-select:none;min-width:160px}
#scale-bar-wrap:hover{background:rgba(30,41,59,1)}
.scale-bar-line{display:flex;align-items:center;gap:0}
.scale-bar-end{width:2px;height:8px;background:#fff;display:inline-block}
.scale-bar-mid{height:3px;background:#fff;display:inline-block;transition:width .3s}
.scale-label{font-size:11px;color:#cbd5e1;letter-spacing:.5px}
.scale-ratio{font-size:12px;font-weight:700;color:var(--accent, #d4a843);letter-spacing:.5px}
#scale-input-row{pointer-events:all;display:flex;gap:4px;align-items:center;background:rgba(30,41,59,.95);border-radius:7px;padding:4px 8px;box-shadow:0 2px 8px rgba(0,0,0,.3)}
#scale-input-row input{width:90px;background:#1e293b;border:1px solid #475569;color:#fff;border-radius:4px;padding:3px 6px;font-size:12px;text-align:center;outline:none}
#scale-input-row input:focus{border-color:var(--accent, #d4a843)}
#scale-input-row button{background:var(--accent, #d4a843);color:#1e293b;border:none;border-radius:4px;padding:3px 8px;cursor:pointer;font-size:11px;font-weight:700}
#scale-presets-bar{pointer-events:all;display:flex;gap:4px;flex-wrap:wrap;justify-content:center;max-width:340px}
.scale-preset-btn{background:rgba(30,41,59,.88);color:#fff;border:1px solid #475569;border-radius:5px;padding:3px 8px;font-size:11px;cursor:pointer;white-space:nowrap;display:flex;align-items:center;gap:4px;transition:.15s}
.scale-preset-btn:hover{background:#334155;border-color:var(--accent,#d4a843);color:var(--accent,#d4a843)}
.scale-preset-btn i{font-size:9px;color:#94a3b8;cursor:pointer}
.scale-preset-btn i:hover{color:#ef4444}
.scale-preset-add{background:rgba(30,41,59,.7);color:#94a3b8;border:1px dashed #475569;border-radius:5px;padding:3px 8px;font-size:11px;cursor:pointer}
.scale-preset-add:hover{border-color:var(--accent,#d4a843);color:var(--accent,#d4a843)}

/* ── SIDEBAR ── */
#sidebar{width:calc(var(--sidebar-w) + var(--strip-w));display:flex;flex-shrink:0;z-index:1500;box-shadow:-2px 0 12px rgba(0,0,0,.08)}

/* Icon Strip */
#icon-strip{width:var(--strip-w);background:#f8fafc;border-right:1px solid var(--border);display:flex;flex-direction:column;align-items:center;padding:8px 0;gap:2px}
.strip-btn{width:38px;height:38px;border:none;background:none;border-radius:var(--radius);cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--text2);font-size:15px;transition:.15s;position:relative}
.strip-btn:hover{background:var(--border);color:var(--text)}
.strip-btn.active{background:var(--accent-light);color:var(--accent)}
.strip-btn.active::before{content:'';position:absolute;right:-1px;top:8px;bottom:8px;width:3px;background:var(--accent);border-radius:3px 0 0 3px}
.strip-spacer{flex:1}
.strip-badge{position:absolute;top:2px;left:2px;background:var(--accent);color:#fff;font-size:8px;width:16px;height:16px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700}

/* Panel */
#panel{width:var(--sidebar-w);background:var(--surface);display:flex;flex-direction:column;overflow:hidden;border-right:1px solid var(--border)}
#panel-head{padding:14px 16px 0;flex-shrink:0}
#panel-title-row{display:flex;align-items:center;gap:8px;margin-bottom:12px}
#panel-title-row i{color:var(--accent);font-size:16px}
#panel-title-row span{font-size:15px;font-weight:600}
#panel-title-row .close-btn{margin-right:auto;background:none;border:none;cursor:pointer;color:var(--text2);font-size:14px}

/* Tabs */
.tabs{display:flex;border-bottom:2px solid var(--border)}
.tab{flex:1;padding:10px 6px;text-align:center;cursor:pointer;font-size:12.5px;color:var(--text2);border:none;background:none;border-bottom:3px solid transparent;margin-bottom:-2px;transition:.15s;font-weight:500;white-space:nowrap}
.tab:hover{color:var(--text);background:var(--hover)}
.tab.active{color:var(--accent);font-weight:700;border-bottom-color:var(--accent);background:var(--accent-light)}
.tab .cnt{font-weight:700;font-size:13px;display:block;line-height:1.1}
.tab .lbl{font-size:11px}

/* Search */
#search-box{padding:10px 16px;flex-shrink:0;border-bottom:1px solid var(--border)}
.search-row{display:flex;gap:6px}
.search-row input{flex:1;padding:8px 12px;border:1px solid var(--border);border-radius:6px;font-size:13px;direction:rtl;outline:none;transition:.2s}
.search-row input:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(212,168,67,.15)}
.search-row button{width:36px;height:36px;border:none;background:var(--accent);color:#fff;border-radius:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px}

/* Content scroll area */
#panel-content{flex:1;overflow-y:auto;overflow-x:hidden}
#panel-content::-webkit-scrollbar{width:6px}
#panel-content::-webkit-scrollbar-track{background:transparent}
#panel-content::-webkit-scrollbar-thumb{background:#cbd5e1;border-radius:3px}

/* ── BLOCK LIST ── */
.block-item{padding:12px 16px;border-bottom:1px solid #f1f5f9;cursor:pointer;display:flex;align-items:center;gap:12px;transition:.12s}
.block-item:hover{background:var(--hover)}
.block-item.selected{background:var(--accent-light);border-right:3px solid var(--accent)}
.block-icon{width:40px;height:40px;background:#e0f2fe;border-radius:var(--radius);display:flex;align-items:center;justify-content:center;color:#0284c7;font-size:16px;flex-shrink:0}
.block-info{flex:1;min-width:0}
.block-num{font-size:17px;font-weight:700;color:var(--text)}
.block-meta{display:flex;gap:12px;margin-top:3px}
.block-meta span{font-size:11.5px;color:var(--text2);display:flex;align-items:center;gap:3px}
.block-meta i{font-size:10px;color:#94a3b8}
.block-arrow{color:#cbd5e1;font-size:12px}

/* ── PLAN LIST ── */
.plan-item{padding:12px 16px;border-bottom:1px solid #f1f5f9;cursor:pointer;transition:.12s}
.plan-item:hover{background:var(--hover)}
.plan-head{display:flex;align-items:center;gap:8px}
.plan-head i{color:var(--accent);font-size:13px}
.plan-name{font-weight:600;font-size:13.5px;flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.plan-badge{background:#e0f2fe;color:#0284c7;font-size:10px;padding:2px 8px;border-radius:10px;white-space:nowrap;font-weight:600}
.plan-sub{font-size:11.5px;color:var(--text2);margin-top:4px;display:flex;gap:10px;flex-wrap:wrap}
.plan-sub span{display:flex;align-items:center;gap:3px}
.plan-status{padding:2px 8px;border-radius:10px;font-size:10px;font-weight:600}
.plan-status.active{background:#dcfce7;color:#15803d}
.plan-status.pending{background:#fef3c7;color:#a16207}
.plan-status.other{background:#f1f5f9;color:#64748b}

/* ── DOC LIST ── */
.doc-item{padding:10px 16px;border-bottom:1px solid #f8fafc;display:flex;align-items:center;gap:10px;font-size:12.5px}
.doc-item:hover{background:var(--hover)}
.doc-icon{width:32px;height:32px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:14px;flex-shrink:0}
.doc-icon.pdf{background:#fef2f2;color:#dc2626}
.doc-icon.dwg{background:#fef9e7;color:#d97706}
.doc-icon.shp{background:#f0fdf4;color:#16a34a}
.doc-icon.other{background:#f1f5f9;color:#64748b}
.doc-info{flex:1;min-width:0}
.doc-name{font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.doc-plan{font-size:11px;color:var(--text2);margin-top:2px}
.doc-item{cursor:pointer}
.doc-item .doc-actions{display:flex;gap:4px;margin-right:auto;flex-shrink:0}
.doc-item .doc-btn{border:none;background:none;color:var(--text2);cursor:pointer;padding:4px 6px;border-radius:4px;font-size:12px;transition:.15s}
.doc-item .doc-btn:hover{background:var(--accent-light);color:var(--accent)}
.doc-item.unavailable{opacity:.5}
.doc-item.unavailable .doc-name::after{content:' (לא זמין)';font-size:10px;color:var(--text2)}

/* ── DOCUMENT VIEWER MODAL ── */
.viewer-overlay{position:fixed;inset:0;z-index:9000;background:rgba(0,0,0,.85);display:none;flex-direction:column}
.viewer-overlay.open{display:flex}
.viewer-toolbar{height:48px;background:#1a1a2e;display:flex;align-items:center;padding:0 12px;gap:8px;flex-shrink:0;z-index:9010}
.viewer-toolbar .vt-title{color:#e5e7eb;font-size:13px;font-weight:500;flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:right}
.viewer-toolbar .vt-plan{color:#94a3b8;font-size:11px;margin-right:8px;white-space:nowrap}
.viewer-toolbar .vt-btn{background:none;border:1px solid rgba(255,255,255,.15);color:#e5e7eb;padding:6px 10px;border-radius:6px;cursor:pointer;font-size:13px;display:flex;align-items:center;gap:5px;transition:.15s;white-space:nowrap}
.viewer-toolbar .vt-btn:hover{background:rgba(255,255,255,.1);border-color:rgba(255,255,255,.3)}
.viewer-toolbar .vt-btn.active{background:rgba(212,168,67,.2);border-color:var(--accent);color:var(--accent)}
.viewer-toolbar .vt-sep{width:1px;height:24px;background:rgba(255,255,255,.12);margin:0 4px}
.viewer-toolbar .vt-zoom{color:#94a3b8;font-size:12px;min-width:42px;text-align:center}
.viewer-body{flex:1;display:flex;overflow:hidden;position:relative}
.viewer-content{flex:1;display:flex;align-items:center;justify-content:center;overflow:auto;position:relative;background:#242424}
.viewer-content iframe{width:100%;height:100%;border:none;background:#fff}
.viewer-content img{max-width:100%;max-height:100%;object-fit:contain;transition:transform .2s}
.viewer-content .viewer-pdf-container{width:100%;height:100%;overflow:auto;display:flex;flex-direction:column;align-items:center;gap:12px;padding:20px}
.viewer-content .pdf-page-wrapper{background:#fff;box-shadow:0 2px 12px rgba(0,0,0,.4);position:relative}
.viewer-content canvas.pdf-page{display:block}
.viewer-sidebar{width:220px;background:#16162a;border-left:1px solid rgba(255,255,255,.08);overflow-y:auto;display:none;flex-shrink:0}
.viewer-sidebar.open{display:block}
.viewer-sidebar .vs-head{padding:10px 12px;font-size:12px;color:#94a3b8;font-weight:600;border-bottom:1px solid rgba(255,255,255,.06)}
.viewer-sidebar .vs-thumb{padding:8px 12px;cursor:pointer;border-bottom:1px solid rgba(255,255,255,.04);transition:.15s}
.viewer-sidebar .vs-thumb:hover{background:rgba(255,255,255,.05)}
.viewer-sidebar .vs-thumb.active{background:rgba(212,168,67,.15);border-right:3px solid var(--accent)}
.viewer-sidebar .vs-thumb canvas{width:100%;border-radius:4px;box-shadow:0 1px 4px rgba(0,0,0,.3)}
.viewer-sidebar .vs-thumb-label{color:#94a3b8;font-size:10px;text-align:center;margin-top:4px}
.viewer-info-panel{padding:24px;color:#e5e7eb;font-size:13px;line-height:1.8;text-align:right;max-width:600px;margin:auto}
.viewer-info-panel h3{color:var(--accent);font-size:16px;margin-bottom:12px}
.viewer-info-panel .info-row{display:flex;gap:8px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06)}
.viewer-info-panel .info-row .k{color:#94a3b8;min-width:80px;flex-shrink:0}
.viewer-info-panel .info-row .v{color:#e5e7eb;word-break:break-all}
.viewer-info-panel .dl-btn{display:inline-flex;align-items:center;gap:8px;background:var(--accent);color:#1a1a2e;padding:10px 24px;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;border:none;margin-top:16px;transition:.15s}
.viewer-info-panel .dl-btn:hover{filter:brightness(1.1)}
.viewer-json-container{width:100%;height:100%;overflow:auto;padding:20px;font-family:'Cascadia Code','Fira Code',monospace;font-size:13px;color:#e5e7eb;white-space:pre-wrap;direction:ltr;text-align:left}
.viewer-json-container .json-key{color:#7dd3fc}.viewer-json-container .json-str{color:#86efac}.viewer-json-container .json-num{color:#fbbf24}.viewer-json-container .json-bool{color:#c084fc}.viewer-json-container .json-null{color:#94a3b8}
.viewer-kml-map{width:100%;height:100%}
.viewer-nav-arrow{position:absolute;top:50%;transform:translateY(-50%);width:44px;height:80px;background:rgba(0,0,0,.5);border:none;color:#fff;font-size:20px;cursor:pointer;z-index:9005;display:flex;align-items:center;justify-content:center;transition:.15s;border-radius:4px}
.viewer-nav-arrow:hover{background:rgba(0,0,0,.75)}
.viewer-nav-arrow.prev{right:8px}
.viewer-nav-arrow.next{left:8px}
.viewer-loading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:9006}
.viewer-loading i{font-size:32px;color:var(--accent);animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.viewer-page-indicator{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.7);color:#e5e7eb;padding:6px 16px;border-radius:20px;font-size:12px;z-index:9005}

/* ── LAYER LIST ── */
.layer-group{border-bottom:1px solid var(--border)}
.layer-group-head{padding:10px 16px;font-weight:600;font-size:13px;cursor:pointer;display:flex;align-items:center;gap:8px;background:#fafbfc}
.layer-group-head:hover{background:var(--hover)}
.layer-group-head i.toggle{transition:.2s;font-size:10px;color:var(--text2)}
.layer-group-head.open i.toggle{transform:rotate(90deg)}
.layer-group-head .badge{margin-right:auto;background:var(--border);padding:1px 8px;border-radius:10px;font-size:10px;color:var(--text2);font-weight:500}
.layer-cat-toggle{border:none;padding:2px 7px;border-radius:4px;font-size:10px;font-family:inherit;cursor:pointer;white-space:nowrap;transition:.15s}
.layer-cat-toggle.on{background:#10b981;color:#fff}
.layer-cat-toggle.off{background:#ef4444;color:#fff}
.layer-reorder-btn{border:none;background:transparent;cursor:pointer;color:var(--text2);font-size:11px;padding:2px 4px;border-radius:3px;transition:.15s;line-height:1}
.layer-reorder-btn:hover{background:var(--accent-light);color:var(--accent)}
.layer-reorder-btn:disabled{opacity:.25;cursor:default}
.layer-reorder-btn:disabled:hover{background:transparent;color:var(--text2)}
.layer-reorder-btns{display:flex;flex-direction:column;gap:0;margin-right:2px;flex-shrink:0}
.layer-action-btn{border:none;background:transparent;cursor:pointer;color:var(--text2);font-size:11px;padding:2px 4px;border-radius:3px;transition:.15s;line-height:1;opacity:.5;flex-shrink:0}
.layer-action-btn:hover{opacity:1}
.layer-action-btn.edit:hover{color:#3b82f6}
.layer-action-btn.delete:hover{color:#ef4444}
.layer-actions{display:flex;gap:1px;align-items:center;margin-right:auto;flex-shrink:0}
.layers-global-bar{display:flex;align-items:center;gap:6px;padding:8px 16px;border-bottom:1px solid var(--border);background:var(--surface2);font-size:11px;flex-wrap:wrap}
.layers-global-bar span{font-weight:600;color:var(--text2);flex:1}
.layers-global-btn{border:none;padding:4px 10px;border-radius:4px;font-size:11px;font-family:inherit;cursor:pointer;font-weight:600;transition:.15s}
.layers-global-btn.on{background:#10b981;color:#fff}
.layers-global-btn.on:hover{background:#059669}
.layers-global-btn.off{background:#ef4444;color:#fff}
.layers-global-btn.off:hover{background:#dc2626}
.dxf-upload-btn{border:none;padding:4px 10px;border-radius:4px;font-size:11px;font-family:inherit;cursor:pointer;font-weight:600;transition:.15s;background:var(--accent);color:#fff}
.dxf-upload-btn:hover{opacity:.85}
.dxf-upload-btn i{margin-left:4px}
.dxf-upload-progress{width:100%;padding:6px 16px;font-size:11px;color:var(--text2);display:flex;align-items:center;gap:6px}
.dxf-upload-progress .spinner-sm{width:14px;height:14px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin .6s linear infinite}
.dxf-layer-filter{display:flex;flex-wrap:wrap;gap:4px;padding:4px 16px 4px 40px;width:100%}
.dxf-layer-chip{font-size:10px;padding:2px 6px;border-radius:3px;cursor:pointer;border:1px solid var(--border);background:var(--surface);transition:.15s}
.dxf-layer-chip.active{background:var(--accent);color:#fff;border-color:var(--accent)}
.dxf-layer-chip:hover{border-color:var(--accent)}
.layer-items{display:none;padding:2px 0}
.layer-group.open .layer-items{display:block}
.layer-item{padding:7px 16px 7px 40px;display:flex;align-items:center;gap:8px;font-size:12px;cursor:pointer;flex-wrap:wrap}
.layer-item:hover{background:var(--hover)}
.layer-toggle{width:32px;height:18px;border-radius:9px;background:#cbd5e1;position:relative;cursor:pointer;transition:.2s;flex-shrink:0}
.layer-toggle::after{content:'';width:14px;height:14px;background:#fff;border-radius:50%;position:absolute;top:2px;right:2px;transition:.2s}
.layer-toggle.on{background:var(--accent)}
.layer-toggle.on::after{right:auto;left:2px}
.layer-label{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.layer-size{font-size:10px;color:var(--text2)}

/* Layer style controls */
.layer-controls{width:100%;display:flex;align-items:center;gap:8px;padding:6px 0 2px 40px;font-size:11px}
.layer-controls label{color:var(--text2);white-space:nowrap;font-size:10px}
.layer-color-btn{width:22px;height:22px;border:2px solid var(--border);border-radius:4px;cursor:pointer;padding:0;outline:none;transition:.15s}
.layer-color-btn:hover{border-color:var(--accent);transform:scale(1.1)}
.layer-opacity-slider{-webkit-appearance:none;appearance:none;width:80px;height:5px;border-radius:3px;background:var(--border);outline:none;cursor:pointer}
.layer-opacity-slider::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);cursor:pointer;border:2px solid #fff;box-shadow:0 1px 3px rgba(0,0,0,.2)}
.layer-opacity-slider::-moz-range-thumb{width:14px;height:14px;border-radius:50%;background:var(--accent);cursor:pointer;border:2px solid #fff;box-shadow:0 1px 3px rgba(0,0,0,.2)}
.layer-opacity-val{font-size:10px;color:var(--text2);min-width:26px;text-align:center}
.layer-color-palette{display:flex;gap:4px;flex-wrap:wrap;padding:4px 0 2px 40px;width:100%}
.layer-color-swatch{width:20px;height:20px;border-radius:4px;cursor:pointer;border:2px solid transparent;transition:.15s}
.layer-color-swatch:hover{transform:scale(1.15);border-color:var(--text)}
.layer-color-swatch.active{border-color:var(--text);box-shadow:0 0 0 2px var(--accent-light)}

/* ── SHP/DXF LAYER STYLE CONTROLS ── */
.shp-style-panel{padding:6px 12px 8px 12px;background:#f8fafc;border-top:1px solid #e2e8f0;font-size:11px}
.shp-style-row{display:flex;align-items:center;gap:6px;padding:3px 0;flex-wrap:wrap}
.shp-style-row label{color:var(--text2);font-size:10px;min-width:50px;white-space:nowrap}
.shp-style-row input[type=color]{width:28px;height:22px;border:1px solid var(--border);border-radius:4px;cursor:pointer;padding:1px}
.shp-style-row input[type=range]{flex:1;max-width:100px}
.shp-style-row .style-val{font-size:10px;color:var(--text2);min-width:28px;text-align:center}
.shp-settings-btn{background:none;border:1px solid var(--border);border-radius:4px;cursor:pointer;padding:2px 5px;font-size:10px;color:var(--text2);transition:.15s;margin-left:2px}
.shp-settings-btn:hover{background:var(--hover);color:var(--text)}
.shp-settings-btn.open{background:var(--accent-light);color:var(--accent);border-color:var(--accent)}

/* ── STATS PANEL ── */
.stats-grid{padding:16px;display:grid;grid-template-columns:1fr 1fr;gap:10px}
.stat-card{background:var(--bg);border-radius:var(--radius);padding:14px;text-align:center}
.stat-val{font-size:24px;font-weight:700;color:var(--accent)}
.stat-lbl{font-size:11px;color:var(--text2);margin-top:2px}
.stats-section{padding:0 16px 16px}
.stats-section h3{font-size:13px;font-weight:600;margin-bottom:8px;color:var(--text)}
.stat-bar{display:flex;align-items:center;gap:8px;margin-bottom:6px;font-size:12px}
.stat-bar-label{width:100px;text-align:left;color:var(--text2);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.stat-bar-track{flex:1;height:6px;background:var(--border);border-radius:3px;overflow:hidden}
.stat-bar-fill{height:100%;background:var(--accent);border-radius:3px;transition:.3s}
.stat-bar-val{width:40px;text-align:right;font-weight:600;font-size:11px}

/* ── COMPLOT PANEL ── */
.complot-cards{padding:16px;display:flex;flex-direction:column;gap:10px}
.complot-card{background:var(--bg);border-radius:var(--radius);padding:12px 16px;display:flex;align-items:center;gap:12px}
.complot-card i{font-size:20px;color:var(--accent)}
.complot-card .info{flex:1}
.complot-card .title{font-size:13px;font-weight:600}
.complot-card .count{font-size:11px;color:var(--text2)}

/* ── FOOTER ── */
#panel-footer{padding:10px 16px;border-top:1px solid var(--border);flex-shrink:0}
#panel-footer button{width:100%;padding:10px;border:none;background:var(--primary);color:#fff;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;display:flex;align-items:center;justify-content:center;gap:6px;transition:.15s}
#panel-footer button:hover{background:#334155}
#panel-footer button i{color:var(--accent)}

/* ── PAGINATION ── */
.pagination{display:flex;justify-content:center;align-items:center;gap:8px;padding:12px 16px;border-top:1px solid var(--border)}
.pagination button{padding:6px 12px;border:1px solid var(--border);background:var(--surface);border-radius:6px;cursor:pointer;font-size:12px;transition:.15s}
.pagination button:hover{background:var(--hover)}
.pagination button.active{background:var(--accent);color:#fff;border-color:var(--accent)}
.pagination span{font-size:12px;color:var(--text2)}

/* ── LOADING ── */
#loading{position:fixed;inset:0;background:rgba(255,255,255,.92);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;z-index:9999;font-size:15px;color:var(--text2)}
.spinner{width:36px;height:36px;border:3px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin .7s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* ── POPUP ── */
.leaflet-popup-content-wrapper{direction:rtl;font-family:'Segoe UI',Tahoma,Arial,sans-serif;border-radius:var(--radius)!important}
.leaflet-popup-content{margin:10px 14px!important;font-size:13px;line-height:1.6}
.popup-title{font-weight:700;font-size:14px;color:var(--primary);margin-bottom:4px}
.popup-row{display:flex;gap:6px}
.popup-row .k{color:var(--text2);min-width:60px}

/* ── PLANNING POPUP ── */
.planning-popup{direction:rtl;min-width:280px}
.planning-popup-header{display:flex;align-items:center;gap:8px;padding:6px 0 8px;border-bottom:2px solid var(--border);margin-bottom:6px}
.planning-cat-badge{display:inline-block;padding:2px 8px;border-radius:10px;font-size:11px;font-weight:600;color:#fff}
.planning-popup .popup-row{padding:2px 0;border-bottom:1px solid #f0f0f0}
.planning-popup .popup-row:last-child{border-bottom:none}
.planning-popup .popup-row .k{font-weight:600;min-width:80px;color:#555}
.planning-popup .popup-row .v{flex:1}
.planning-popup .plan-links{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap}
.planning-popup .plan-links a{display:inline-flex;align-items:center;gap:4px;padding:4px 10px;border-radius:6px;background:var(--accent-light);color:var(--accent);font-size:12px;font-weight:600;text-decoration:none;transition:.15s}
.planning-popup .plan-links a:hover{background:var(--accent);color:#fff}
.planning-area-badge{display:inline-block;background:#e8f5e9;color:#2e7d32;padding:1px 6px;border-radius:4px;font-size:12px;font-weight:600}

/* ── PLANNING LEGEND ── */
.planning-legend{position:absolute;bottom:30px;left:10px;background:#fff;border-radius:10px;box-shadow:0 2px 12px rgba(0,0,0,.15);padding:10px 14px;z-index:800;max-height:50vh;overflow-y:auto;direction:rtl;font-size:12px;min-width:180px}
.planning-legend-title{font-weight:700;font-size:13px;margin-bottom:6px;color:var(--primary);display:flex;align-items:center;justify-content:space-between}
.planning-legend-title button{background:none;border:none;cursor:pointer;color:var(--text2);font-size:14px}
.planning-legend-item{display:flex;align-items:center;gap:6px;padding:3px 2px;cursor:pointer;border-radius:4px;transition:.1s}
.planning-legend-item:hover{background:var(--hover)}
.planning-legend-item.off{opacity:.35}
.planning-legend-swatch{width:16px;height:12px;border-radius:3px;border:1px solid rgba(0,0,0,.15);flex-shrink:0}
.planning-legend-label{flex:1}
.planning-legend-count{color:var(--text2);font-size:11px}

/* ── PLANNING CATEGORY CHIPS ── */
.planning-cat-chips{display:flex;flex-wrap:wrap;gap:4px;padding:4px 8px}
.planning-cat-chip{display:inline-flex;align-items:center;gap:4px;padding:2px 8px;border-radius:12px;font-size:11px;cursor:pointer;border:1px solid;transition:.15s;user-select:none}
.planning-cat-chip.active{color:#fff}
.planning-cat-chip:not(.active){background:#fff;opacity:.6}
.planning-cat-chip:hover{opacity:1}

/* ── SEARCH PANEL ── */
.search-tabs{display:flex;gap:0;border-bottom:2px solid var(--border);margin:0 -16px;padding:0 16px}
.search-tab{flex:1;padding:9px 4px;text-align:center;cursor:pointer;font-size:12px;font-weight:500;color:var(--text2);border:none;background:none;border-bottom:3px solid transparent;margin-bottom:-2px;transition:.15s;white-space:nowrap}
.search-tab:hover{color:var(--text);background:var(--hover)}
.search-tab.active{color:var(--accent);font-weight:700;border-bottom-color:var(--accent);background:var(--accent-light)}
.search-tab i{margin-left:4px;font-size:12px}
.search-form{padding:16px}
.search-form label{display:block;font-size:12px;font-weight:600;color:var(--text2);margin-bottom:4px}
.search-form .field{margin-bottom:12px}
.search-form input{width:100%;padding:10px 12px;border:1px solid var(--border);border-radius:6px;font-size:14px;direction:rtl;outline:none;transition:.2s}
.search-form input:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(212,168,67,.15)}
.search-form .row{display:flex;gap:8px}
.search-form .row input{flex:1}
.search-btn{width:100%;padding:10px;border:none;background:var(--accent);color:#fff;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;display:flex;align-items:center;justify-content:center;gap:8px;transition:.15s}
.search-btn:hover{background:#c5972e}
.search-btn:disabled{opacity:.5;cursor:not-allowed}
.search-btn i{font-size:14px}

.search-result{padding:14px 16px;border-bottom:1px solid var(--border);cursor:pointer;transition:.12s}
.search-result:hover{background:var(--hover)}
.search-result-head{display:flex;align-items:center;gap:8px}
.search-result-icon{width:36px;height:36px;border-radius:var(--radius);display:flex;align-items:center;justify-content:center;font-size:15px;flex-shrink:0}
.search-result-icon.parcel-icon{background:#e0f2fe;color:#0284c7}
.search-result-icon.plan-icon{background:#fef3c7;color:#d97706}
.search-result-icon.address-icon{background:#f0fdf4;color:#16a34a}
.search-result-body{flex:1;min-width:0}
.search-result-title{font-weight:700;font-size:14px}
.search-result-sub{font-size:11.5px;color:var(--text2);margin-top:2px;display:flex;gap:8px;flex-wrap:wrap}
.search-result-sub span{display:flex;align-items:center;gap:3px}
.search-result-actions{display:flex;gap:6px;margin-top:8px}
.search-result-actions button{padding:4px 10px;border:1px solid var(--border);background:var(--surface);border-radius:5px;cursor:pointer;font-size:11px;display:flex;align-items:center;gap:4px;transition:.15s;color:var(--text)}
.search-result-actions button:hover{background:var(--accent-light);border-color:var(--accent)}
.search-result-actions button i{font-size:10px;color:var(--accent)}

.helka-list{padding:8px 16px;display:flex;flex-wrap:wrap;gap:4px}
.helka-chip{padding:3px 8px;background:var(--bg);border:1px solid var(--border);border-radius:4px;font-size:11px;cursor:pointer;transition:.12s}
.helka-chip:hover{background:var(--accent-light);border-color:var(--accent)}
.helka-chip.active{background:var(--accent);color:#fff;border-color:var(--accent)}

/* ── SEARCH HISTORY & FAVORITES ── */
.search-history-section{padding:8px 0;border-bottom:1px solid var(--border)}
.search-history-header{display:flex;align-items:center;justify-content:space-between;padding:6px 16px;font-size:12px;font-weight:700;color:var(--text2);cursor:pointer}
.search-history-header:hover{color:var(--text)}
.search-history-header i.toggle{font-size:10px;transition:.2s}
.search-history-header.open i.toggle{transform:rotate(-90deg)}
.search-history-items{max-height:0;overflow:hidden;transition:max-height .25s ease}
.search-history-section.open .search-history-items{max-height:400px;overflow-y:auto}
.search-history-item{display:flex;align-items:center;gap:8px;padding:6px 16px;cursor:pointer;font-size:12px;transition:.12s}
.search-history-item:hover{background:var(--bg)}
.search-history-item .sh-icon{width:24px;height:24px;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:10px;flex-shrink:0}
.search-history-item .sh-icon.parcel{background:#e0f2fe;color:#0284c7}
.search-history-item .sh-icon.plan{background:#fef3c7;color:#d97706}
.search-history-item .sh-icon.address{background:#f0fdf4;color:#16a34a}
.search-history-item .sh-label{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.search-history-item .sh-star{color:var(--border);font-size:12px;cursor:pointer;transition:.12s;padding:2px}
.search-history-item .sh-star:hover{color:#f59e0b}
.search-history-item .sh-star.starred{color:#f59e0b}
.search-history-item .sh-delete{color:var(--border);font-size:11px;cursor:pointer;transition:.12s;padding:2px}
.search-history-item .sh-delete:hover{color:#ef4444}
.search-history-clear{padding:4px 16px;font-size:11px;color:var(--text2);cursor:pointer;text-align:left}
.search-history-clear:hover{color:#ef4444}
.search-fav-btn{background:none;border:none;cursor:pointer;font-size:13px;color:var(--border);transition:.12s;padding:4px}
.search-fav-btn:hover{color:#f59e0b}
.search-fav-btn.starred{color:#f59e0b}

.search-loading{text-align:center;padding:20px;color:var(--text2);font-size:13px}
.search-loading i{margin-left:6px}

/* ── PARCEL CONTROLS (in block view) ── */
.parcel-toolbar{padding:10px 16px;background:var(--bg);border-bottom:1px solid var(--border);display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.parcel-toolbar label{font-size:11px;font-weight:600;color:var(--text2)}
.parcel-toolbar .sep{width:1px;height:18px;background:var(--border)}
.parcel-color-swatch{width:20px;height:20px;border-radius:4px;cursor:pointer;border:2px solid transparent;transition:.15s;display:inline-block}
.parcel-color-swatch:hover{transform:scale(1.15);border-color:var(--text)}
.parcel-color-swatch.active{border-color:var(--text);box-shadow:0 0 0 2px var(--accent-light)}
.parcel-mini-slider{-webkit-appearance:none;appearance:none;width:60px;height:5px;border-radius:3px;background:var(--border);outline:none;cursor:pointer;vertical-align:middle}
.parcel-mini-slider::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);cursor:pointer;border:2px solid #fff;box-shadow:0 1px 2px rgba(0,0,0,.2)}
.parcel-mini-slider::-moz-range-thumb{width:12px;height:12px;border-radius:50%;background:var(--accent);cursor:pointer;border:2px solid #fff}
.parcel-info-row{padding:6px 16px;font-size:11px;color:var(--text2);background:var(--bg);border-bottom:1px solid var(--border);display:flex;align-items:center;gap:6px}
.parcel-info-row i{color:var(--accent)}
.parcel-label{font-size:11px;font-weight:700;color:#1e293b;text-shadow:0 0 3px #fff,0 0 3px #fff,0 0 3px #fff,1px 1px 0 #fff,-1px -1px 0 #fff;white-space:nowrap;pointer-events:auto;text-align:center;line-height:1;cursor:grab}
.parcel-label-lg{font-size:13px}
.migrash-label{font-size:10px;font-weight:700;color:#065f46;text-shadow:0 0 3px #ecfdf5,0 0 3px #ecfdf5,0 0 3px #ecfdf5,1px 1px 0 #d1fae5,-1px -1px 0 #d1fae5;white-space:nowrap;pointer-events:auto;text-align:center;line-height:1;cursor:grab;background:rgba(209,250,229,0.6);padding:1px 3px;border-radius:3px;border:1px solid rgba(16,185,129,0.4)}
.migrash-label-lg{font-size:12px}
.parcel-label:active,.migrash-label:active{cursor:grabbing}
.label-reset-btn{border:1px solid var(--border);background:var(--surface);padding:3px 8px;border-radius:4px;cursor:pointer;font-size:10px;color:var(--text2);transition:.15s;display:inline-flex;align-items:center;gap:4px;margin-right:4px}
.label-reset-btn:hover{border-color:#ef4444;color:#ef4444}
@keyframes parcel-pulse{0%{opacity:1}50%{opacity:0.3}100%{opacity:1}}
.parcel-flash{animation:parcel-pulse 0.5s ease-in-out 6}
.layer-text-color-row{display:flex;align-items:center;gap:6px;padding:2px 0}
.layer-text-color-row label{font-size:10px;color:var(--text2);white-space:nowrap}
.migrash-labels-toggle{border:none;padding:3px 8px;border-radius:4px;cursor:pointer;font-size:10px;font-family:inherit;background:var(--surface2);color:var(--text2)}
.migrash-labels-toggle.on{background:var(--accent);color:#fff}
.add-layer-btn{border:none;background:#3b82f6;color:#fff;padding:3px 8px;border-radius:4px;font-size:10px;font-family:inherit;cursor:pointer;transition:.15s;white-space:nowrap}
.add-layer-btn:hover{background:#2563eb}
.add-layer-btn.added{background:#10b981}
.add-layer-btn.added:hover{background:#ef4444}
.plan-layer-group{border-bottom:1px solid var(--border)}
.parcel-toolbar .label-toggle{border:1px solid var(--border);background:var(--surface);padding:3px 10px;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600;color:var(--text2);transition:.15s;display:inline-flex;align-items:center;gap:4px}
.parcel-toolbar .label-toggle:hover{border-color:var(--accent);color:var(--accent)}
.parcel-toolbar .label-toggle.on{background:var(--accent);color:#fff;border-color:var(--accent)}

/* ── MAP TOOLS ── */
#map-tools{position:absolute;top:12px;left:12px;z-index:1000;display:flex;flex-direction:column;gap:4px}
.map-tool-btn{width:34px;height:34px;border:none;background:var(--surface);border-radius:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px;color:var(--text2);box-shadow:var(--shadow);transition:.15s;direction:ltr}
.map-tool-btn:hover{background:var(--accent-light);color:var(--accent)}
.map-tool-btn.active{background:var(--accent);color:#fff}
.map-tool-btn[title]:hover::after{content:attr(title);position:absolute;left:40px;background:var(--primary);color:#fff;padding:3px 8px;border-radius:4px;font-size:11px;white-space:nowrap;pointer-events:none}
#coord-display{position:absolute;bottom:12px;right:12px;background:rgba(30,41,59,.85);color:#fff;padding:4px 10px;border-radius:6px;font-size:11px;z-index:1000;direction:ltr;font-family:monospace}
.coord-pin-popup{direction:ltr;font-family:monospace;font-size:11px;line-height:1.6}
.coord-pin-popup .coord-line{display:flex;justify-content:space-between;gap:8px}
.coord-pin-popup .coord-label{color:#64748b;font-weight:600}
.coord-pin-popup .coord-value{color:#1e293b}
.coord-pin-popup .coord-actions{margin-top:4px;display:flex;gap:6px;justify-content:center}
.coord-pin-popup .coord-copy-btn{background:var(--accent);color:#fff;border:none;border-radius:4px;padding:2px 8px;cursor:pointer;font-size:10px;transition:.15s}
.coord-pin-popup .coord-copy-btn:hover{opacity:.8}
.coord-pin-popup .coord-delete-btn{background:#ef4444;color:#fff;border:none;border-radius:4px;padding:2px 8px;cursor:pointer;font-size:10px;transition:.15s}
.coord-pin-popup .coord-delete-btn:hover{opacity:.8}
#coord-pin-overlay{position:absolute;top:0;left:0;width:100%;height:100%;z-index:999;cursor:crosshair;display:none}
#measure-tooltip{position:absolute;z-index:2000;background:rgba(30,41,59,.9);color:#fff;padding:4px 10px;border-radius:6px;font-size:12px;pointer-events:none;display:none;direction:rtl}

/* ── IMAGE OVERLAY ── */
.img-overlay-handle{width:14px;height:14px;background:#fff;border:2px solid var(--accent);border-radius:50%;cursor:move;box-shadow:0 1px 4px rgba(0,0,0,.3);z-index:1100!important}
.img-overlay-handle.corner-nw{cursor:nw-resize}
.img-overlay-handle.corner-ne{cursor:ne-resize}
.img-overlay-handle.corner-sw{cursor:sw-resize}
.img-overlay-handle.corner-se{cursor:se-resize}
.img-overlay-handle.rotate{background:var(--accent);cursor:grab;width:12px;height:12px}
.img-overlay-ctrl{position:absolute;bottom:60px;left:12px;background:var(--surface);border-radius:var(--radius);box-shadow:var(--shadow);padding:8px 12px;z-index:1200;direction:rtl;font-size:12px;min-width:220px;display:none}
.img-overlay-ctrl .ctrl-title{font-weight:700;font-size:13px;margin-bottom:6px;display:flex;align-items:center;justify-content:space-between}
.img-overlay-ctrl .ctrl-row{display:flex;align-items:center;gap:6px;margin-bottom:4px}
.img-overlay-ctrl .ctrl-row label{min-width:50px;color:var(--text2);font-size:11px}
.img-overlay-ctrl .ctrl-row input[type=range]{flex:1;height:4px}
.img-overlay-ctrl .ctrl-row .val{font-size:11px;min-width:28px;text-align:center;color:var(--text)}
.img-overlay-ctrl .ctrl-actions{display:flex;gap:4px;margin-top:6px;flex-wrap:wrap}
.img-overlay-ctrl .ctrl-btn{border:none;padding:3px 8px;border-radius:4px;font-size:10px;cursor:pointer;font-weight:600;transition:.15s;display:flex;align-items:center;gap:3px;font-family:inherit}
.img-overlay-ctrl .ctrl-btn.primary{background:var(--accent);color:#fff}
.img-overlay-ctrl .ctrl-btn.danger{background:#ef4444;color:#fff}
.img-overlay-ctrl .ctrl-btn.secondary{background:var(--border);color:var(--text)}
.img-overlay-ctrl .ctrl-btn:hover{opacity:.85}
.leaflet-image-overlay-active{outline:2px dashed var(--accent);outline-offset:0}

/* ── DRAWING TOOLS ── */
#draw-toolbar{position:absolute;top:8px;left:50%;transform:translateX(-50%);z-index:1300;display:none;background:var(--surface);border-radius:var(--radius);box-shadow:0 2px 12px rgba(0,0,0,.15);padding:4px 6px;direction:rtl;gap:2px;align-items:center}
#draw-toolbar.visible{display:flex}
.draw-tb-btn{width:34px;height:34px;border:none;background:none;border-radius:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--text2);font-size:14px;transition:.15s;position:relative}
.draw-tb-btn:hover{background:var(--border);color:var(--text)}
.draw-tb-btn.active{background:var(--accent-light);color:var(--accent)}
.draw-tb-sep{width:1px;height:24px;background:var(--border);margin:0 2px}
.draw-tb-label{font-size:11px;color:var(--text2);padding:0 4px;white-space:nowrap}
.snap-indicator{width:10px;height:10px;background:rgba(239,68,68,.6);border:2px solid #fff;border-radius:50%;position:absolute;pointer-events:none;z-index:2000;box-shadow:0 0 6px rgba(239,68,68,.5);transform:translate(-50%,-50%);display:none}
.snap-indicator.visible{display:block}
#draw-props{position:absolute;bottom:60px;right:12px;background:var(--surface);border-radius:var(--radius);box-shadow:var(--shadow);padding:8px 12px;z-index:1200;direction:rtl;font-size:12px;min-width:200px;display:none}
#draw-props .ctrl-title{font-weight:700;font-size:13px;margin-bottom:6px;display:flex;align-items:center;justify-content:space-between}
#draw-props .ctrl-row{display:flex;align-items:center;gap:6px;margin-bottom:4px}
#draw-props .ctrl-row label{min-width:45px;color:var(--text2);font-size:11px}
#draw-props .ctrl-row input[type=range]{flex:1;height:4px}
#draw-props .ctrl-row input[type=color]{width:28px;height:22px;border:1px solid var(--border);border-radius:4px;padding:0;cursor:pointer}
#draw-props .ctrl-row input[type=text]{flex:1;border:1px solid var(--border);border-radius:4px;padding:2px 6px;font-size:11px;font-family:inherit;direction:rtl}
#draw-props .ctrl-row .val{font-size:11px;min-width:24px;text-align:center}
#draw-props .ctrl-actions{display:flex;gap:4px;margin-top:6px;flex-wrap:wrap}
.draw-shape-label{background:transparent;border:none;padding:2px 4px;font-size:12px;font-weight:700;color:#1e293b;text-shadow:0 0 3px #fff,0 0 3px #fff,0 0 3px #fff,0 0 3px #fff;white-space:nowrap;pointer-events:auto;cursor:pointer}
.draw-shape-label:hover{text-decoration:underline}

/* ── MEASUREMENT DIALOG ── */
#measure-dialog{position:absolute;top:50px;left:12px;width:320px;max-height:calc(100vh - 120px);background:var(--surface);border-radius:var(--radius);box-shadow:0 4px 24px rgba(0,0,0,.2);z-index:1400;direction:rtl;display:none;flex-direction:column;overflow:hidden}
#measure-dialog.visible{display:flex}
.mdlg-header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:var(--primary);color:#fff;flex-shrink:0}
.mdlg-header h3{margin:0;font-size:14px;font-weight:700}
.mdlg-header .mdlg-close{background:none;border:none;color:#fff;font-size:16px;cursor:pointer;opacity:.7;transition:.15s}
.mdlg-header .mdlg-close:hover{opacity:1}
.mdlg-tools{display:flex;gap:4px;padding:8px 10px;border-bottom:1px solid var(--border);flex-shrink:0;flex-wrap:wrap}
.mdlg-tool-btn{display:inline-flex;align-items:center;gap:5px;padding:6px 10px;border:1px solid var(--border);border-radius:6px;background:#fff;cursor:pointer;font-size:11px;font-weight:600;color:var(--text2);transition:.15s;white-space:nowrap}
.mdlg-tool-btn:hover{background:var(--hover);color:var(--text)}
.mdlg-tool-btn.active{background:var(--accent-light);color:var(--accent);border-color:var(--accent)}
.mdlg-tool-btn i{font-size:12px}
.mdlg-body{flex:1;overflow-y:auto;padding:8px 10px}
.mdlg-section{margin-bottom:8px}
.mdlg-section-title{font-size:11px;font-weight:700;color:var(--text2);margin-bottom:4px;display:flex;align-items:center;gap:4px}
.mdlg-item{display:flex;align-items:center;gap:6px;padding:5px 8px;border-radius:6px;transition:.1s;cursor:pointer;font-size:12px}
.mdlg-item:hover{background:var(--hover)}
.mdlg-item .mdlg-icon{width:22px;text-align:center;color:var(--accent);font-size:12px}
.mdlg-item .mdlg-name{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.mdlg-item .mdlg-val{font-weight:600;color:var(--primary);font-size:11px;white-space:nowrap}
.mdlg-item .mdlg-del{background:none;border:none;color:#ef4444;cursor:pointer;font-size:11px;padding:2px;opacity:.5;transition:.15s}
.mdlg-item .mdlg-del:hover{opacity:1}
.mdlg-empty{text-align:center;color:var(--text2);font-size:12px;padding:16px;font-style:italic}
.mdlg-footer{padding:6px 10px;border-top:1px solid var(--border);display:flex;gap:4px;flex-shrink:0}
.mdlg-footer button{flex:1;padding:5px;border:1px solid var(--border);border-radius:6px;background:#fff;cursor:pointer;font-size:11px;transition:.15s}
.mdlg-footer button:hover{background:var(--hover)}
.mdlg-footer button.danger{color:#ef4444;border-color:#fca5a5}
.mdlg-footer button.danger:hover{background:#fef2f2}

/* Dimension line labels */
.dim-label{background:rgba(255,255,255,.92);border:1px solid #3b82f6;border-radius:4px;padding:1px 6px;font-size:11px;font-weight:700;color:#1e40af;white-space:nowrap;pointer-events:auto;cursor:default;box-shadow:0 1px 3px rgba(0,0,0,.15)}
.dim-label-area{background:rgba(255,255,255,.92);border:1px solid #10b981;border-radius:4px;padding:2px 8px;font-size:12px;font-weight:700;color:#065f46;white-space:nowrap;pointer-events:auto;cursor:default;box-shadow:0 1px 3px rgba(0,0,0,.15)}

/* ── EMPTY STATE ── */
.empty{padding:40px 16px;text-align:center;color:var(--text2)}
.empty i{font-size:36px;margin-bottom:12px;color:#cbd5e1}
.empty p{font-size:13px}

/* ── RESPONSIVE ── */
@media(max-width:768px){
  :root{--sidebar-w:calc(100vw - var(--strip-w))}
  #sidebar{width:100%;position:absolute;right:0;top:var(--topbar-h);bottom:0;z-index:2000}
  #sidebar.collapsed{transform:translateX(100%)}
  .topbar-sub{display:none}
}

/* ── LEAFLET LAYER CONTROL RTL FIX ── */
.leaflet-control-layers{direction:ltr;text-align:left}
.leaflet-control-layers label{font-size:13px;padding:3px 0;cursor:pointer}
.leaflet-control-layers-toggle{width:36px!important;height:36px!important}

/* ── COMPARE MODE ── */
#compare-panel{position:absolute;top:8px;left:50%;transform:translateX(-50%);z-index:2100;background:rgba(15,23,42,.95);color:#fff;border-radius:12px;padding:12px 16px;display:none;gap:12px;align-items:flex-start;box-shadow:0 4px 24px rgba(0,0,0,.5);min-width:500px;max-width:90vw;direction:rtl;flex-wrap:wrap}
#compare-panel.active{display:flex}
.compare-side{flex:1;min-width:180px;display:flex;flex-direction:column;gap:6px}
.compare-side-title{font-size:11px;color:#94a3b8;font-weight:600;display:flex;align-items:center;gap:6px}
.compare-side-title i{font-size:13px}
.compare-side-title.left-side{color:#60a5fa}
.compare-side-title.right-side{color:#f97316}
.compare-select{background:#1e293b;color:#fff;border:1px solid #334155;border-radius:6px;padding:5px 8px;font-size:12px;width:100%;cursor:pointer;outline:none}
.compare-select:focus{border-color:var(--accent,#d4a843)}
.compare-opacity-row{display:flex;align-items:center;gap:6px;font-size:11px;color:#94a3b8}
.compare-opacity-row input{flex:1;accent-color:var(--accent,#d4a843)}
.compare-close-btn{background:#ef4444;border:none;color:#fff;border-radius:6px;padding:5px 12px;cursor:pointer;font-size:12px;align-self:flex-start;white-space:nowrap}
.compare-close-btn:hover{background:#dc2626}
.compare-presets{display:flex;flex-wrap:wrap;gap:4px;margin-top:2px}
.compare-preset-btn{background:#1e293b;border:1px solid #334155;color:#94a3b8;border-radius:5px;padding:3px 8px;font-size:10px;cursor:pointer;white-space:nowrap;transition:.15s}
.compare-preset-btn:hover{border-color:var(--accent,#d4a843);color:var(--accent,#d4a843)}
/* Swipe divider */
#compare-divider{position:absolute;top:0;bottom:0;width:3px;background:linear-gradient(to bottom,#60a5fa,#f97316);z-index:1050;cursor:ew-resize;display:none;transform:translateX(-50%);transition:none}
#compare-divider::before{content:'';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:36px;height:36px;background:rgba(15,23,42,.9);border:2px solid rgba(255,255,255,.4);border-radius:50%;cursor:ew-resize;box-shadow:0 2px 12px rgba(0,0,0,.5)}
#compare-divider::after{content:'⟨⟩';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:13px;color:#fff;pointer-events:none;margin-top:0}
#compare-divider-label-left{position:absolute;top:12px;right:calc(100% + 10px);background:rgba(15,23,42,.85);color:#60a5fa;border-radius:6px;padding:3px 8px;font-size:11px;white-space:nowrap;pointer-events:none}
#compare-divider-label-right{position:absolute;top:12px;left:calc(100% + 10px);background:rgba(15,23,42,.85);color:#f97316;border-radius:6px;padding:3px 8px;font-size:11px;white-space:nowrap;pointer-events:none}
#compare-mode-badge{position:absolute;top:8px;left:50%;transform:translateX(-50%);background:rgba(96,165,250,.15);color:#60a5fa;border:1px solid #3b82f6;border-radius:8px;padding:5px 12px;font-size:11px;z-index:1100;display:none;align-items:center;gap:6px;cursor:pointer;white-space:nowrap}
#compare-mode-badge:hover{background:rgba(96,165,250,.25)}
#compare-mode-badge.active{display:flex}
</style>
</head>
<body>
<div id="app">
  <!-- TOP BAR -->
  <header id="topbar">
    <div class="topbar-logo">
      <i class="fas fa-map-marked-alt"></i>
      <span>Gush Helka Map</span>
    </div>
    <div class="topbar-sep"></div>
    <div class="topbar-sub">כפר חב"ד — גושים, חלקות ותב"עות</div>
    <div class="topbar-spacer"></div>
    <button class="topbar-btn" onclick="app.toggleSidebar()" title="הסתר/הצג סרגל"><i class="fas fa-columns"></i></button>
    <button class="topbar-btn" onclick="app.fitBounds()" title="מסגרת מפה"><i class="fas fa-expand"></i></button>
  </header>

  <!-- MAIN -->
  <div id="main">
    <!-- SIDEBAR -->
    <aside id="sidebar">
      <div id="icon-strip">
        <button class="strip-btn active" data-panel="data" title="נתונים"><i class="fas fa-clipboard-list"></i></button>
        <button class="strip-btn" data-panel="layers" title="שכבות GIS"><i class="fas fa-layer-group"></i><span class="strip-badge" id="layers-badge" style="display:none">0</span></button>
        <button class="strip-btn" data-panel="search" title="חיפוש מתקדם"><i class="fas fa-search-plus"></i></button>
        <button class="strip-btn" data-panel="complot" title="Complot"><i class="fas fa-building"></i></button>
        <button class="strip-btn" data-panel="stats" title="סטטיסטיקות"><i class="fas fa-chart-pie"></i></button>
        <div class="strip-spacer"></div>
        <button class="strip-btn" data-panel="settings" title="הגדרות"><i class="fas fa-cog"></i></button>
      </div>
      <div id="panel">
        <div id="panel-head">
          <div id="panel-title-row">
            <i class="fas fa-clipboard-list"></i>
            <span id="panel-title-text">נתונים</span>
          </div>
          <div class="tabs" id="data-tabs">
            <button class="tab active" data-tab="blocks"><span class="cnt" id="cnt-blocks">-</span><span class="lbl">גושים</span></button>
            <button class="tab" data-tab="plans"><span class="cnt" id="cnt-plans">-</span><span class="lbl">תכניות</span></button>
            <button class="tab" data-tab="documents"><span class="cnt" id="cnt-docs">-</span><span class="lbl">מסמכים</span></button>
          </div>
        </div>
        <div id="search-box">
          <div class="search-row">
            <input type="text" id="search-input" placeholder="חיפוש גוש, תכנית או מסמך..." oninput="app.onSearch(this.value)">
            <button onclick="app.onSearch(document.getElementById('search-input').value)"><i class="fas fa-search"></i></button>
          </div>
        </div>
        <div id="panel-content"></div>
        <div id="panel-footer">
          <button onclick="app.switchPanel('stats')"><i class="fas fa-chart-bar"></i> סיכום נתונים</button>
        </div>
      </div>
    </aside>

    <!-- MAP -->
    <div id="map-wrap">
      <div id="map"></div>
      <input type="file" id="dxf-file-input" accept=".dxf,.dwg" style="display:none" onchange="app.handleDxfUpload(this)">
      <input type="file" id="shp-file-input" accept=".zip,.shp" style="display:none" onchange="app.handleShpUpload(this)">
      <input type="file" id="img-overlay-input" accept="image/*,.pdf" style="display:none" onchange="app.handleImageOverlayUpload(this)">
      <div id="coord-pin-overlay"></div>
      <div id="img-overlay-ctrl" class="img-overlay-ctrl">
        <div class="ctrl-title">
          <span><i class="fas fa-image" style="margin-left:4px"></i> שכבת תמונה</span>
          <button class="ctrl-btn danger" onclick="app.removeActiveImageOverlay()" title="הסר"><i class="fas fa-trash"></i></button>
        </div>
        <div class="ctrl-row">
          <label>שקיפות</label>
          <input type="range" min="5" max="100" value="70" oninput="app.setImageOverlayOpacity(this.value/100);this.nextElementSibling.textContent=this.value+'%'">
          <span class="val">70%</span>
        </div>
        <div class="ctrl-actions">
          <button class="ctrl-btn secondary" onclick="app.toggleImageOverlayLock()" id="img-lock-btn" title="נעל/שחרר"><i class="fas fa-lock-open"></i> שחרור</button>
          <button class="ctrl-btn secondary" onclick="app.fitImageOverlay()" title="התאם לתצוגה"><i class="fas fa-expand"></i> מסגרת</button>
          <button class="ctrl-btn secondary" onclick="app.resetImageOverlayRotation()" title="אפס סיבוב"><i class="fas fa-undo"></i> אפס סיבוב</button>
        </div>
        <div style="margin-top:6px;font-size:10px;color:var(--text2)">גרור פינות לשינוי גודל • גרור מרכז להזזה • Shift+גרירה לסיבוב</div>
      </div>
      <div id="map-tools">
        <button class="map-tool-btn" onclick="app.toggleMeasure('distance')" id="measure-distance-btn" title="מדידת מרחק"><i class="fas fa-ruler"></i></button>
        <button class="map-tool-btn" onclick="app.toggleMeasure('area')" id="measure-area-btn" title="מדידת שטח"><i class="fas fa-ruler-combined"></i></button>
        <button class="map-tool-btn" onclick="app.clearMeasure()" title="נקה מדידות"><i class="fas fa-eraser"></i></button>
        <button class="map-tool-btn" onclick="app.toggleMeasureDialog()" id="measure-dialog-btn" title="מדידות ותמחון"><i class="fas fa-drafting-compass"></i></button>
        <button class="map-tool-btn" onclick="app.toggleCoordPin()" id="coord-pin-btn" title="הוסף תג קואורדינטות"><i class="fas fa-map-pin"></i></button>
        <button class="map-tool-btn" onclick="app.clearCoordPins()" title="נקה תגי קואורדינטות"><i class="fas fa-times-circle"></i></button>
        <button class="map-tool-btn" onclick="app.exportView()" title="ייצוא תמונה"><i class="fas fa-camera"></i></button>
        <div style="width:1px;height:24px;background:var(--border);margin:0 2px"></div>
        <button class="map-tool-btn" onclick="app.triggerImageOverlay()" id="img-overlay-btn" title="הוסף שכבת תמונה"><i class="fas fa-image"></i></button>
        <div style="width:1px;height:24px;background:var(--border);margin:0 2px"></div>
        <button class="map-tool-btn" onclick="app.toggleDrawMode()" id="draw-mode-btn" title="כלי ציור"><i class="fas fa-pen-fancy"></i></button>
        <div style="width:1px;height:24px;background:var(--border);margin:0 2px"></div>
        <button class="map-tool-btn" onclick="app.toggleCompareMode()" id="compare-mode-btn" title="השוואת שכבות"><i class="fas fa-columns"></i></button>
      </div>
      <div id="draw-toolbar">
        <span class="draw-tb-label"><i class="fas fa-pen-fancy"></i> ציור:</span>
        <button class="draw-tb-btn" onclick="app.setDrawTool('polyline')" id="dt-polyline" title="קו"><i class="fas fa-minus"></i></button>
        <button class="draw-tb-btn" onclick="app.setDrawTool('polygon')" id="dt-polygon" title="פוליגון"><i class="fas fa-draw-polygon"></i></button>
        <button class="draw-tb-btn" onclick="app.setDrawTool('circle')" id="dt-circle" title="עיגול"><i class="fas fa-circle"></i></button>
        <button class="draw-tb-btn" onclick="app.setDrawTool('rectangle')" id="dt-rectangle" title="מלבן"><i class="fas fa-vector-square"></i></button>
        <div class="draw-tb-sep"></div>
        <button class="draw-tb-btn" onclick="app.setDrawTool('marker')" id="dt-marker" title="סימן"><i class="fas fa-map-marker-alt"></i></button>
        <button class="draw-tb-btn" onclick="app.setDrawTool('text')" id="dt-text" title="טקסט"><i class="fas fa-font"></i></button>
        <div class="draw-tb-sep"></div>
        <button class="draw-tb-btn" onclick="app.toggleSnap()" id="dt-snap" title="סנאפ לקודקודים"><i class="fas fa-magnet"></i></button>
        <div class="draw-tb-sep"></div>
        <button class="draw-tb-btn" onclick="app.undoLastDraw()" title="בטל אחרון"><i class="fas fa-undo"></i></button>
        <button class="draw-tb-btn" onclick="app.clearAllDrawings()" title="נקה הכל" style="color:#ef4444"><i class="fas fa-trash"></i></button>
        <button class="draw-tb-btn" onclick="app.toggleDrawMode()" title="סגור" style="color:#ef4444"><i class="fas fa-times"></i></button>
      </div>
      <div id="snap-indicator" class="snap-indicator"></div>
      <div id="draw-props"></div>
      <div id="coord-display">--</div>
      <div id="measure-tooltip"></div>
      <!-- Measurement Dialog -->
      <div id="measure-dialog">
        <div class="mdlg-header">
          <h3><i class="fas fa-drafting-compass"></i> מדידות ותמחון</h3>
          <button class="mdlg-close" onclick="app.closeMeasureDialog()"><i class="fas fa-times"></i></button>
        </div>
        <div class="mdlg-tools">
          <button class="mdlg-tool-btn" onclick="app.setMeasureTool('line')" id="mt-line" title="מדידת קו">
            <i class="fas fa-ruler"></i> קו
          </button>
          <button class="mdlg-tool-btn" onclick="app.setMeasureTool('area')" id="mt-area" title="מדידת שטח">
            <i class="fas fa-ruler-combined"></i> שטח
          </button>
          <button class="mdlg-tool-btn" onclick="app.setMeasureTool('dimension')" id="mt-dimension" title="קו מידה">
            <i class="fas fa-arrows-alt-h"></i> מידה
          </button>
          <button class="mdlg-tool-btn" onclick="app.setMeasureTool('sketch')" id="mt-sketch" title="תמחון שטח">
            <i class="fas fa-pencil-ruler"></i> תמחון
          </button>
        </div>
        <div class="mdlg-body" id="measure-list">
          <div class="mdlg-empty">לחץ על כלי למעלה להתחיל מדידה</div>
        </div>
        <div class="mdlg-footer">
          <button onclick="app.exportMeasurements()" title="ייצוא"><i class="fas fa-download"></i> ייצוא</button>
          <button class="danger" onclick="app.clearAllMeasurements()" title="נקה הכל"><i class="fas fa-trash"></i> נקה הכל</button>
        </div>
      </div>
      <div id="map-info">
        <span><i class="fas fa-map-pin"></i> כפר חב"ד</span>
        <span><i class="fas fa-th"></i> <span id="mi-blocks">-</span> גושים</span>
        <span><i class="fas fa-file-alt"></i> <span id="mi-plans">-</span> תכניות</span>
        <span><i class="fas fa-layer-group"></i> <span id="mi-layers">0</span> שכבות פעילות</span>
      </div>
      <!-- COMPARE MODE panel -->
      <div id="compare-panel">
        <div class="compare-side">
          <div class="compare-side-title right-side"><i class="fas fa-arrow-left"></i> צד ימין</div>
          <select class="compare-select" id="compare-right-select" onchange="app.setCompareLayer('right',this.value)"></select>
          <div class="compare-opacity-row">
            <span>שקיפות</span>
            <input type="range" min="0" max="100" value="100" id="compare-right-opacity"
              oninput="app.setCompareOpacity('right',this.value/100);this.nextElementSibling.textContent=this.value+'%'">
            <span>100%</span>
          </div>
        </div>
        <div style="display:flex;flex-direction:column;gap:6px;align-items:center;justify-content:center;padding:0 4px">
          <div style="font-size:10px;color:#475569;text-align:center">קבועים</div>
          <div class="compare-presets" id="compare-presets"></div>
        </div>
        <div class="compare-side">
          <div class="compare-side-title left-side"><i class="fas fa-arrow-right"></i> צד שמאל</div>
          <select class="compare-select" id="compare-left-select" onchange="app.setCompareLayer('left',this.value)"></select>
          <div class="compare-opacity-row">
            <span>שקיפות</span>
            <input type="range" min="0" max="100" value="100" id="compare-left-opacity"
              oninput="app.setCompareOpacity('left',this.value/100);this.nextElementSibling.textContent=this.value+'%'">
            <span>100%</span>
          </div>
        </div>
        <button class="compare-close-btn" onclick="app.toggleCompareMode()"><i class="fas fa-times"></i> סגור</button>
      </div>
      <!-- Compare swipe divider -->
      <div id="compare-divider">
        <div id="compare-divider-label-left"></div>
        <div id="compare-divider-label-right"></div>
      </div>
      <!-- Compare mode badge -->
      <div id="compare-mode-badge" onclick="app.toggleComparePanel()">
        <i class="fas fa-columns"></i> השואה פעילה — לחץ לערוך
      </div>
      <div id="scale-widget">
        <div id="scale-presets-bar"></div>
        <div id="scale-input-row" style="display:none">
          <span style="font-size:11px;color:#94a3b8">1&thinsp;:</span>
          <input id="scale-input" type="number" min="100" max="500000" step="100" placeholder="קנה מידה" onkeydown="if(event.key==='Enter')app.applyScaleInput();if(event.key==='Escape')app.toggleScaleInput()" />
          <button onclick="app.applyScaleInput()">✓</button>
          <button onclick="app.addCurrentScalePreset()" title="שמור כקיצור" style="background:#475569">★</button>
          <button onclick="app.toggleScaleInput()" style="background:#475569;color:#94a3b8">✕</button>
        </div>
        <div id="scale-bar-wrap" onclick="app.toggleScaleInput()" title="לחץ להזנת קנה מידה">
          <div class="scale-ratio" id="scale-ratio-lbl">1 : —</div>
          <div class="scale-bar-line">
            <span class="scale-bar-end"></span>
            <span class="scale-bar-mid" id="scale-bar-mid" style="width:100px"></span>
            <span class="scale-bar-end"></span>
          </div>
          <div class="scale-label" id="scale-bar-lbl">— מ'</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- DOCUMENT VIEWER -->
<div class="viewer-overlay" id="doc-viewer">
  <div class="viewer-toolbar">
    <button class="vt-btn" onclick="docViewer.close()" title="סגור (Esc)"><i class="fas fa-times"></i></button>
    <div class="vt-sep"></div>
    <button class="vt-btn" onclick="docViewer.prevDoc()" title="מסמך קודם"><i class="fas fa-chevron-right"></i></button>
    <button class="vt-btn" onclick="docViewer.nextDoc()" title="מסמך הבא"><i class="fas fa-chevron-left"></i></button>
    <div class="vt-sep"></div>
    <button class="vt-btn" onclick="docViewer.zoomOut()" title="הקטן"><i class="fas fa-search-minus"></i></button>
    <span class="vt-zoom" id="viewer-zoom">100%</span>
    <button class="vt-btn" onclick="docViewer.zoomIn()" title="הגדל"><i class="fas fa-search-plus"></i></button>
    <button class="vt-btn" onclick="docViewer.fitWidth()" title="רוחב מלא"><i class="fas fa-arrows-alt-h"></i></button>
    <div class="vt-sep"></div>
    <button class="vt-btn" onclick="docViewer.rotateCW()" title="סובב"><i class="fas fa-redo"></i></button>
    <button class="vt-btn" id="viewer-sidebar-btn" onclick="docViewer.toggleSidebar()" title="תמונות ממוזערות"><i class="fas fa-th-list"></i></button>
    <button class="vt-btn" onclick="docViewer.toggleFullscreen()" title="מסך מלא"><i class="fas fa-expand"></i></button>
    <div class="vt-sep"></div>
    <button class="vt-btn" onclick="docViewer.download()" title="הורד"><i class="fas fa-download"></i></button>
    <button class="vt-btn" onclick="docViewer.print()" title="הדפס"><i class="fas fa-print"></i></button>
    <div class="vt-sep"></div>
    <span class="vt-plan" id="viewer-plan"></span>
    <span class="vt-title" id="viewer-title"></span>
  </div>
  <div class="viewer-body">
    <div class="viewer-sidebar" id="viewer-sidebar">
      <div class="vs-head">עמודים</div>
      <div id="viewer-thumbs"></div>
    </div>
    <div class="viewer-content" id="viewer-content">
      <div class="viewer-loading" id="viewer-loading" style="display:none"><i class="fas fa-spinner"></i></div>
    </div>
    <button class="viewer-nav-arrow prev" onclick="docViewer.prevDoc()" title="מסמך קודם"><i class="fas fa-chevron-right"></i></button>
    <button class="viewer-nav-arrow next" onclick="docViewer.nextDoc()" title="מסמך הבא"><i class="fas fa-chevron-left"></i></button>
  </div>
</div>

<!-- LOADING -->
<div id="loading"><div class="spinner"></div><div>טוען נתונים...</div></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.js"></script>
<script>
// EPSG:2039 — Israel 1993 / Israeli TM Grid
// Uses EPSG:1184 7-parameter Helmert transformation (accuracy ~1m).
// Rotation signs converted from coordinate-frame to position-vector convention for proj4.
proj4.defs('EPSG:2039', '+proj=tmerc +lat_0=31.73439361111111 +lon_0=35.20451694444445 +k=1.0000067 +x_0=219529.584 +y_0=626907.39 +ellps=GRS80 +towgs84=23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262 +units=m +no_defs');
function itmToLatLng(coords) {
  const x = coords[0], y = coords[1];
  // Auto-detect: if coords are large (>1000) they are ITM, otherwise already WGS84
  if (Math.abs(x) > 1000 || Math.abs(y) > 1000) {
    const [lng, lat] = proj4('EPSG:2039', 'EPSG:4326', [x, y]);
    return L.latLng(lat, lng);
  }
  return L.latLng(coords[1], coords[0]);
}

// Hebrew translation map for GIS layer names
const LAYER_HEB = {
  // אחר
  'arcgis_defibrillators_view': 'דפיברילטורים',
  'drainage_projects': 'פרויקטי ניקוז',
  'functional_areas': 'אזורים פונקציונליים',
  'raw_materials': 'חומרי גלם',
  // גז ודלק
  'gas_fuel_pipes': 'צינורות דלק',
  'gas_pipelines': 'קווי גז',
  'gas_stations': 'תחנות דלק',
  'gas_survey_area': 'אזור סקר גז',
  // גבולות
  'gvulot_district': 'גבולות מחוז',
  'gvulot_local_councils': 'גבולות מועצות מקומיות',
  'gvulot_municipal': 'גבולות מוניציפליים',
  'gvulot_planning_areas': 'גבולות אזורי תכנון',
  'gvulot_sub_districts': 'גבולות נפות',
  // תחבורה
  'road_compilation_detailed': 'כבישים - מפורט',
  'road_compilation_interchanges': 'מחלפים',
  'road_compilation_roads': 'כבישים',
  'train_compilation': 'מסילות רכבת',
  // שימור
  'shimour_points': 'אתרי שימור - נקודות',
  'shimour_polygons': 'אתרי שימור - פוליגונים',
  // תמ"א 1 - תשתיות
  'tama1_electricity': 'חשמל',
  'tama1_flood': 'הצפות',
  'tama1_forest': 'יערות',
  'tama1_gas_pipeline': 'צינורות גז',
  'tama1_nature': 'שמורות טבע',
  'tama1_quarry': 'מחצבות',
  'tama1_roads': 'כבישים',
  'tama1_stream': 'נחלים',
  'tama1_train': 'רכבת',
  'tama1_waste': 'פסולת',
  'tama1_water_pipe': 'צינורות מים',
  'tama1_water_protect': 'הגנת מים',
  'tama1_water_storage': 'אגירת מים',
  // תמ"א 35
  'tama35_conservation': 'שימור',
  'tama35_eco_corridor': 'מסדרון אקולוגי',
  'tama35_env_electricity': 'סביבה - חשמל',
  'tama35_env_landscape': 'סביבה - נוף',
  'tama35_env_noise': 'סביבה - רעש',
  'tama35_env_recharge': 'סביבה - חידור מים',
  'tama35_env_security': 'סביבה - ביטחון',
  'tama35_env_water_protect': 'סביבה - הגנת מים',
  'tama35_forests': 'יערות',
  'tama35_landscape': 'נוף',
  'tama35_nature_reserves': 'שמורות טבע',
  'tama35_roads': 'כבישים',
  'tama35_textures': 'מרקמים',
  'tama35_train': 'רכבת',
  // תמ"מ 3/21
  'tmm321_birds_natbag': 'ציפורים - נתב"ג',
  'tmm321_electricity': 'חשמל',
  'tmm321_fire_area': 'אזור שרפות',
  'tmm321_gas': 'גז',
  'tmm321_height_limit': 'מגבלת גובה',
  'tmm321_heritage': 'מורשת',
  'tmm321_interchanges': 'מחלפים',
  'tmm321_land_use': 'ייעודי קרקע',
  'tmm321_municipal_border': 'גבול מוניציפלי',
  'tmm321_nature': 'טבע',
  'tmm321_noise_natbag': 'רעש - נתב"ג',
  'tmm321_plan_border': 'גבול תכנית',
  'tmm321_rail': 'מסילה',
  'tmm321_roads': 'כבישים',
  'tmm321_scenic_road': 'דרך נופית',
  'tmm321_sewage': 'ביוב',
  'tmm321_stations': 'תחנות',
  'tmm321_streams': 'נחלים',
  'tmm321_transport_center': 'מרכז תחבורה',
  'tmm321_valued_area': 'אזור ערכי',
  'tmm321_waste': 'פסולת',
  'tmm321_water': 'מים',
  // תמ"מ 3/21 shichvot
  'tmm321_layer1_\u05ea\u05de\u05de_3__21___\u05de\u05e1\u05e4\u05e8\u05d9_\u05db\u05d1\u05d9\u05e9\u05d9\u05dd': 'מספרי כבישים',
  'tmm321_layer10_\u05ea\u05de\u05de_3__21___\u05db\u05d1\u05d9\u05e9\u05d9\u05dd': 'כבישים',
  'tmm321_layer12_\u05ea\u05de\u05de_3__21___\u05de\u05e1\u05d9\u05dc\u05d4': 'מסילה',
  'tmm321_layer13_\u05ea\u05de\u05de_3__21___\u05e9\u05de\u05d5\u05ea_\u05d9\u05e9\u05d5\u05d1\u05d9\u05dd': 'שמות יישובים',
  'tmm321_layer16_\u05ea\u05de\u05de_3__21___\u05de\u05e8\u05db\u05d6_\u05ea\u05d7\u05d1\u05d5\u05e8\u05d4': 'מרכז תחבורה',
  'tmm321_layer21_\u05ea\u05de\u05de_3__21___\u05e0\u05d7\u05dc\u05d9\u05dd': 'נחלים',
  'tmm321_layer26_\u05ea\u05de\u05de_3__21___\u05d2\u05d1\u05d5\u05dc_\u05de\u05d5\u05e0\u05d9\u05e6\u05d9\u05e4\u05dc\u05d9': 'גבול מוניציפלי',
  'tmm321_layer27_\u05ea\u05de\u05de_3__21___\u05d2\u05d1\u05d5\u05dc_\u05ea\u05db\u05e0\u05d9\u05ea': 'גבול תכנית',
  'tmm321_layer28_\u05ea\u05de\u05de_3__21___\u05d9\u05e2\u05d5\u05d3\u05d9_\u05e7\u05e8\u05e7\u05e2': 'ייעודי קרקע',
  'tmm321_layer4_\u05ea\u05de\u05de_3__21___\u05e7\u05d5\u05d5\u05d9_\u05d7\u05e9\u05de\u05dc': 'קווי חשמל',
  'tmm321_layer5_\u05ea\u05de\u05de_3__21____\u05e0\u05ea\u05d1_\u05d2__\u05de\u05d2\u05d1\u05dc\u05d5\u05ea_\u05e8\u05e2\u05e9': 'נתב"ג - מגבלות רעש',
  'tmm321_layer8_\u05ea\u05de\u05de_\u05e0\u05ea\u05d1\u05d2___\u05d2\u05d1\u05d5\u05dc_\u05d4\u05e9\u05e7\u05de\u05d0': 'נתב"ג - גבול השקמא',
  'tmm321_layer9_\u05ea\u05de\u05de_3__21___\u05de\u05d7\u05dc\u05e4\u05d9\u05dd': 'מחלפים',
  // מכלול תמ"מ מרכז
  'tmm_merkaz_layer1_\u05d2\u05d1\u05d5\u05dc_\u05e9\u05d9\u05e0\u05d5\u05d9\u05d9_\u05ea\u05de_\u05de\u05d9\u05dd': 'גבול שינויי תמ"מ',
  'tmm_merkaz_layer10_\u05e1\u05d9\u05de\u05d1\u05d5\u05dc\u05d9\u05dd': 'סימבולים',
  'tmm_merkaz_layer11_\u05e7\u05d5\u05d5\u05d9\u05dd': 'קווים',
  'tmm_merkaz_layer12_\u05d9\u05e2\u05d5\u05d3\u05d9_\u05e7\u05e8\u05e7\u05e2': 'ייעודי קרקע',
  'tmm_merkaz_layer13_\u05dc\u05d9\u05d9\u05d1\u05dc_\u05d9\u05e9\u05d5\u05d1\u05d9\u05dd': 'תוויות יישובים',
  'tmm_merkaz_layer2_\u05d2\u05d1\u05d5\u05dc_\u05de\u05d7\u05d5\u05d6': 'גבול מחוז',
  'tmm_merkaz_layer3_\u05d0\u05d6\u05d5\u05e8\u05d9\u05dd_\u05dc\u05d1\u05d9\u05e8\u05d5\u05e8': 'אזורים לבירור',
  'tmm_merkaz_layer8_\u05de\u05d2\u05d1\u05dc\u05d5\u05ea_\u05e4\u05d5\u05dc\u05d9\u05d2\u05d5\u05df': 'מגבלות - פוליגון',
  // תת"ל / ותמ"ל
  'ttl_blue_lines': 'קווים כחולים',
  'vatmal_compounds': 'מתחמי ותמ"ל',
  // Xplan
  'xplan_land_use': 'ייעודי קרקע',
  'xplan_lines': 'קווים',
  'xplan_points': 'נקודות',
  'xplan_polygons': 'פוליגונים',
};
function layerHeb(name) {
  const stem = name.replace(/\.geojson$/, '');
  return LAYER_HEB[stem] || stem.replace(/_/g, ' ');
}
</script>
<script>
/* ═══════════════════════════════════════════
   Gush Helka Map — Main Application
   ═══════════════════════════════════════════ */
class GushHelkaApp {
  constructor() {
    this.map = null;
    this.data = null;
    this.documents = null;
    this.currentPanel = 'data';
    this.currentTab = 'blocks';
    this.searchQuery = '';
    this.activeLayers = new Map();
    this.layerStyles = {};  // file -> {color, opacity}
    this._colorPaletteOpen = null; // track which layer has color palette open
    this.selectedBlock = null;
    this._parcelsLayer = null;  // Parcels subdivision layer for selected block
    this._parcelLabelsLayer = null; // Parcel number labels layer
    this._showParcelLabels = true;  // Show parcel numbers on map
    this._parcelColor = '#e11d48';
    this._parcelOpacity = 0.15;
    this._parcelWeight = 2;
    this._highlightedParcel = null;
    // Migrash layer
    this._migrashLayer = null;
    this._migrashLabelsLayer = null;
    this._migrashData = null;
    this._migrashColor = '#10b981';
    this._migrashTextColor = '#1e293b';
    this._migrashOpacity = 0.25;
    this._migrashWeight = 3;
    this._showMigrashLabels = true;
    this._migrashOn = false;
    this._parcelsOn = true; // parcels layer visible by default when loaded
    this._labelPositions = JSON.parse(localStorage.getItem('labelPositions') || '{}'); // saved dragged label positions
    this._categoryOrder = JSON.parse(localStorage.getItem('categoryOrder') || '[]'); // saved category display order
    this._layerOrder = JSON.parse(localStorage.getItem('layerOrder') || '{}'); // saved layer order within categories: { cat: [file1, file2...] }
    this._layerRenames = JSON.parse(localStorage.getItem('layerRenames') || '{}'); // custom display names: key -> name
    this._catRenames = JSON.parse(localStorage.getItem('catRenames') || '{}'); // category renames: origName -> newName
    this._hiddenLayers = new Set(JSON.parse(localStorage.getItem('hiddenLayers') || '[]')); // deleted GIS layer files
    this._hiddenCategories = new Set(JSON.parse(localStorage.getItem('hiddenCategories') || '[]')); // deleted categories
    this._planLayers = new Map(); // planNumber -> { layer, color, name }
    this._dxfLayers = new Map(); // id -> { layer, name, color, geojson, dxfLayers, visibleDxfLayers, savedName }
    this._dxfIdCounter = 0;
    this._savedLayersList = []; // list of saved geojson files from server
    // Scale widget
    this._scalePresets = JSON.parse(localStorage.getItem('scalePresets') || 'null') ||
      [500, 1000, 2500, 5000, 10000, 25000];
    this._scaleInputOpen = false;
    // Compare mode
    this._compareMode = false;
    this._compareLeftKey = 'Google היברידי';
    this._compareRightKey = 'צילום אוויר 2017 (ינואר)';
    this._compareLeftLayer = null;
    this._compareRightLayer = null;
    this._compareDividerXRatio = 0.5;
    this._compareDragging = false;
    this._comparePanelOpen = true;
    this._dxfUploading = false;
    this._dxfStyleOpen = new Set(); // dxfIds whose style panel is expanded

    // Planning layer categories with colors
    this._planningCategories = {
      'מגורים':       { color: '#4caf50', icon: 'fa-home',         keywords: ['מגורים','מגורי','דיור'] },
      'חקלאי':        { color: '#8d6e63', icon: 'fa-seedling',     keywords: ['חקלאי','חקלאית','פרדס','חצי חקלאי'] },
      'דרכים':        { color: '#78909c', icon: 'fa-road',         keywords: ['דרך','כביש','ככר עירונית','מעבר'] },
      'ציבורי':       { color: '#ff9800', icon: 'fa-landmark',     keywords: ['ציבור','מוסד','חינוכי','אולפנה','בית עלמין'] },
      'שטח פתוח':     { color: '#66bb6a', icon: 'fa-tree',         keywords: ['פתוח','שבילים','שביל','נופ','מדרון','פיתוח נופי'] },
      'תעסוקה':       { color: '#42a5f5', icon: 'fa-industry',     keywords: ['תעשי','תעסוק','מלאכה','אחסנ','משרד','מסחר','חנה וסע','חניון'] },
      'מסילה':        { color: '#455a64', icon: 'fa-train',        keywords: ['מסילת ברזל','רכבת','תחבור'] },
      'שמורת טבע':    { color: '#2e7d32', icon: 'fa-leaf',         keywords: ['שמורת טבע'] },
      'תשתיות':       { color: '#e53935', icon: 'fa-bolt',         keywords: ['מתקנ','ניקוז','תעלה','ואדי','נחל','טרנספורמ','תדלוק','דלק','חשמל','מים'] },
      'ספורט':        { color: '#00acc1', icon: 'fa-futbol',       keywords: ['ספורט','נופש'] },
      'מחוץ לתחום':   { color: '#bdbdbd', icon: 'fa-map-marker-alt', keywords: ['מחוץ לתחום'] },
      'משק':          { color: '#a1887f', icon: 'fa-warehouse',    keywords: ['משק','בית - אריזה'] },
      'אחר':          { color: '#9e9e9e', icon: 'fa-question',     keywords: [] }
    };
    this._planningLegendVisible = new Map(); // dxfId -> boolean
    this._imageOverlays = new Map(); // id -> { overlay, bounds, corners, markers, rotation, locked, name, opacity }
    this._imageOverlayIdCounter = 0;
    this._activeImageOverlayId = null;
    // Drawing tools
    this._drawMode = false;
    this._drawTool = null; // 'polyline'|'polygon'|'circle'|'rectangle'|'marker'|'text'
    this._drawSnap = true;
    this._snapDistance = 12; // pixels
    this._drawColor = '#e11d48';
    this._drawWeight = 3;
    this._drawFillOpacity = 0.2;
    this._drawPoints = [];
    this._drawTempLayers = [];
    this._drawItems = []; // {id, type, layer, label?, latlngs, props}
    this._drawIdCounter = 0;
    this._drawRectStart = null;
    this._drawCircleCenter = null;
    this._mmgIndex = null; // plan_number -> [{name, name_heb, features, file}]
    this._mmgLayers = new Map(); // key -> { layer, color, name }
    this._measureMode = null; // 'distance' | 'area' | null
    this._measurePoints = [];
    this._measureLayers = [];
    this._measureTooltipEl = null;
    // Advanced measurement dialog state
    this._measureDialogOpen = false;
    this._measureToolActive = null; // 'line'|'area'|'dimension'|'sketch'
    this._savedMeasurements = []; // {id, type, name, value, unit, layers[], latlngs[]}
    this._measureIdCounter = 0;
    this._dimPoints = []; // for dimension tool: 2 points
    this._sketchPhase = null; // 'polygon' | 'dimensions'
    this._sketchPoints = []; // polygon points for sketch
    this._sketchPolygonLayer = null;
    this._sketchTempLayers = [];
    this._coordPinMode = false;
    this._coordPins = []; // { id, marker, latlng }
    this._coordPinIdCounter = 0;
    this._loadSavedCoordPins();
    this.docPage = 0;
    this.DOC_PAGE_SIZE = 50;
    this.tabaLayer = null;
    this.cadastreLayer = null;
    this.blockCenters = {};
    // Search history & favorites
    this._searchHistory = JSON.parse(localStorage.getItem('searchHistory') || '[]');
    this._searchFavorites = JSON.parse(localStorage.getItem('searchFavorites') || '[]');
    this.init();
  }

  async init() {
    this.initMap();
    this._restoreCoordPins();
    this.bindEvents();
    try {
      const res = await fetch('/api/summary');
      this.data = await res.json();
      this.updateCounts();
      this.renderTab();
      await this.loadTaba();
      await this.loadCadastreBlocks();
      // Load MMG index
      try {
        const mmgRes = await fetch('/api/mmg');
        this._mmgIndex = await mmgRes.json();
        console.log('MMG index loaded:', Object.keys(this._mmgIndex).length, 'plans');
      } catch(e) { console.warn('MMG index load failed:', e); }
      // Auto-load saved uploaded layers
      await this.autoLoadSavedLayers();
    } catch (e) {
      console.error('Load error:', e);
      document.getElementById('panel-content').innerHTML =
        '<div class="empty"><i class="fas fa-exclamation-triangle"></i><p>שגיאה בטעינת נתונים</p></div>';
    }
    document.getElementById('loading').style.display = 'none';
  }

  /* ── Map ── */
  initMap() {
    this.map = L.map('map', { zoomControl: true }).setView([31.990, 34.853], 15);

    // Define multiple basemaps
    this._basemaps = {
      'OpenStreetMap': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap', maxZoom: 19
      }),
      'Google לוויין': L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
        attribution: '© Google', maxZoom: 21
      }),
      'Google היברידי': L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
        attribution: '© Google', maxZoom: 21
      }),
      'Google כבישים': L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
        attribution: '© Google', maxZoom: 21
      }),
      'לוויין (Esri)': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: '© Esri', maxZoom: 19
      }),
      'טופוגרפי': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenTopoMap', maxZoom: 17
      }),
      'CartoDB כהה': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '© CartoDB', maxZoom: 19
      }),
      'CartoDB בהיר': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '© CartoDB', maxZoom: 19
      }),
      'צילום אוויר 2017 (ינואר)': L.tileLayer('https://wayback.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/WMTS/1.0.0/default028mm/MapServer/tile/9486/{z}/{y}/{x}', {
        attribution: '© Esri Wayback 2017-01-25', maxZoom: 19
      }),
      'צילום אוויר 2017 (מאי)': L.tileLayer('https://wayback.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/WMTS/1.0.0/default028mm/MapServer/tile/14342/{z}/{y}/{x}', {
        attribution: '© Esri Wayback 2017-05-31', maxZoom: 19
      }),
      'צילום אוויר 2017 (אוגוסט)': L.tileLayer('https://wayback.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/WMTS/1.0.0/default028mm/MapServer/tile/25379/{z}/{y}/{x}', {
        attribution: '© Esri Wayback 2017-08-30', maxZoom: 19
      }),
      'צילום אוויר 2017 (נובמבר)': L.tileLayer('https://wayback.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/WMTS/1.0.0/default028mm/MapServer/tile/25521/{z}/{y}/{x}', {
        attribution: '© Esri Wayback 2017-11-16', maxZoom: 19
      })
    };

    // Add default basemap (Google Hybrid for best alignment)
    this._basemaps['Google היברידי'].addTo(this.map);

    // Add layer control to map
    this._layerControl = L.control.layers(this._basemaps, {}, {
      position: 'topright',
      collapsed: true
    }).addTo(this.map);

    // Coordinate display on mouse move
    const coordEl = document.getElementById('coord-display');
    this.map.on('mousemove', (e) => {
      const itm = proj4('EPSG:4326', 'EPSG:2039', [e.latlng.lng, e.latlng.lat]);
      coordEl.textContent = `WGS84: ${e.latlng.lat.toFixed(5)}, ${e.latlng.lng.toFixed(5)}  |  ITM: ${Math.round(itm[0])}, ${Math.round(itm[1])}`;
    });

    // Measure tool click handler
    this.map.on('click', (e) => this._onMeasureClick(e));
    this.map.on('click', (e) => this._onCoordPinClick(e));
    this.map.on('click', (e) => this._onDrawClick(e));
    this.map.on('click', (e) => this._onAdvancedMeasureClick(e));
    this.map.on('mousemove', (e) => this._onMeasureMove(e));
    this.map.on('mousemove', (e) => this._onDrawMove(e));
    this.map.on('mousemove', (e) => this._onAdvancedMeasureMove(e));
    this.map.on('dblclick', (e) => this._onDrawDblClick(e));
    this.map.on('dblclick', (e) => this._onAdvancedMeasureDblClick(e));
    this.map.on('contextmenu', (e) => {
      if (this._drawMode && this._drawPoints.length > 0) {
        L.DomEvent.preventDefault(e);
        this._finishDrawShape();
      }
    });

    // Init coord pin overlay (captures clicks above all layers)
    this._initCoordPinOverlay();

    // Scale widget: update on zoom and move
    this.map.on('zoomend moveend', () => this._updateScaleWidget());
    this._updateScaleWidget();
    this._renderScalePresets();
  }

  /* ── Scale Widget ── */
  _getMapScale() {
    const zoom = this.map.getZoom();
    const lat = this.map.getCenter().lat;
    const metersPerPx = 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoom);
    return Math.round(metersPerPx / 0.000264583); // 0.000264583 m = 1px @ 96dpi
  }

  _getZoomForScale(scale) {
    const lat = this.map.getCenter().lat;
    const metersPerPx = scale * 0.000264583;
    return Math.log2(156543.03392 * Math.cos(lat * Math.PI / 180) / metersPerPx);
  }

  _formatScale(scale) {
    if (scale >= 1000000) return (scale / 1000000).toFixed(1).replace('.0','') + 'M';
    if (scale >= 1000) return (scale / 1000).toFixed(scale % 1000 === 0 ? 0 : 1) + 'K';
    return String(scale);
  }

  _scaleBarMeters(scale) {
    // Pick a nice round distance that renders ~100px wide
    const pxPerMeter = 1 / (scale * 0.000264583);
    const targets = [1,2,5,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000];
    let best = targets[0], bestPx = Math.abs(pxPerMeter * targets[0] - 100);
    for (const t of targets) {
      const px = Math.abs(pxPerMeter * t - 100);
      if (px < bestPx) { bestPx = px; best = t; }
    }
    const widthPx = pxPerMeter * best;
    return { meters: best, widthPx: Math.round(widthPx) };
  }

  _updateScaleWidget() {
    const scale = this._getMapScale();
    const { meters, widthPx } = this._scaleBarMeters(scale);
    const label = meters >= 1000 ? (meters / 1000).toFixed(meters % 1000 === 0 ? 0 : 1) + ' ק"מ' : meters + ' מ\'';
    document.getElementById('scale-ratio-lbl').textContent = '1 : ' + scale.toLocaleString();
    document.getElementById('scale-bar-mid').style.width = widthPx + 'px';
    document.getElementById('scale-bar-lbl').textContent = label;
    // Update input placeholder
    const inp = document.getElementById('scale-input');
    if (inp) inp.placeholder = scale;
  }

  toggleScaleInput() {
    this._scaleInputOpen = !this._scaleInputOpen;
    const row = document.getElementById('scale-input-row');
    row.style.display = this._scaleInputOpen ? 'flex' : 'none';
    if (this._scaleInputOpen) {
      const inp = document.getElementById('scale-input');
      inp.value = this._getMapScale();
      inp.focus(); inp.select();
    }
  }

  applyScaleInput() {
    const val = parseInt(document.getElementById('scale-input').value);
    if (!val || val < 100 || val > 5000000) { alert('הזן קנה מידה בין 100 ל-5,000,000'); return; }
    const zoom = this._getZoomForScale(val);
    this.map.setZoom(Math.min(21, Math.max(1, Math.round(zoom))));
    this._scaleInputOpen = false;
    document.getElementById('scale-input-row').style.display = 'none';
  }

  zoomToScale(scale) {
    const zoom = this._getZoomForScale(scale);
    this.map.setZoom(Math.min(21, Math.max(1, Math.round(zoom))));
  }

  addCurrentScalePreset() {
    const scale = parseInt(document.getElementById('scale-input').value) || this._getMapScale();
    if (this._scalePresets.includes(scale)) { alert('קיצור לקנה מידה זה כבר קיים'); return; }
    this._scalePresets.push(scale);
    this._scalePresets.sort((a, b) => a - b);
    localStorage.setItem('scalePresets', JSON.stringify(this._scalePresets));
    this._renderScalePresets();
  }

  addCustomScalePreset() {
    const val = prompt('הזן ערך קנה מידה להוספה (לדוגמה: 2500):');
    if (!val) return;
    const scale = parseInt(val.replace(/[^0-9]/g, ''));
    if (!scale || scale < 100 || scale > 5000000) { alert('ערך לא תקין. הזן בין 100 ל-5,000,000'); return; }
    if (this._scalePresets.includes(scale)) { alert('כבר קיים'); return; }
    this._scalePresets.push(scale);
    this._scalePresets.sort((a, b) => a - b);
    localStorage.setItem('scalePresets', JSON.stringify(this._scalePresets));
    this._renderScalePresets();
  }

  deleteScalePreset(scale) {
    this._scalePresets = this._scalePresets.filter(s => s !== scale);
    localStorage.setItem('scalePresets', JSON.stringify(this._scalePresets));
    this._renderScalePresets();
  }

  _renderScalePresets() {
    const bar = document.getElementById('scale-presets-bar');
    if (!bar) return;
    let html = this._scalePresets.map(s =>
      `<button class="scale-preset-btn" onclick="app.zoomToScale(${s})" title="עבור ל-1:${s.toLocaleString()}">
        1:${this._formatScale(s)}
        <i class="fas fa-times" onclick="event.stopPropagation();app.deleteScalePreset(${s})" title="מחק קיצור"></i>
      </button>`
    ).join('');
    html += `<button class="scale-preset-add" onclick="app.addCustomScalePreset()" title="הוסף קנה מידה מותאם"><i class="fas fa-plus"></i></button>`;
    bar.innerHTML = html;
  }

  /* ── Compare Mode ── */
  _compareLayerOptions() {
    const aerial = [
      'צילום אוויר 2017 (ינואר)', 'צילום אוויר 2017 (מאי)',
      'צילום אוויר 2017 (אוגוסט)', 'צילום אוויר 2017 (נובמבר)'
    ];
    const base = Object.keys(this._basemaps).filter(k => !aerial.includes(k));
    return { aerial, base };
  }

  _buildCompareSelect(selectId, selectedKey) {
    const el = document.getElementById(selectId);
    if (!el) return;
    const { aerial, base } = this._compareLayerOptions();
    let html = '<optgroup label="מפות בסיס">' +
      base.map(k => `<option value="${k}" ${k===selectedKey?'selected':''}>${k}</option>`).join('') +
      '</optgroup>' +
      '<optgroup label="צילומי אוויר היסטוריים">' +
      aerial.map(k => `<option value="${k}" ${k===selectedKey?'selected':''}>${k}</option>`).join('') +
      '</optgroup>';
    el.innerHTML = html;
  }

  _applyCompareClip() {
    const mapContainer = this.map.getContainer();
    const w = mapContainer.offsetWidth;
    const x = Math.round(w * this._compareDividerXRatio);
    // Clip right layer to the right of the divider
    if (this._compareRightLayer) {
      const pane = this._compareRightLayer.getPane ? this._compareRightLayer.getPane() : null;
      if (pane) {
        pane.style.clipPath = `inset(0 0 0 ${x}px)`;
        pane.style.webkitClipPath = `inset(0 0 0 ${x}px)`;
      }
    }
    // Reset left layer clip
    if (this._compareLeftLayer) {
      const pane = this._compareLeftLayer.getPane ? this._compareLeftLayer.getPane() : null;
      if (pane) { pane.style.clipPath = ''; pane.style.webkitClipPath = ''; }
    }
    // Move divider element
    const div = document.getElementById('compare-divider');
    if (div) div.style.left = x + 'px';
  }

  _createCompareLayer(key) {
    // Clone the tile layer using the same URL template
    const orig = this._basemaps[key];
    if (!orig) return null;
    const url = orig._url;
    const opts = { ...orig.options };
    // Each compare layer gets a unique pane for independent clipping
    const paneName = 'comparePane_' + Math.random().toString(36).slice(2, 7);
    if (!this.map.getPane(paneName)) {
      this.map.createPane(paneName);
      this.map.getPane(paneName).style.zIndex = 200;
    }
    opts.pane = paneName;
    return L.tileLayer(url, opts);
  }

  _initCompareLayers() {
    if (this._compareLeftLayer) { this.map.removeLayer(this._compareLeftLayer); this._compareLeftLayer = null; }
    if (this._compareRightLayer) { this.map.removeLayer(this._compareRightLayer); this._compareRightLayer = null; }

    this._compareLeftLayer = this._createCompareLayer(this._compareLeftKey);
    this._compareRightLayer = this._createCompareLayer(this._compareRightKey);

    if (this._compareLeftLayer) this._compareLeftLayer.addTo(this.map);
    if (this._compareRightLayer) this._compareRightLayer.addTo(this.map);

    this._applyCompareClip();
    this._updateCompareLabels();
  }

  _updateCompareLabels() {
    const lblL = document.getElementById('compare-divider-label-left');
    const lblR = document.getElementById('compare-divider-label-right');
    if (lblL) lblL.textContent = this._compareLeftKey;
    if (lblR) lblR.textContent = this._compareRightKey;
  }

  _setupCompareDragEvents() {
    const divider = document.getElementById('compare-divider');
    if (!divider) return;
    const mapContainer = this.map.getContainer();

    const onMove = (e) => {
      if (!this._compareDragging) return;
      const rect = mapContainer.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const x = Math.max(20, Math.min(mapContainer.offsetWidth - 20, clientX - rect.left));
      this._compareDividerXRatio = x / mapContainer.offsetWidth;
      this._applyCompareClip();
    };
    const onUp = () => { this._compareDragging = false; };

    divider.addEventListener('mousedown', (e) => { this._compareDragging = true; e.preventDefault(); });
    divider.addEventListener('touchstart', (e) => { this._compareDragging = true; }, { passive: true });
    document.addEventListener('mousemove', onMove);
    document.addEventListener('touchmove', onMove, { passive: true });
    document.addEventListener('mouseup', onUp);
    document.addEventListener('touchend', onUp);
    // Reapply clip on map move/zoom (tile panes can reset)
    this.map.on('move zoom', () => { if (this._compareMode) this._applyCompareClip(); });
  }

  toggleCompareMode() {
    this._compareMode = !this._compareMode;
    const divider = document.getElementById('compare-divider');
    const panel = document.getElementById('compare-panel');
    const badge = document.getElementById('compare-mode-badge');
    const btn = document.getElementById('compare-mode-btn');

    if (this._compareMode) {
      // Build selects
      this._buildCompareSelect('compare-left-select', this._compareLeftKey);
      this._buildCompareSelect('compare-right-select', this._compareRightKey);
      this._buildComparePresets();
      // Show UI
      if (divider) divider.style.display = 'block';
      if (panel) { panel.classList.add('active'); this._comparePanelOpen = true; }
      if (badge) badge.classList.remove('active'); // badge hidden when panel open
      if (btn) btn.classList.add('active');
      // Disable map scroll/drag on divider
      if (this.map.scrollWheelZoom) this.map.scrollWheelZoom.disable();
      this._setupCompareDragEvents();
      this._initCompareLayers();
      if (this.map.scrollWheelZoom) this.map.scrollWheelZoom.enable();
    } else {
      if (divider) divider.style.display = 'none';
      if (panel) panel.classList.remove('active');
      if (badge) badge.classList.remove('active');
      if (btn) btn.classList.remove('active');
      if (this._compareLeftLayer) { this.map.removeLayer(this._compareLeftLayer); this._compareLeftLayer = null; }
      if (this._compareRightLayer) { this.map.removeLayer(this._compareRightLayer); this._compareRightLayer = null; }
    }
  }

  toggleComparePanel() {
    const panel = document.getElementById('compare-panel');
    const badge = document.getElementById('compare-mode-badge');
    if (!panel) return;
    this._comparePanelOpen = !this._comparePanelOpen;
    panel.classList.toggle('active', this._comparePanelOpen);
    // Badge shows only when panel is closed
    if (badge) badge.classList.toggle('active', !this._comparePanelOpen);
  }

  setCompareLayer(side, key) {
    if (side === 'left') this._compareLeftKey = key;
    else this._compareRightKey = key;
    this._initCompareLayers();
    this._updateCompareLabels();
  }

  setCompareOpacity(side, val) {
    const layer = side === 'left' ? this._compareLeftLayer : this._compareRightLayer;
    if (layer) layer.setOpacity(val);
  }

  _buildComparePresets() {
    const presets = [
      { label: 'היברידי vs ינואר \'17', left: 'Google היברידי', right: 'צילום אוויר 2017 (ינואר)' },
      { label: 'היברידי vs מאי \'17', left: 'Google היברידי', right: 'צילום אוויר 2017 (מאי)' },
      { label: 'היברידי vs אוג\' \'17', left: 'Google היברידי', right: 'צילום אוויר 2017 (אוגוסט)' },
      { label: 'ינואר vs מאי \'17', left: 'צילום אוויר 2017 (ינואר)', right: 'צילום אוויר 2017 (מאי)' },
      { label: 'מאי vs נוב\' \'17', left: 'צילום אוויר 2017 (מאי)', right: 'צילום אוויר 2017 (נובמבר)' },
      { label: 'OSM vs לוויין', left: 'OpenStreetMap', right: 'לוויין (Esri)' },
    ];
    const bar = document.getElementById('compare-presets');
    if (!bar) return;
    bar.innerHTML = presets.map((p, i) =>
      `<button class="compare-preset-btn" onclick="app._applyComparePreset(${i})" data-preset='${JSON.stringify(p).replace(/'/g,"\\'")}'>
        ${p.label}
      </button>`
    ).join('');
    this._comparePresets = presets;
  }

  _applyComparePreset(idx) {
    const p = this._comparePresets[idx];
    if (!p) return;
    this._compareLeftKey = p.left;
    this._compareRightKey = p.right;
    document.getElementById('compare-left-select').value = p.left;
    document.getElementById('compare-right-select').value = p.right;
    this._initCompareLayers();
    this._updateCompareLabels();
  }

  async loadTaba() {
    try {
      const res = await fetch('/data/taba_kfar_chabad.geojson');
      const geo = await res.json();
      this.tabaLayer = L.geoJSON(geo, {
        coordsToLatLng: itmToLatLng,
        style: { color: '#3b82f6', weight: 2, fillOpacity: 0.08, fillColor: '#3b82f6' },
        onEachFeature: (f, layer) => {
          const p = f.properties || {};
          const name = p.PLAN_NAME || p.PL_NAME || p.NAME || p.ENTITY_NAME || '';
          const num = p.PLAN_NUMBER || p.PL_NUMBER || p.NUMB || '';
          if (name || num) {
            layer.bindPopup(`<div class="popup-title">${num}</div><div>${name}</div>`);
          }
        }
      }).addTo(this.map);
      if (this.tabaLayer.getBounds().isValid()) {
        this.map.fitBounds(this.tabaLayer.getBounds(), { padding: [30, 30] });
      }
    } catch (e) { console.warn('taba load:', e); }
  }

  async loadCadastreBlocks() {
    try {
      const res = await fetch('/data/cadastre/blocks_kfar_chabad.geojson');
      const geo = await res.json();
      this.cadastreLayer = L.geoJSON(geo, {
        coordsToLatLng: itmToLatLng,
        style: { color: '#f59e0b', weight: 1.5, fillOpacity: 0.03, fillColor: '#f59e0b', dashArray: '5,5' },
        onEachFeature: (f, layer) => {
          const gush = f.properties?.GUSH_NUM;
          if (gush) {
            const id = String(Math.round(gush));
            const center = layer.getBounds().getCenter();
            this.blockCenters[id] = center;
            layer.bindPopup(`<div class="popup-title">גוש ${id}</div>`);
          }
        }
      }).addTo(this.map);
    } catch (e) { console.warn('cadastre load:', e); }
  }

  fitBounds() {
    if (this.tabaLayer && this.tabaLayer.getBounds().isValid()) {
      this.map.fitBounds(this.tabaLayer.getBounds(), { padding: [30, 30] });
    } else {
      this.map.setView([31.977, 34.864], 14);
    }
  }

  /* ── Events ── */
  bindEvents() {
    // Icon strip
    document.querySelectorAll('.strip-btn').forEach(btn => {
      btn.addEventListener('click', () => this.switchPanel(btn.dataset.panel));
    });
    // Tabs
    document.querySelectorAll('#data-tabs .tab').forEach(btn => {
      btn.addEventListener('click', () => {
        this.currentTab = btn.dataset.tab;
        document.querySelectorAll('#data-tabs .tab').forEach(t => t.classList.remove('active'));
        btn.classList.add('active');
        this.docPage = 0;
        this.searchQuery = '';
        document.getElementById('search-input').value = '';
        this.renderTab();
      });
    });
  }

  /* ── Panel Switching ── */
  switchPanel(panel) {
    this.currentPanel = panel;
    document.querySelectorAll('.strip-btn').forEach(b => b.classList.toggle('active', b.dataset.panel === panel));
    const titleEl = document.getElementById('panel-title-text');
    const titleIcon = document.querySelector('#panel-title-row > i');
    const tabs = document.getElementById('data-tabs');
    const search = document.getElementById('search-box');
    const footer = document.getElementById('panel-footer');

    const panelCfg = {
      data:     { title: 'נתונים', icon: 'fa-clipboard-list', tabs: true, search: true, footer: true },
      layers:   { title: 'שכבות GIS', icon: 'fa-layer-group', tabs: false, search: true, footer: false },
      search:   { title: 'חיפוש מתקדם', icon: 'fa-search-plus', tabs: false, search: false, footer: false },
      complot:  { title: 'Complot', icon: 'fa-building', tabs: false, search: false, footer: false },
      stats:    { title: 'סטטיסטיקות', icon: 'fa-chart-pie', tabs: false, search: false, footer: false },
      settings: { title: 'הגדרות', icon: 'fa-cog', tabs: false, search: false, footer: false },
    };
    const cfg = panelCfg[panel] || panelCfg.data;
    titleEl.textContent = cfg.title;
    titleIcon.className = 'fas ' + cfg.icon;
    tabs.style.display = cfg.tabs ? 'flex' : 'none';
    search.style.display = cfg.search ? 'block' : 'none';
    footer.style.display = cfg.footer ? 'block' : 'none';
    document.getElementById('search-input').placeholder = panel === 'layers' ? 'חיפוש שכבה...' : panel === 'search' ? 'חיפוש חופשי...' : 'חיפוש גוש, תכנית או מסמך...';

    this.searchQuery = '';
    document.getElementById('search-input').value = '';
    this.renderPanel();
  }

  renderPanel() {
    switch (this.currentPanel) {
      case 'data': this.renderTab(); break;
      case 'layers': this.renderLayers(); break;
      case 'complot': this.renderComplot(); break;
      case 'stats': this.renderStats(); break;
      case 'settings': this.renderSettings(); break;
      case 'search': this.renderAdvancedSearch(); break;
    }
  }

  /* ── Tab Rendering ── */
  renderTab() {
    switch (this.currentTab) {
      case 'blocks': this.renderBlocks(); break;
      case 'plans': this.renderPlans(); break;
      case 'documents': this.renderDocuments(); break;
    }
  }

  updateCounts() {
    if (!this.data) return;
    const s = this.data.stats;
    document.getElementById('cnt-blocks').textContent = s.total_blocks.toLocaleString();
    document.getElementById('cnt-plans').textContent = s.total_plans.toLocaleString();
    document.getElementById('cnt-docs').textContent = (s.total_documents || 0).toLocaleString();
    document.getElementById('mi-blocks').textContent = s.total_blocks;
    document.getElementById('mi-plans').textContent = s.total_plans;
  }

  /* ── Blocks ── */
  renderBlocks() {
    const el = document.getElementById('panel-content');
    if (!this.data) { el.innerHTML = '<div class="empty"><i class="fas fa-spinner fa-spin"></i></div>'; return; }

    let blocks = this.data.blocks;
    if (this.searchQuery) {
      const q = this.searchQuery.toLowerCase();
      blocks = blocks.filter(b => String(b.id).includes(q));
    }

    if (!blocks.length) {
      el.innerHTML = '<div class="empty"><i class="fas fa-search"></i><p>לא נמצאו גושים</p></div>';
      return;
    }

    el.innerHTML = blocks.map(b => `
      <div class="block-item${this.selectedBlock === b.id ? ' selected' : ''}" onclick="app.selectBlock(${b.id})">
        <div class="block-icon"><i class="fas fa-th"></i></div>
        <div class="block-info">
          <div class="block-num">גוש ${b.id}</div>
          <div class="block-meta">
            <span><i class="fas fa-puzzle-piece"></i> ${b.parcels_count || '—'} חלקות</span>
            <span><i class="fas fa-file-alt"></i> ${b.plans_count} תכניות</span>
          </div>
        </div>
        <i class="fas fa-chevron-left block-arrow"></i>
      </div>
    `).join('');

    // If a block is selected, show parcel controls below the list
    if (this.selectedBlock && this._parcelsLayer) {
      const PCOLORS = ['#e11d48','#2563eb','#16a34a','#d97706','#7c3aed','#0891b2','#dc2626','#4f46e5','#059669','#ea580c'];
      const parcelCount = this._parcelsLayer.getLayers().length;
      el.insertAdjacentHTML('afterbegin', `
        <div class="parcel-info-row">
          <i class="fas fa-vector-square"></i>
          <strong>גוש ${this.selectedBlock}</strong> — ${parcelCount} חלקות מוצגות במפה
          <button style="margin-right:auto;border:none;background:var(--accent);color:#fff;padding:3px 10px;border-radius:4px;cursor:pointer;font-size:11px" onclick="app.clearParcels()">
            <i class="fas fa-times"></i> הסר חלקות
          </button>
        </div>
        <div class="parcel-toolbar">
          <label>צבע חלקות</label>
          ${PCOLORS.map(c => `<div class="parcel-color-swatch${c===this._parcelColor?' active':''}" style="background:${c}" onclick="app.setParcelColor('${c}')"></div>`).join('')}
          <div class="sep"></div>
          <label>שקיפות</label>
          <input type="range" class="parcel-mini-slider" min="0" max="100" value="${Math.round(this._parcelOpacity*100)}"
            oninput="app.setParcelOpacity(this.value/100)">
          <div class="sep"></div>
          <label>עובי קו</label>
          <input type="range" class="parcel-mini-slider" min="1" max="6" value="${this._parcelWeight}" style="width:40px"
            oninput="app.setParcelWeight(parseInt(this.value))">
          <div class="sep"></div>
          <button class="label-toggle${this._showParcelLabels ? ' on' : ''}" onclick="app.toggleParcelLabels()">
            <i class="fas fa-font"></i> מספרי חלקות
          </button>
        </div>
      `);
    }
  }

  async selectBlock(id) {
    this.selectedBlock = id;
    const center = this.blockCenters[String(id)];
    if (center) {
      this.map.setView(center, 17);
      // Highlight block on map
      if (this.cadastreLayer) {
        this.cadastreLayer.eachLayer(layer => {
          const gush = layer.feature?.properties?.GUSH_NUM;
          if (gush && Math.round(gush) === id) {
            layer.setStyle({ color: '#ef4444', weight: 3, fillOpacity: 0.15, fillColor: '#ef4444', dashArray: null });
            layer.openPopup();
          } else {
            layer.setStyle({ color: '#f59e0b', weight: 1.5, fillOpacity: 0.03, fillColor: '#f59e0b', dashArray: '5,5' });
          }
        });
      }
    }
    // Load parcels for this block
    await this.loadBlockParcels(id);
    this.renderBlocks();
    this.renderLayers();
  }

  async loadBlockParcels(gush) {
    // Remove old parcels + labels layers
    if (this._parcelLabelsLayer) {
      this.map.removeLayer(this._parcelLabelsLayer);
      this._parcelLabelsLayer = null;
    }
    if (this._parcelsLayer) {
      this.map.removeLayer(this._parcelsLayer);
      this._parcelsLayer = null;
    }
    try {
      const [res, migrashRes] = await Promise.all([
        fetch(`/api/parcels/geojson?gush=${gush}`),
        fetch(`/api/migrash`).then(r => r.json()).catch(() => ({mapping:[]}))
      ]);
      const geo = await res.json();
      if (!geo.features || !geo.features.length) return;

      // Build migrash lookup for this block
      const migrashMap = {};
      (migrashRes.mapping || []).forEach(m => {
        if (String(m.gush) === String(gush)) migrashMap[String(m.helka)] = m;
      });

      const color = this._parcelColor;
      const opacity = this._parcelOpacity;
      const weight = this._parcelWeight;

      this._parcelsLayer = L.geoJSON(geo, {
        coordsToLatLng: itmToLatLng,
        style: (f) => {
          const p = f.properties || {};
          const helka = String(p.PARCEL || '');
          const hasMigrash = !!migrashMap[helka];
          return {
            color: hasMigrash ? '#10b981' : color,
            weight: hasMigrash ? Math.max(weight, 3) : weight,
            fillOpacity: hasMigrash ? 0.25 : opacity,
            fillColor: hasMigrash ? '#10b981' : color,
          };
        },
        onEachFeature: (f, layer) => {
          const p = f.properties || {};
          const helka = p.PARCEL || '?';
          const area = p.LEGAL_AREA ? p.LEGAL_AREA.toLocaleString() : '?';
          const status = p.STATUS_TEX || '';
          const mg = migrashMap[String(helka)];
          const migrashHtml = mg ? `
            <div class="popup-row" style="border-top:1px solid #e5e7eb;margin-top:4px;padding-top:4px">
              <span class="k" style="color:#10b981">מגרש</span><span><strong>${mg.migrash}</strong></span>
            </div>
            <div class="popup-row"><span class="k">תכנית</span><span>${mg.plan || ''}</span></div>
            <div class="popup-row"><span class="k">ייעוד</span><span>${mg.yeud || ''}</span></div>
            ${mg.shetach_sqm ? `<div class="popup-row"><span class="k">שטח מגרש</span><span>${Number(mg.shetach_sqm).toLocaleString()} מ"ר</span></div>` : ''}
            <div class="popup-row"><a href="https://sdan.complot.co.il/gush2/#gush/${gush}/${helka}" target="_blank" style="color:#3b82f6;font-size:10px">🔗 פרטים באתר קומפלוט</a></div>
          ` : '';
          layer.bindPopup(`
            <div class="popup-title">חלקה ${helka}</div>
            <div class="popup-row"><span class="k">גוש</span><span>${gush}</span></div>
            <div class="popup-row"><span class="k">שטח</span><span>${area} מ"ר</span></div>
            <div class="popup-row"><span class="k">סטטוס</span><span>${status}</span></div>
            ${migrashHtml}
          `);
          // Hover highlight
          layer.on('mouseover', () => {
            if (this._highlightedParcel && this._highlightedParcel !== layer) {
              this._highlightedParcel.setStyle({ weight: weight, color: color });
            }
            layer.setStyle({ weight: Math.max(weight + 2, 4), color: '#fbbf24' });
            layer.bringToFront();
            this._highlightedParcel = layer;
            layer.bindTooltip(`חלקה ${helka}${mg ? ' · מגרש '+mg.migrash : ''} · ${area} מ"ר`, { sticky: true, className: 'parcel-tooltip' }).openTooltip();
          });
          layer.on('mouseout', () => {
            layer.setStyle({ weight: weight, color: color });
            layer.closeTooltip();
          });
        }
      }).addTo(this.map);
      this._parcelsOn = true;

      // Create parcel number labels at polygon centroids
      this._createParcelLabels();
    } catch(e) { console.error('Parcels load error:', e); }
  }

  _createParcelLabels() {
    if (this._parcelLabelsLayer) {
      this.map.removeLayer(this._parcelLabelsLayer);
      this._parcelLabelsLayer = null;
    }
    if (!this._parcelsLayer) return;
    const labelMarkers = [];
    const gush = this.selectedBlock || '';
    this._parcelsLayer.eachLayer(layer => {
      const p = layer.feature?.properties || {};
      const helka = p.PARCEL;
      if (helka == null) return;
      // Check for saved position
      const posKey = `p_${gush}_${helka}`;
      const savedPos = this._labelPositions[posKey];
      const bounds = layer.getBounds();
      const center = savedPos ? L.latLng(savedPos.lat, savedPos.lng) : bounds.getCenter();
      // Determine label size based on polygon area on screen
      const areaM2 = p.Shape__Area || p.LEGAL_AREA || 0;
      const sizeClass = areaM2 > 3000 ? ' parcel-label-lg' : '';
      const icon = L.divIcon({
        className: 'parcel-label' + sizeClass,
        html: String(helka),
        iconSize: [40, 14],
        iconAnchor: [20, 7]
      });
      const marker = L.marker(center, { icon, draggable: true, pane: 'tooltipPane', zIndexOffset: 1000 });
      marker._labelKey = posKey;
      marker.on('dragend', (e) => {
        const pos = e.target.getLatLng();
        this._labelPositions[posKey] = { lat: pos.lat, lng: pos.lng };
        this._saveLabelPositions();
      });
      labelMarkers.push(marker);
    });
    this._parcelLabelsLayer = L.layerGroup(labelMarkers);
    if (this._showParcelLabels) {
      this._parcelLabelsLayer.addTo(this.map);
    }
  }

  _saveLabelPositions() {
    localStorage.setItem('labelPositions', JSON.stringify(this._labelPositions));
  }

  resetLabelPositions() {
    this._labelPositions = {};
    this._saveLabelPositions();
    // Rebuild parcel labels
    this._createParcelLabels();
    // Rebuild migrash labels if on
    if (this._migrashOn && this._migrashLayer) {
      this._rebuildMigrashLabels();
    }
  }

  toggleParcelLabels() {
    this._showParcelLabels = !this._showParcelLabels;
    if (this._parcelLabelsLayer) {
      if (this._showParcelLabels) {
        this._parcelLabelsLayer.addTo(this.map);
      } else {
        this.map.removeLayer(this._parcelLabelsLayer);
      }
    }
    this.renderBlocks();
  }

  clearParcels() {
    if (this._parcelLabelsLayer) {
      this.map.removeLayer(this._parcelLabelsLayer);
      this._parcelLabelsLayer = null;
    }
    if (this._parcelsLayer) {
      this.map.removeLayer(this._parcelsLayer);
      this._parcelsLayer = null;
    }
    this.selectedBlock = null;
    // Reset block styles
    if (this.cadastreLayer) {
      this.cadastreLayer.eachLayer(layer => {
        layer.setStyle({ color: '#f59e0b', weight: 1.5, fillOpacity: 0.03, fillColor: '#f59e0b', dashArray: '5,5' });
      });
    }
    this.renderBlocks();
  }

  setParcelColor(color) {
    this._parcelColor = color;
    if (this._parcelsLayer) {
      this._parcelsLayer.eachLayer(l => {
        if (l.setStyle) l.setStyle({ color: color, fillColor: color });
      });
    }
    this.renderBlocks();
  }

  setParcelOpacity(opacity) {
    this._parcelOpacity = opacity;
    if (this._parcelsLayer) {
      this._parcelsLayer.eachLayer(l => {
        if (l.setStyle) l.setStyle({ fillOpacity: opacity });
      });
    }
  }

  setParcelWeight(w) {
    this._parcelWeight = w;
    if (this._parcelsLayer) {
      this._parcelsLayer.eachLayer(l => {
        if (l.setStyle) l.setStyle({ weight: w });
      });
    }
  }

  /* ── Migrash Layer ── */
  async toggleMigrash() {
    if (this._migrashOn) {
      // Remove layer
      if (this._migrashLabelsLayer) { this.map.removeLayer(this._migrashLabelsLayer); this._migrashLabelsLayer = null; }
      if (this._migrashLayer) { this.map.removeLayer(this._migrashLayer); this._migrashLayer = null; }
      this._migrashOn = false;
    } else {
      await this.loadMigrashLayer();
      this._migrashOn = true;
    }
    this.renderLayers();
  }

  async loadMigrashLayer() {
    // Remove old
    if (this._migrashLabelsLayer) { this.map.removeLayer(this._migrashLabelsLayer); this._migrashLabelsLayer = null; }
    if (this._migrashLayer) { this.map.removeLayer(this._migrashLayer); this._migrashLayer = null; }

    // Fetch migrash mapping
    if (!this._migrashData) {
      try {
        const res = await fetch('/api/migrash');
        this._migrashData = await res.json();
      } catch(e) { console.error('Migrash data load error:', e); return; }
    }

    const mapping = this._migrashData.mapping || [];
    if (!mapping.length) return;

    // Group by gush
    const byGush = {};
    mapping.forEach(m => {
      const g = String(m.gush);
      if (!byGush[g]) byGush[g] = {};
      byGush[g][String(m.helka)] = m;
    });

    const allLayers = [];
    const labelMarkers = [];
    const color = this._migrashColor;
    const opacity = this._migrashOpacity;
    const weight = this._migrashWeight;
    const textColor = this._migrashTextColor;

    // For each gush with migrash data, load parcels
    for (const gush of Object.keys(byGush)) {
      try {
        const res = await fetch(`/api/parcels/geojson?gush=${gush}`);
        const geo = await res.json();
        if (!geo.features) continue;

        const migrashMap = byGush[gush];

        geo.features.forEach(f => {
          const helka = String(f.properties?.PARCEL || '');
          const mg = migrashMap[helka];
          if (!mg) return; // Skip parcels without migrash

          const layer = L.geoJSON(f, {
            coordsToLatLng: itmToLatLng,
            style: { color, weight, fillOpacity: opacity, fillColor: color },
            onEachFeature: (feat, lyr) => {
              lyr.bindPopup(`
                <div class="popup-title">מגרש ${mg.migrash}</div>
                <div class="popup-row"><span class="k">גוש</span><span>${gush}</span></div>
                <div class="popup-row"><span class="k">חלקה</span><span>${helka}</span></div>
                <div class="popup-row"><span class="k">תכנית</span><span>${mg.plan || ''}</span></div>
                <div class="popup-row"><span class="k">ייעוד</span><span>${mg.yeud || ''}</span></div>
                ${mg.shetach_sqm ? `<div class="popup-row"><span class="k">שטח</span><span>${Number(mg.shetach_sqm).toLocaleString()} מ"ר</span></div>` : ''}
              `);
              lyr.on('mouseover', () => {
                lyr.setStyle({ weight: Math.max(weight + 2, 4), color: '#fbbf24' });
                lyr.bringToFront();
                lyr.bindTooltip(`מגרש ${mg.migrash} · חלקה ${helka} · ${mg.yeud || ''}`, { sticky: true, className: 'parcel-tooltip' }).openTooltip();
              });
              lyr.on('mouseout', () => {
                lyr.setStyle({ weight, color });
                lyr.closeTooltip();
              });
            }
          });
          allLayers.push(layer);

          // Create label at centroid with offset from parcel label
          try {
            const bounds = layer.getBounds();
            const origCenter = bounds.getCenter();
            const posKey = `m_${gush}_${helka}`;
            const savedPos = this._labelPositions[posKey];
            // Default offset: shift migrash label slightly south-east to avoid overlap with parcel label
            const defaultCenter = savedPos ? L.latLng(savedPos.lat, savedPos.lng) :
              L.latLng(origCenter.lat - (bounds.getNorth() - bounds.getSouth()) * 0.18,
                       origCenter.lng + (bounds.getEast() - bounds.getWest()) * 0.12);
            const areaM2 = f.properties?.Shape__Area || f.properties?.LEGAL_AREA || 0;
            const sizeClass = areaM2 > 3000 ? ' migrash-label-lg' : '';
            const icon = L.divIcon({
              className: 'migrash-label' + sizeClass,
              html: `<span style="color:${textColor}">מ${mg.migrash}</span>`,
              iconSize: [46, 16],
              iconAnchor: [23, 8]
            });
            const marker = L.marker(defaultCenter, { icon, draggable: true, pane: 'tooltipPane', zIndexOffset: 2000 });
            marker._labelKey = posKey;
            marker.on('dragend', (e) => {
              const pos = e.target.getLatLng();
              this._labelPositions[posKey] = { lat: pos.lat, lng: pos.lng };
              this._saveLabelPositions();
            });
            labelMarkers.push(marker);
          } catch(e) {}
        });
      } catch(e) { console.error(`Migrash parcels load error for gush ${gush}:`, e); }
    }

    if (allLayers.length) {
      this._migrashLayer = L.layerGroup(allLayers).addTo(this.map);
    }
    if (labelMarkers.length) {
      this._migrashLabelsLayer = L.layerGroup(labelMarkers);
      if (this._showMigrashLabels) this._migrashLabelsLayer.addTo(this.map);
    }
  }

  changeMigrashColor(color) {
    this._migrashColor = color;
    if (this._migrashLayer) {
      this._migrashLayer.eachLayer(lg => {
        if (lg.eachLayer) lg.eachLayer(l => { if (l.setStyle) l.setStyle({ color, fillColor: color }); });
      });
    }
    this._colorPaletteOpen = null;
    this.renderLayers();
  }

  changeMigrashTextColor(color) {
    this._migrashTextColor = color;
    this._rebuildMigrashLabels();
    this._colorPaletteOpen = null;
    this.renderLayers();
  }

  _rebuildMigrashLabels() {
    // Rebuild labels with current text color, preserving dragged positions
    const color = this._migrashTextColor;
    if (this._migrashLabelsLayer) {
      const wasShown = this.map.hasLayer(this._migrashLabelsLayer);
      this.map.removeLayer(this._migrashLabelsLayer);
      this._migrashLabelsLayer = null;
      // Rebuild from migrash layer data
      if (this._migrashData && this._migrashLayer) {
        const labelMarkers = [];
        const mapping = this._migrashData.mapping || [];
        const migrashByKey = {};
        mapping.forEach(m => { migrashByKey[`${m.gush}-${m.helka}`] = m; });

        this._migrashLayer.eachLayer(lg => {
          if (!lg.eachLayer) return;
          lg.eachLayer(l => {
            const p = l.feature?.properties || {};
            const gush = p.GUSH_NUM || p.GUSH || '';
            const helka = p.PARCEL || '';
            const gushStr = String(Math.round(gush));
            const key = `${gushStr}-${helka}`;
            const mg = migrashByKey[key];
            if (!mg) return;
            try {
              const bounds = l.getBounds();
              const origCenter = bounds.getCenter();
              const posKey = `m_${gushStr}_${helka}`;
              const savedPos = this._labelPositions[posKey];
              const center = savedPos ? L.latLng(savedPos.lat, savedPos.lng) :
                L.latLng(origCenter.lat - (bounds.getNorth() - bounds.getSouth()) * 0.18,
                         origCenter.lng + (bounds.getEast() - bounds.getWest()) * 0.12);
              const areaM2 = p.Shape__Area || p.LEGAL_AREA || 0;
              const sizeClass = areaM2 > 3000 ? ' migrash-label-lg' : '';
              const icon = L.divIcon({
                className: 'migrash-label' + sizeClass,
                html: `<span style="color:${color}">מ${mg.migrash}</span>`,
                iconSize: [46, 16],
                iconAnchor: [23, 8]
              });
              const marker = L.marker(center, { icon, draggable: true, pane: 'tooltipPane', zIndexOffset: 2000 });
              marker._labelKey = posKey;
              marker.on('dragend', (e) => {
                const pos = e.target.getLatLng();
                this._labelPositions[posKey] = { lat: pos.lat, lng: pos.lng };
                this._saveLabelPositions();
              });
              labelMarkers.push(marker);
            } catch(e) {}
          });
        });
        if (labelMarkers.length) {
          this._migrashLabelsLayer = L.layerGroup(labelMarkers);
          if (wasShown && this._showMigrashLabels) this._migrashLabelsLayer.addTo(this.map);
        }
      }
    }
  }

  changeMigrashOpacity(opacity) {
    this._migrashOpacity = opacity;
    if (this._migrashLayer) {
      this._migrashLayer.eachLayer(lg => {
        if (lg.eachLayer) lg.eachLayer(l => { if (l.setStyle) l.setStyle({ fillOpacity: opacity }); });
      });
    }
  }

  changeMigrashWeight(w) {
    this._migrashWeight = w;
    if (this._migrashLayer) {
      this._migrashLayer.eachLayer(lg => {
        if (lg.eachLayer) lg.eachLayer(l => { if (l.setStyle) l.setStyle({ weight: w }); });
      });
    }
  }

  toggleMigrashLabels() {
    this._showMigrashLabels = !this._showMigrashLabels;
    if (this._migrashLabelsLayer) {
      if (this._showMigrashLabels) this._migrashLabelsLayer.addTo(this.map);
      else this.map.removeLayer(this._migrashLabelsLayer);
    }
    this.renderLayers();
  }

  /* ── Highlight specific parcel on map ── */
  async highlightParcelOnMap(gush, helka) {
    // Ensure parcels for this block are loaded
    if (this.selectedBlock !== gush) {
      await this.selectBlock(gush);
    }
    if (!this._parcelsLayer) return;

    // Find the specific parcel layer
    let targetLayer = null;
    this._parcelsLayer.eachLayer(l => {
      const p = l.feature?.properties || {};
      if (String(p.PARCEL) === String(helka)) {
        targetLayer = l;
      }
    });

    if (targetLayer) {
      // Flash highlight
      const origStyle = {
        color: this._parcelColor,
        weight: this._parcelWeight,
        fillOpacity: this._parcelOpacity,
        fillColor: this._parcelColor
      };

      // Zoom to parcel bounds
      this.map.fitBounds(targetLayer.getBounds(), { maxZoom: 19, padding: [50, 50] });

      // Flash effect
      targetLayer.bringToFront();
      const flashColor = '#facc15';
      let flashCount = 0;
      const flashInterval = setInterval(() => {
        if (flashCount >= 8) {
          clearInterval(flashInterval);
          targetLayer.setStyle({ color: '#ef4444', weight: 4, fillOpacity: 0.3, fillColor: '#ef4444' });
          return;
        }
        const isOn = flashCount % 2 === 0;
        targetLayer.setStyle({
          color: isOn ? flashColor : origStyle.color,
          weight: isOn ? 5 : origStyle.weight,
          fillOpacity: isOn ? 0.4 : origStyle.fillOpacity,
          fillColor: isOn ? flashColor : origStyle.fillColor
        });
        flashCount++;
      }, 200);

      // Open popup
      targetLayer.openPopup();
    }
  }

  /* ── Plans ── */
  renderPlans() {
    const el = document.getElementById('panel-content');
    if (!this.data) return;

    let plans = this.data.plans;
    if (this.searchQuery) {
      const q = this.searchQuery.toLowerCase();
      plans = plans.filter(p =>
        (p.name || '').toLowerCase().includes(q) ||
        (p.number || '').toLowerCase().includes(q) ||
        (p.entity_name || '').toLowerCase().includes(q)
      );
    }

    if (!plans.length) {
      el.innerHTML = '<div class="empty"><i class="fas fa-search"></i><p>לא נמצאו תכניות</p></div>';
      return;
    }

    el.innerHTML = plans.map(p => {
      const statusClass = (p.status || '').includes('אושר') ? 'active' : (p.status || '').includes('הפקדה') ? 'pending' : 'other';
      const planNum = (p.number || p.name || '').replace(/'/g, "\\'");
      const isAdded = this._planLayers.has(p.number || p.name);
      const hasMMG = this._mmgIndex && this._mmgIndex[p.number || p.name];
      const mmgCount = hasMMG ? this._mmgIndex[p.number || p.name].length : 0;
      return `<div class="plan-item" onclick="app.expandPlan('${planNum}')">
        <div class="plan-head">
          <i class="fas fa-map"></i>
          <span class="plan-name">${p.number || p.name}</span>
          <span class="plan-badge">${p.docs_count} מסמכים</span>
          <button class="add-layer-btn ${isAdded ? 'added' : ''}" onclick="event.stopPropagation();app.togglePlanLayer('${planNum}')" title="${isAdded ? 'הסר שכבה' : 'הוסף כשכבה'}">
            <i class="fas ${isAdded ? 'fa-layer-group' : 'fa-plus'}"></i> ${isAdded ? 'שכבה' : 'הוסף כשכבה'}
          </button>
          ${hasMMG ? `<button class="add-layer-btn" onclick="event.stopPropagation();app.showMMGLayers('${planNum}')" title="שכבות מ&quot;מ&quot;ג" style="background:#8b5cf6">
            <i class="fas fa-drafting-compass"></i> מ"מ"ג (${mmgCount})
          </button>` : ''}
        </div>
        <div class="plan-sub">
          ${p.status ? `<span class="plan-status ${statusClass}">${p.status}</span>` : ''}
          ${p.entity_name ? `<span><i class="fas fa-landmark"></i> ${p.entity_name}</span>` : ''}
          ${p.station_desc ? `<span><i class="fas fa-info-circle"></i> ${p.station_desc}</span>` : ''}
        </div>
      </div>`;
    }).join('');
  }

  expandPlan(name) {
    // Switch to documents tab filtered by plan
    this.currentTab = 'documents';
    document.querySelectorAll('#data-tabs .tab').forEach(t => t.classList.toggle('active', t.dataset.tab === 'documents'));
    this.searchQuery = name;
    document.getElementById('search-input').value = name;
    this.docPage = 0;
    this.renderDocuments();
  }

  /* ── Documents ── */
  async renderDocuments() {
    const el = document.getElementById('panel-content');
    if (!this.documents) {
      el.innerHTML = '<div class="empty"><i class="fas fa-spinner fa-spin"></i><p>טוען מסמכים...</p></div>';
      try {
        const r = await fetch('/api/documents');
        this.documents = await r.json();
      } catch(e) {
        el.innerHTML = '<div class="empty"><i class="fas fa-exclamation-triangle"></i><p>שגיאה בטעינה</p></div>';
        return;
      }
    }

    let docs = this.documents;
    if (this.searchQuery) {
      const q = this.searchQuery.toLowerCase();
      docs = docs.filter(d =>
        (d.DOC_NAME || '').toLowerCase().includes(q) ||
        (d.plan || '').toLowerCase().includes(q) ||
        (d.source || '').toLowerCase().includes(q) ||
        (d.FILE_TYPE || '').toLowerCase().includes(q)
      );
    }

    const total = docs.length;
    const pages = Math.ceil(total / this.DOC_PAGE_SIZE);
    const start = this.docPage * this.DOC_PAGE_SIZE;
    const page = docs.slice(start, start + this.DOC_PAGE_SIZE);

    if (!total) {
      el.innerHTML = '<div class="empty"><i class="fas fa-search"></i><p>לא נמצאו מסמכים</p></div>';
      return;
    }

    const iconClass = (ft) => {
      ft = (ft || '').toLowerCase().trim();
      if (ft === 'pdf') return 'pdf';
      if (ft === 'dwg' || ft === 'dxf') return 'dwg';
      if (ft === 'shp') return 'shp';
      if (ft === 'doc' || ft === 'docx') return 'other';
      if (ft === 'xls' || ft === 'xlsx') return 'other';
      if (ft === 'kml') return 'other';
      return 'other';
    };
    const iconFA = (ft) => {
      ft = (ft || '').toLowerCase().trim();
      if (ft === 'pdf') return 'fa-file-pdf';
      if (ft === 'dwg' || ft === 'dxf') return 'fa-drafting-compass';
      if (ft === 'shp') return 'fa-vector-square';
      if (ft === 'doc' || ft === 'docx') return 'fa-file-word';
      if (ft === 'xls' || ft === 'xlsx') return 'fa-file-excel';
      if (ft === 'zip') return 'fa-file-archive';
      if (ft === 'kml') return 'fa-globe';
      if (ft === 'jpg' || ft === 'jpeg' || ft === 'png') return 'fa-file-image';
      if (ft === 'pptx') return 'fa-file-powerpoint';
      if (ft === 'json' || ft === 'geojson') return 'fa-code';
      if (ft === 'html') return 'fa-code';
      return 'fa-file';
    };

    // Store filtered docs list for viewer navigation
    this._currentDocList = docs;

    let html = page.map((d, pi) => {
      const globalIdx = start + pi;
      const hasFile = d._has_file;
      const ft = (d.FILE_TYPE || '').trim().toLowerCase();
      const dateStr = d.EDITING_DATE || d.INTERNAL_OPEN_DATE || '';
      const pagesStr = d.DOC_PAGES ? `${d.DOC_PAGES} עמ'` : '';
      return `
      <div class="doc-item${hasFile ? '' : ' unavailable'}" onclick="app.openDocViewer(${globalIdx})" title="${hasFile ? 'לחץ לצפייה' : 'הקובץ לא זמין'}">
        <div class="doc-icon ${iconClass(d.FILE_TYPE)}"><i class="fas ${iconFA(d.FILE_TYPE)}"></i></div>
        <div class="doc-info">
          <div class="doc-name">${d.DOC_NAME || 'ללא שם'}</div>
          <div class="doc-plan">${d.plan || ''} · ${d.RUB_DESC || d.source || ''} · ${ft.toUpperCase()} ${pagesStr ? '· ' + pagesStr : ''} ${dateStr ? '· ' + dateStr : ''}</div>
        </div>
        <div class="doc-actions">
          ${hasFile ? `<button class="doc-btn" onclick="event.stopPropagation();app.downloadDoc(${globalIdx})" title="הורד"><i class="fas fa-download"></i></button>` : ''}
          <button class="doc-btn" onclick="event.stopPropagation();app.openDocViewer(${globalIdx})" title="צפה"><i class="fas fa-eye"></i></button>
        </div>
      </div>`;
    }).join('');

    if (pages > 1) {
      html += `<div class="pagination">
        <button ${this.docPage <= 0 ? 'disabled' : ''} onclick="app.docPage--;app.renderDocuments()"><i class="fas fa-chevron-right"></i></button>
        <span>עמוד ${this.docPage + 1} מתוך ${pages} (${total.toLocaleString()} מסמכים)</span>
        <button ${this.docPage >= pages - 1 ? 'disabled' : ''} onclick="app.docPage++;app.renderDocuments()"><i class="fas fa-chevron-left"></i></button>
      </div>`;
    }

    el.innerHTML = html;
  }

  /* ── Document Viewer Integration ── */
  openDocViewer(globalIdx) {
    const docs = this._currentDocList || this.documents || [];
    const doc = docs[globalIdx];
    if (!doc) return;
    docViewer.open(doc, docs);
  }

  downloadDoc(globalIdx) {
    const docs = this._currentDocList || this.documents || [];
    const doc = docs[globalIdx];
    if (!doc || !doc._has_file) return;
    const url = `/api/documents/file/${doc._idx}`;
    const ft = (doc.FILE_TYPE || '').trim().toLowerCase();
    const a = document.createElement('a');
    a.href = url;
    a.download = (doc.DOC_NAME || 'document') + '.' + ft;
    a.click();
  }

  /* ── Layers ── */
  renderLayers() {
    const el = document.getElementById('panel-content');
    if (!this.data) return;
    const cats = this.data.layer_categories || {};
    const q = this.searchQuery.toLowerCase();
    const COLORS = ['#ef4444','#8b5cf6','#06b6d4','#10b981','#f97316','#ec4899','#6366f1','#14b8a6','#3b82f6','#f59e0b','#a855f7','#22d3ee'];

    const renderLayerControls = (key, isBase) => {
      const style = this.layerStyles[key] || {};
      const color = style.color || (key === 'taba' ? '#3b82f6' : key === 'cadastre' ? '#f59e0b' : '#ef4444');
      const opacity = style.opacity != null ? style.opacity : (isBase ? 0.08 : 0.12);
      const weight = style.weight != null ? style.weight : 2;
      const opacityPct = Math.round(opacity * 100);
      const showPalette = this._colorPaletteOpen === key;
      let ctrl = `<div class="layer-controls">
        <label>צבע</label>
        <button class="layer-color-btn" style="background:${color}" onclick="event.stopPropagation();app.toggleColorPalette('${key}')"></button>
        <label>שקיפות</label>
        <input type="range" class="layer-opacity-slider" min="0" max="100" value="${opacityPct}"
          oninput="event.stopPropagation();app.changeLayerOpacity('${key}',this.value/100,${isBase});this.nextElementSibling.textContent=this.value+'%'"
          onclick="event.stopPropagation()">
        <span class="layer-opacity-val">${opacityPct}%</span>
      </div>
      <div class="layer-controls">
        <label>עובי קו</label>
        <input type="range" class="layer-opacity-slider" min="1" max="8" value="${weight}" style="width:60px"
          oninput="event.stopPropagation();app.changeLayerWeight('${key}',parseInt(this.value),${isBase});this.nextElementSibling.textContent=this.value"
          onclick="event.stopPropagation()">
        <span class="layer-opacity-val">${weight}</span>
      </div>`;
      if (showPalette) {
        ctrl += `<div class="layer-color-palette" onclick="event.stopPropagation()">
          ${COLORS.map(c => `<div class="layer-color-swatch${c===color?' active':''}" style="background:${c}" onclick="app.changeLayerColor('${key}','${c}',${isBase})"></div>`).join('')}
        </div>`;
      }
      return ctrl;
    };

    let html = '';
    const allCatFiles = []; // collect all GIS layer files for global toggle
    // Base layer states (needed for global bar and base section)
    const tabaOn = this.tabaLayer && this.map.hasLayer(this.tabaLayer);
    const cadOn = this.cadastreLayer && this.map.hasLayer(this.cadastreLayer);
    const migOn = this._migrashOn;
    const parcOn = this._parcelsOn && this._parcelsLayer && this.map.hasLayer(this._parcelsLayer);

    // Sort categories by saved order
    const catEntries = Object.entries(cats).filter(([cat]) => !this._hiddenCategories.has(cat));
    const orderedCats = this._getOrderedCategories(catEntries);
    // Pre-filter to get visible category indices for arrow disable logic
    const visibleCatIndices = [];
    for (let i = 0; i < orderedCats.length; i++) {
      const [cat, rawLayers] = orderedCats[i];
      const layers = this._getOrderedLayers(cat, rawLayers).filter(l => !this._hiddenLayers.has(l.file));
      const filtered = q ? layers.filter(l => {
        const heb = layerHeb(l.name).toLowerCase();
        const alias = (this._layerRenames[l.file] || '').toLowerCase();
        return l.name.toLowerCase().includes(q) || cat.toLowerCase().includes(q) || heb.includes(q) || alias.includes(q);
      }) : layers;
      if (filtered.length) visibleCatIndices.push(i);
    }

    for (let catIdx = 0; catIdx < orderedCats.length; catIdx++) {
      const [cat, rawLayers] = orderedCats[catIdx];
      // Sort layers within category by saved order
      const layers = this._getOrderedLayers(cat, rawLayers).filter(l => !this._hiddenLayers.has(l.file));
      const filtered = q ? layers.filter(l => {
        const heb = layerHeb(l.name).toLowerCase();
        const alias = (this._layerRenames[l.file] || '').toLowerCase();
        return l.name.toLowerCase().includes(q) || cat.toLowerCase().includes(q) || heb.includes(q) || alias.includes(q);
      }) : layers;
      if (!filtered.length) continue;
      const catFiles = filtered.map(l => l.file);
      allCatFiles.push(...catFiles);
      const catActiveCount = catFiles.filter(f => this.activeLayers.has(f)).length;
      const catAllOn = catActiveCount === catFiles.length;
      const catSomeOn = catActiveCount > 0;
      const escapedCat = cat.replace(/'/g, "\\'");
      const isFirstCat = catIdx === visibleCatIndices[0];
      const isLastCat = catIdx === visibleCatIndices[visibleCatIndices.length - 1];
      html += `<div class="layer-group">
        <div class="layer-group-head" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <i class="fas fa-chevron-left toggle"></i>
          <div class="layer-reorder-btns" onclick="event.stopPropagation()">
            <button class="layer-reorder-btn" ${isFirstCat ? 'disabled' : ''} onclick="app.moveCategory('${escapedCat}',-1)" title="הזז למעלה"><i class="fas fa-chevron-up"></i></button>
            <button class="layer-reorder-btn" ${isLastCat ? 'disabled' : ''} onclick="app.moveCategory('${escapedCat}',1)" title="הזז למטה"><i class="fas fa-chevron-down"></i></button>
          </div>
          <span>${this._catRenames[cat] || cat}</span>
          <span class="badge">${catActiveCount}/${filtered.length}</span>
          <div class="layer-actions" onclick="event.stopPropagation()">
            <button class="layer-action-btn edit" onclick="app.renameCategory('${escapedCat}')" title="שנה שם"><i class="fas fa-pen"></i></button>
            <button class="layer-action-btn delete" onclick="app.deleteCategory('${escapedCat}')" title="מחק קטגוריה"><i class="fas fa-trash-alt"></i></button>
          </div>
          <button class="layer-cat-toggle ${catAllOn ? 'off' : 'on'}" onclick="event.stopPropagation();app.toggleCategoryLayers('${escapedCat}', ${catAllOn ? 'false' : 'true'})" title="${catAllOn ? 'כבה הכל' : 'הדלק הכל'}">
            <i class="fas ${catAllOn ? 'fa-toggle-on' : 'fa-toggle-off'}"></i> ${catAllOn ? 'כבה' : 'הדלק'}
          </button>
        </div>
        <div class="layer-items">
          ${filtered.map((l, lIdx) => {
            const isActive = this.activeLayers.has(l.file);
            const sColor = this.layerStyles[l.file]?.color || '#999';
            const hebName = layerHeb(l.name);
            const escapedFile = l.file.replace(/'/g, "\\'");
            const isFirst = lIdx === 0;
            const isLast = lIdx === filtered.length - 1;
            return `
            <div class="layer-item" onclick="app.toggleLayer('${l.file}', this)">
              <div class="layer-reorder-btns" onclick="event.stopPropagation()">
                <button class="layer-reorder-btn" ${isFirst ? 'disabled' : ''} onclick="app.moveLayerInCategory('${escapedCat}','${escapedFile}',-1)" title="הזז למעלה"><i class="fas fa-chevron-up"></i></button>
                <button class="layer-reorder-btn" ${isLast ? 'disabled' : ''} onclick="app.moveLayerInCategory('${escapedCat}','${escapedFile}',1)" title="הזז למטה"><i class="fas fa-chevron-down"></i></button>
              </div>
              <div class="layer-toggle${isActive ? ' on' : ''}" style="${isActive ? 'background:'+sColor : ''}"></div>
              <span class="layer-label">${this._layerRenames[l.file] || hebName}</span>
              <div class="layer-actions" onclick="event.stopPropagation()">
                <button class="layer-action-btn edit" onclick="app.renameGisLayer('${escapedFile}')" title="שנה שם"><i class="fas fa-pen"></i></button>
                <button class="layer-action-btn delete" onclick="app.deleteGisLayer('${escapedFile}')" title="הסתר שכבה"><i class="fas fa-trash-alt"></i></button>
              </div>
              <span class="layer-size">${l.size_kb > 1024 ? (l.size_kb / 1024).toFixed(1) + ' MB' : l.size_kb + ' KB'}</span>
              ${isActive ? renderLayerControls(l.file, false) : ''}
            </div>`;
          }).join('')}
        </div>
      </div>`;
    }

    // Global toggle bar
    const totalGis = allCatFiles.length;
    const totalGisOn = allCatFiles.filter(f => this.activeLayers.has(f)).length;
    const baseOn = (tabaOn ? 1 : 0) + (cadOn ? 1 : 0) + (migOn ? 1 : 0) + (parcOn ? 1 : 0);
    const planLayerCount = this._planLayers.size;
    const mmgLayerCount = this._mmgLayers.size;
    const dxfLayerCount = this._dxfLayers.size;
    const imgLayerCount = this._imageOverlays.size;
    const drawCount = this._drawItems.length;
    const globalAllOn = totalGisOn === totalGis && totalGis > 0 && baseOn === 4;
    const globalSomeOn = totalGisOn > 0 || baseOn > 0 || planLayerCount > 0 || mmgLayerCount > 0 || dxfLayerCount > 0 || imgLayerCount > 0 || drawCount > 0;
    const globalBar = `<div class="layers-global-bar">
      <span><i class="fas fa-layer-group"></i> ${totalGisOn + baseOn + planLayerCount + mmgLayerCount + dxfLayerCount + imgLayerCount + drawCount} שכבות פעילות</span>
      <button class="dxf-upload-btn" onclick="app.triggerDxfUpload()" title="העלה קובץ DXF או DWG"><i class="fas fa-upload"></i> DXF/DWG</button>
      <button class="dxf-upload-btn" onclick="app.triggerShpUpload()" title="העלה קובץ SHP/ZIP"><i class="fas fa-upload"></i> SHP</button>
      <button class="layers-global-btn on" onclick="app.toggleAllLayers(true)" title="הדלק הכל"><i class="fas fa-eye"></i> הדלק הכל</button>
      <button class="layers-global-btn off" onclick="app.toggleAllLayers(false)" title="כבה הכל"><i class="fas fa-eye-slash"></i> כבה הכל</button>
      ${this._hiddenLayers.size + this._hiddenCategories.size > 0 ? `<button class="dxf-upload-btn" onclick="app.restoreHiddenLayers()" title="שחזר שכבות מוסתרות" style="background:#f59e0b;color:#fff"><i class="fas fa-undo"></i> שחזר (${this._hiddenLayers.size + this._hiddenCategories.size})</button>` : ''}
    </div>`;

    // Migrash layer controls (extended - two color pickers + labels toggle)
    const renderMigrashControls = () => {
      const mColor = this._migrashColor;
      const mTextColor = this._migrashTextColor;
      const mOpacity = this._migrashOpacity;
      const mWeight = this._migrashWeight;
      const mOpacityPct = Math.round(mOpacity * 100);
      const showPalette = this._colorPaletteOpen === 'migrash';
      const showTextPalette = this._colorPaletteOpen === 'migrash-text';
      let ctrl = `<div class="layer-controls">
        <label>צבע מילוי</label>
        <button class="layer-color-btn" style="background:${mColor}" onclick="event.stopPropagation();app.toggleColorPalette('migrash')"></button>
        <label>שקיפות</label>
        <input type="range" class="layer-opacity-slider" min="0" max="100" value="${mOpacityPct}"
          oninput="event.stopPropagation();app.changeMigrashOpacity(this.value/100);this.nextElementSibling.textContent=this.value+'%'"
          onclick="event.stopPropagation()">
        <span class="layer-opacity-val">${mOpacityPct}%</span>
      </div>`;
      if (showPalette) {
        ctrl += `<div class="layer-color-palette" onclick="event.stopPropagation()">
          ${COLORS.map(c => `<div class="layer-color-swatch${c===mColor?' active':''}" style="background:${c}" onclick="app.changeMigrashColor('${c}')"></div>`).join('')}
        </div>`;
      }
      ctrl += `<div class="layer-controls">
        <label>צבע טקסט</label>
        <button class="layer-color-btn" style="background:${mTextColor}" onclick="event.stopPropagation();app.toggleColorPalette('migrash-text')"></button>
        <label>עובי קו</label>
        <input type="range" class="layer-opacity-slider" min="1" max="8" value="${mWeight}" style="width:60px"
          oninput="event.stopPropagation();app.changeMigrashWeight(parseInt(this.value));this.nextElementSibling.textContent=this.value"
          onclick="event.stopPropagation()">
        <span class="layer-opacity-val">${mWeight}</span>
        <button class="migrash-labels-toggle${this._showMigrashLabels?' on':''}" onclick="event.stopPropagation();app.toggleMigrashLabels()">
          <i class="fas fa-font"></i> תוויות
        </button>
      </div>`;
      if (showTextPalette) {
        ctrl += `<div class="layer-color-palette" onclick="event.stopPropagation()">
          ${['#1e293b','#ffffff','#ef4444','#8b5cf6','#06b6d4','#10b981','#f97316','#ec4899','#3b82f6','#f59e0b','#0f172a','#64748b'].map(c => `<div class="layer-color-swatch${c===mTextColor?' active':''}" style="background:${c};${c==='#ffffff'?'border:1px solid #ccc':''}" onclick="app.changeMigrashTextColor('${c}')"></div>`).join('')}
        </div>`;
      }
      return ctrl;
    };

    // Parcels layer controls
    const renderParcelsControls = () => {
      const pColor = this._parcelColor;
      const pOpacity = this._parcelOpacity;
      const pWeight = this._parcelWeight;
      const pOpacityPct = Math.round(pOpacity * 100);
      const showPalette = this._colorPaletteOpen === 'parcels';
      let ctrl = `<div class="layer-controls">
        <label>צבע</label>
        <button class="layer-color-btn" style="background:${pColor}" onclick="event.stopPropagation();app.toggleColorPalette('parcels')"></button>
        <label>שקיפות</label>
        <input type="range" class="layer-opacity-slider" min="0" max="100" value="${pOpacityPct}"
          oninput="event.stopPropagation();app.setParcelOpacity(this.value/100);this.nextElementSibling.textContent=this.value+'%'"
          onclick="event.stopPropagation()">
        <span class="layer-opacity-val">${pOpacityPct}%</span>
      </div>
      <div class="layer-controls">
        <label>עובי קו</label>
        <input type="range" class="layer-opacity-slider" min="1" max="8" value="${pWeight}" style="width:60px"
          oninput="event.stopPropagation();app.setParcelWeight(parseInt(this.value));this.nextElementSibling.textContent=this.value"
          onclick="event.stopPropagation()">
        <span class="layer-opacity-val">${pWeight}</span>
      </div>`;
      if (showPalette) {
        ctrl += `<div class="layer-color-palette" onclick="event.stopPropagation()">
          ${COLORS.map(c => `<div class="layer-color-swatch${c===pColor?' active':''}" style="background:${c}" onclick="app.setParcelColor('${c}');app._colorPaletteOpen=null;app.renderLayers()"></div>`).join('')}
        </div>`;
      }
      return ctrl;
    };

    // Plan layers section
    let planLayersHtml = '';
    if (this._planLayers.size > 0) {
      const plItems = [];
      for (const [planNum, info] of this._planLayers) {
        const plOn = this.map.hasLayer(info.layer);
        const plColor = info.color;
        const escapedPlan = planNum.replace(/'/g, "\\'");
        plItems.push(`
          <div class="layer-item" onclick="app.togglePlanLayerVisibility('${escapedPlan}')">
            <div class="layer-toggle${plOn ? ' on' : ''}" style="${plOn ? 'background:'+plColor : ''}"></div>
            <span class="layer-label" title="${planNum}"><i class="fas fa-map" style="margin-left:4px;font-size:10px"></i> ${this._layerRenames['plan:'+planNum] || planNum}</span>
            <button class="layer-action-btn edit" onclick="event.stopPropagation();app.renamePlanLayer('${escapedPlan}')" title="שנה שם"><i class="fas fa-pen"></i></button>
            <button class="add-layer-btn added" onclick="event.stopPropagation();app.removePlanLayer('${escapedPlan}')" title="הסר שכבה" style="background:#ef4444">
              <i class="fas fa-times"></i> הסר
            </button>
          </div>`);
      }
      planLayersHtml = `<div class="layer-group open plan-layer-group">
        <div class="layer-group-head open" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <i class="fas fa-chevron-left toggle"></i>
          <span>שכבות תכניות</span>
          <span class="badge">${this._planLayers.size}</span>
          <button class="layer-cat-toggle off" onclick="event.stopPropagation();app.removeAllPlanLayers()" title="הסר הכל">
            <i class="fas fa-trash"></i> הסר הכל
          </button>
        </div>
        <div class="layer-items">${plItems.join('')}</div>
      </div>`;
    }

    const baseTotal = 4;
    const baseAllOn = tabaOn && cadOn && migOn && parcOn;
    html = `
      <div class="layer-group open">
        <div class="layer-group-head open" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <i class="fas fa-chevron-left toggle"></i>
          <span>שכבות בסיס</span>
          <span class="badge">${baseOn}/${baseTotal}</span>
          <button class="layer-cat-toggle ${baseAllOn ? 'off' : 'on'}" onclick="event.stopPropagation();app.toggleAllBaseLayers(${baseAllOn ? 'false' : 'true'})" title="${baseAllOn ? 'כבה הכל' : 'הדלק הכל'}">
            <i class="fas ${baseAllOn ? 'fa-toggle-on' : 'fa-toggle-off'}"></i> ${baseAllOn ? 'כבה' : 'הדלק'}
          </button>
        </div>
        <div class="layer-items">
          <div class="layer-item" onclick="app.toggleBase('taba')">
            <div class="layer-toggle${tabaOn ? ' on' : ''}" style="${tabaOn ? 'background:'+(this.layerStyles.taba?.color||'#3b82f6') : ''}"></div>
            <span class="layer-label">תב"עות - גבולות תכניות</span>
            <span class="layer-size">128 KB</span>
            ${tabaOn ? renderLayerControls('taba', true) : ''}
          </div>
          <div class="layer-item" onclick="app.toggleBase('cadastre')">
            <div class="layer-toggle${cadOn ? ' on' : ''}" style="${cadOn ? 'background:'+(this.layerStyles.cadastre?.color||'#f59e0b') : ''}"></div>
            <span class="layer-label">קדסטר - גבולות גושים</span>
            <span class="layer-size">1.9 MB</span>
            ${cadOn ? renderLayerControls('cadastre', true) : ''}
          </div>
          <div class="layer-item" onclick="app.toggleMigrash()">
            <div class="layer-toggle${migOn ? ' on' : ''}" style="${migOn ? 'background:'+this._migrashColor : ''}"></div>
            <span class="layer-label"><i class="fas fa-home" style="margin-left:4px;font-size:10px"></i> מגרשים</span>
            <span class="layer-size">שכבה</span>
            ${migOn ? renderMigrashControls() : ''}
          </div>
          <div class="layer-item" onclick="app.toggleParcelsLayer()">
            <div class="layer-toggle${parcOn ? ' on' : ''}" style="${parcOn ? 'background:'+(this._parcelColor) : ''}"></div>
            <span class="layer-label"><i class="fas fa-vector-square" style="margin-left:4px;font-size:10px"></i> חלקות${this.selectedBlock ? ' (גוש '+this.selectedBlock+')' : ''}</span>
            <span class="layer-size">${this._parcelsLayer ? this._parcelsLayer.getLayers().length : 0}</span>
            ${parcOn ? renderParcelsControls() : ''}
          </div>
          ${(parcOn || migOn) ? `<div style="padding:6px 16px;border-bottom:1px solid #f1f5f9;display:flex;align-items:center;gap:8px;flex-wrap:wrap">
            <span style="font-size:10px;color:var(--text2)"><i class="fas fa-info-circle" style="color:var(--accent)"></i> גרור תוויות למיקום הרצוי</span>
            <button class="label-reset-btn" onclick="event.stopPropagation();app.resetLabelPositions()">
              <i class="fas fa-undo"></i> אפס מיקומים
            </button>
          </div>` : ''}
        </div>
      </div>` + planLayersHtml + html;

    // MMG layers section
    let mmgLayersHtml = '';
    if (this._mmgLayers.size > 0) {
      const mmgItems = [];
      for (const [key, info] of this._mmgLayers) {
        const mOn = this.map.hasLayer(info.layer);
        const escapedKey = key.replace(/'/g, "\\'");
        mmgItems.push(`
          <div class="layer-item" onclick="app.toggleMMGLayerVisibility('${escapedKey}')">
            <div class="layer-toggle${mOn ? ' on' : ''}" style="${mOn ? 'background:'+info.color : ''}"></div>
            <span class="layer-label" title="${key}"><i class="fas fa-drafting-compass" style="margin-left:4px;font-size:10px;color:#8b5cf6"></i> ${this._layerRenames['mmg:'+key] || info.name}</span>
            <button class="layer-action-btn edit" onclick="event.stopPropagation();app.renameMMGLayer('${escapedKey}')" title="שנה שם"><i class="fas fa-pen"></i></button>
            <button class="add-layer-btn added" onclick="event.stopPropagation();app.removeMMGLayerByKey('${escapedKey}')" title="הסר שכבה" style="background:#ef4444;font-size:10px">
              <i class="fas fa-times"></i>
            </button>
          </div>`);
      }
      mmgLayersHtml = `<div class="layer-group open plan-layer-group">
        <div class="layer-group-head open" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <i class="fas fa-chevron-left toggle"></i>
          <span>שכבות מ"מ"ג</span>
          <span class="badge">${this._mmgLayers.size}</span>
          <button class="layer-cat-toggle off" onclick="event.stopPropagation();app.removeAllMMGLayers()" title="הסר הכל">
            <i class="fas fa-trash"></i> הסר הכל
          </button>
        </div>
        <div class="layer-items">${mmgItems.join('')}</div>
      </div>`;
    }
    html = mmgLayersHtml + html;

    // DXF layers section
    let dxfLayersHtml = '';
    if (this._dxfUploading) {
      dxfLayersHtml += `<div class="dxf-upload-progress"><div class="spinner-sm"></div> מעלה ומפענח קובץ DXF...</div>`;
    }
    if (this._dxfLayers.size > 0) {
      const dxfItems = [];
      for (const [dxfId, info] of this._dxfLayers) {
        const dOn = this.map.hasLayer(info.layer);
        const icon = info.isPlanning ? 'fa-city' : (info.isShp ? 'fa-map' : 'fa-drafting-compass');
        const typeLabel = info.isPlanning ? 'תכנוני' : (info.isShp ? 'SHP' : 'DXF');
        const iconColor = info.isPlanning ? '#4caf50' : info.color;
        
        let itemHtml = `
          <div class="layer-item" onclick="app.toggleDxfLayerVisibility(${dxfId})">
            <div class="layer-toggle${dOn ? ' on' : ''}" style="${dOn ? 'background:'+iconColor : ''}"></div>
            <span class="layer-label" title="${info.name}"><i class="fas ${icon}" style="margin-left:4px;font-size:10px;color:${iconColor}"></i> ${this._layerRenames['dxf:'+dxfId] || info.name}</span>`;
        
        // Rename button
        itemHtml += `<button class="layer-action-btn edit" onclick="event.stopPropagation();app.renameDxfLayer(${dxfId})" title="שנה שם"><i class="fas fa-pen"></i></button>`;
        
        // Legend toggle button for planning layers
        if (info.isPlanning) {
          const legendOn = this._planningLegendVisible.get(dxfId);
          itemHtml += `<button class="add-layer-btn${legendOn ? ' added' : ''}" onclick="event.stopPropagation();app.togglePlanningLegendVisibility(${dxfId})" title="מקרא" style="background:${legendOn ? '#4caf50' : '#94a3b8'};font-size:10px;margin-left:2px">
              <i class="fas fa-palette"></i>
            </button>`;
        }
        
        // Style settings toggle
        const styleOpen = this._dxfStyleOpen.has(dxfId);
        itemHtml += `<button class="shp-settings-btn${styleOpen ? ' open' : ''}" onclick="event.stopPropagation();app.toggleShpStylePanel(${dxfId})" title="הגדרות עיצוב">
              <i class="fas fa-sliders-h"></i>
            </button>`;
        
        itemHtml += `<button class="add-layer-btn added" onclick="event.stopPropagation();app.removeDxfLayer(${dxfId})" title="הסר שכבה" style="background:#ef4444;font-size:10px">
              <i class="fas fa-times"></i>
            </button>
          </div>`;
        
        // Style controls panel (expanded)
        if (styleOpen) {
          const st = info.style || {};
          const fillColor = st.fillColor || info.color || '#8b5cf6';
          const fillOpacity = st.fillOpacity != null ? st.fillOpacity : 0.3;
          const borderColor = st.borderColor || info.color || '#8b5cf6';
          const borderOpacity = st.borderOpacity != null ? st.borderOpacity : 1;
          const borderWeight = st.borderWeight != null ? st.borderWeight : (info.isPlanning ? 1.5 : 2);
          const fillOpPct = Math.round(fillOpacity * 100);
          const borderOpPct = Math.round(borderOpacity * 100);
          
          itemHtml += `<div class="shp-style-panel" onclick="event.stopPropagation()">
            <div class="shp-style-row">
              <label>צבע מילוי</label>
              <input type="color" value="${fillColor}" onchange="app.changeShpFillColor(${dxfId},this.value)">
              <label>שקיפות</label>
              <input type="range" class="layer-opacity-slider" min="0" max="100" value="${fillOpPct}"
                oninput="app.changeShpFillOpacity(${dxfId},this.value/100);this.nextElementSibling.textContent=this.value+'%'">
              <span class="style-val">${fillOpPct}%</span>
            </div>
            <div class="shp-style-row">
              <label>צבע מסגרת</label>
              <input type="color" value="${borderColor}" onchange="app.changeShpBorderColor(${dxfId},this.value)">
              <label>שקיפות</label>
              <input type="range" class="layer-opacity-slider" min="0" max="100" value="${borderOpPct}"
                oninput="app.changeShpBorderOpacity(${dxfId},this.value/100);this.nextElementSibling.textContent=this.value+'%'">
              <span class="style-val">${borderOpPct}%</span>
            </div>
            <div class="shp-style-row">
              <label>עובי מסגרת</label>
              <input type="range" class="layer-opacity-slider" min="0" max="8" step="0.5" value="${borderWeight}" style="max-width:80px"
                oninput="app.changeShpBorderWeight(${dxfId},parseFloat(this.value));this.nextElementSibling.textContent=this.value">
              <span class="style-val">${borderWeight}</span>
            </div>
          </div>`;
        }
        
        // Planning category chips (when layer is on and is a planning layer)
        if (dOn && info.isPlanning && info.catCounts) {
          const sortedCats = Object.entries(info.catCounts).sort((a,b) => b[1] - a[1]);
          itemHtml += `<div class="planning-cat-chips">`;
          for (const [cat, count] of sortedCats) {
            const cfg = this._planningCategories[cat] || this._planningCategories['אחר'];
            const isOn = info.visibleCategories.has(cat);
            itemHtml += `<span class="planning-cat-chip${isOn ? ' active' : ''}" 
              style="border-color:${cfg.color};${isOn ? 'background:'+cfg.color : ''}" 
              onclick="event.stopPropagation();app.togglePlanningCategory(${dxfId},'${cat}')"
              title="${cat}: ${count} פוליגונים"><i class="fas ${cfg.icon}" style="font-size:9px"></i> ${cat} (${count})</span>`;
          }
          itemHtml += `</div>`;
        }
        
        // DXF sub-layer filter chips (for non-planning DXF layers)
        if (dOn && !info.isPlanning && info.dxfLayerNames.length > 1) {
          itemHtml += `<div class="dxf-layer-filter">
            ${info.dxfLayerNames.map(ln => `<span class="dxf-layer-chip${info.visibleDxfLayers.has(ln) ? ' active' : ''}" onclick="event.stopPropagation();app.toggleDxfSubLayer(${dxfId},'${ln.replace(/'/g, "\\'")}')"
              title="${ln}">${ln || '(ללא שם)'}</span>`).join('')}
          </div>`;
        }
        
        dxfItems.push(itemHtml);
      }
      
      // Count planning vs DXF layers
      const planningCount = [...this._dxfLayers.values()].filter(i => i.isPlanning).length;
      const dxfCount = this._dxfLayers.size - planningCount;
      const sectionTitle = planningCount > 0 && dxfCount > 0 
        ? `שכבות DXF/תכנוני (${planningCount} תכנוני, ${dxfCount} DXF)` 
        : planningCount > 0 ? `שכבות מידע תכנוני` : `שכבות DXF`;
      
      dxfLayersHtml += `<div class="layer-group open plan-layer-group">
        <div class="layer-group-head open" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <i class="fas fa-chevron-left toggle"></i>
          <span>${sectionTitle}</span>
          <span class="badge">${this._dxfLayers.size}</span>
          <button class="dxf-upload-btn" onclick="event.stopPropagation();app.triggerDxfUpload()" title="העלה נוסף" style="font-size:10px;padding:2px 6px">
            <i class="fas fa-plus"></i>
          </button>
          <button class="layer-cat-toggle off" onclick="event.stopPropagation();app.removeAllDxfLayers()" title="הסר הכל">
            <i class="fas fa-trash"></i> הסר הכל
          </button>
        </div>
        <div class="layer-items">${dxfItems.join('')}</div>
      </div>`;
    }
    html = dxfLayersHtml + html;

    // Image overlay layers section
    let imgLayersHtml = '';
    if (this._imageOverlays.size > 0) {
      const imgItems = [];
      for (const [imgId, info] of this._imageOverlays) {
        const iOn = this.map.hasLayer(info.overlay);
        const isActive = imgId === this._activeImageOverlayId;
        imgItems.push(`
          <div class="layer-item${isActive ? ' active' : ''}" onclick="app.selectImageOverlay(${imgId})" style="${isActive ? 'background:var(--accent-light)' : ''}">
            <div class="layer-toggle${iOn ? ' on' : ''}" onclick="event.stopPropagation();app.toggleImageOverlayVisibility(${imgId})" style="${iOn ? 'background:#f97316' : ''}"></div>
            <span class="layer-label" title="${info.name}"><i class="fas fa-image" style="margin-left:4px;font-size:10px;color:#f97316"></i> ${this._layerRenames['img:'+imgId] || info.name}</span>
            <button class="layer-action-btn edit" onclick="event.stopPropagation();app.renameImageOverlay(${imgId})" title="שנה שם"><i class="fas fa-pen"></i></button>
            <button class="add-layer-btn added" onclick="event.stopPropagation();app.removeActiveImageOverlay(${imgId})" title="הסר" style="background:#ef4444;font-size:10px">
              <i class="fas fa-times"></i>
            </button>
          </div>`);
      }
      imgLayersHtml = `<div class="layer-group open plan-layer-group">
        <div class="layer-group-head open" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <i class="fas fa-chevron-left toggle"></i>
          <span>שכבות תמונה</span>
          <span class="badge">${this._imageOverlays.size}</span>
          <button class="dxf-upload-btn" onclick="event.stopPropagation();app.triggerImageOverlay()" title="העלה תמונה" style="font-size:10px;padding:2px 6px">
            <i class="fas fa-plus"></i>
          </button>
          <button class="layer-cat-toggle off" onclick="event.stopPropagation();app.removeAllImageOverlays()" title="הסר הכל">
            <i class="fas fa-trash"></i> הסר הכל
          </button>
        </div>
        <div class="layer-items">${imgItems.join('')}</div>
      </div>`;
    }
    html = imgLayersHtml + html;

    // Drawing items section
    let drawLayersHtml = '';
    if (this._drawItems.length > 0) {
      const TYPE_ICONS = { polyline: 'fa-minus', polygon: 'fa-draw-polygon', circle: 'fa-circle', rectangle: 'fa-vector-square', marker: 'fa-map-marker-alt', text: 'fa-font' };
      const TYPE_NAMES = { polyline: 'קו', polygon: 'פוליגון', circle: 'עיגול', rectangle: 'מלבן', marker: 'סימן', text: 'טקסט' };
      const drawItems = this._drawItems.map(item => {
        const iOn = this.map.hasLayer(item.layer);
        const icon = TYPE_ICONS[item.type] || 'fa-pencil-alt';
        const name = TYPE_NAMES[item.type] || item.type;
        const color = item.props?.color || '#e11d48';
        let info = '';
        if (item.type === 'polyline' && item.props.length) {
          info = item.props.length > 1000 ? ` (${(item.props.length / 1000).toFixed(1)} ק"מ)` : ` (${Math.round(item.props.length)} מ')`;
        } else if (item.props?.area) {
          info = item.props.area > 10000 ? ` (${(item.props.area / 10000).toFixed(1)} דונם)` : ` (${Math.round(item.props.area)} מ"ר)`;
        } else if (item.props?.text) {
          info = ` "${item.props.text.substring(0, 15)}"`;
        }
        const drawDisplayName = this._layerRenames['draw:'+item.id] || `${name} #${item.id}`;
        return `<div class="layer-item" onclick="app.zoomToDrawItem(${item.id})">
            <div class="layer-toggle${iOn ? ' on' : ''}" onclick="event.stopPropagation();app.toggleDrawItemVisibility(${item.id})" style="${iOn ? 'background:' + color : ''}"></div>
            <span class="layer-label"><i class="fas ${icon}" style="margin-left:4px;font-size:10px;color:${color}"></i> ${drawDisplayName}${info}</span>
            <button class="layer-action-btn edit" onclick="event.stopPropagation();app.renameDrawItem(${item.id})" title="שנה שם"><i class="fas fa-pen"></i></button>
            <button class="add-layer-btn added" onclick="event.stopPropagation();app.deleteDrawItem(${item.id})" title="מחק" style="background:#ef4444;font-size:10px"><i class="fas fa-times"></i></button>
          </div>`;
      }).join('');
      drawLayersHtml = `<div class="layer-group open plan-layer-group">
        <div class="layer-group-head open" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <i class="fas fa-chevron-left toggle"></i>
          <span>ציורים וסימנים</span>
          <span class="badge">${this._drawItems.length}</span>
          <button class="dxf-upload-btn" onclick="event.stopPropagation();app.toggleDrawMode()" title="כלי ציור" style="font-size:10px;padding:2px 6px">
            <i class="fas fa-pen-fancy"></i>
          </button>
          <button class="layer-cat-toggle off" onclick="event.stopPropagation();app.clearAllDrawings()" title="מחק הכל">
            <i class="fas fa-trash"></i> מחק הכל
          </button>
        </div>
        <div class="layer-items">${drawItems}</div>
      </div>`;
    }
    html = drawLayersHtml + html;

    // Saved uploaded layers section
    let savedLayersHtml = '';
    const savedList = this._savedLayersList || [];
    if (savedList.length > 0) {
      const savedItems = savedList.map(f => {
        const sName = f.name;
        const loadedEntry = [...this._dxfLayers.entries()].find(([,i]) => i.savedName === sName);
        const isLoaded = !!loadedEntry;
        const isVisible = isLoaded && this.map.hasLayer(loadedEntry[1].layer);
        const sizeMB = (f.size / 1024 / 1024).toFixed(1);
        const escapedName = sName.replace(/'/g, "\\'");
        return `<div class="layer-item" style="align-items:center">
          <div class="layer-toggle${isVisible ? ' on' : ''}"
            style="${isVisible ? 'background:#8b5cf6' : ''}"
            onclick="event.stopPropagation();${isLoaded ? `app.toggleDxfLayerVisibility(${loadedEntry[0]})` : `app.loadSavedLayer('${escapedName}')`}"
            title="${isLoaded ? 'הדלק/כבה' : 'טען שכבה'}"></div>
          <span class="layer-label" style="flex:1" title="${sName}">
            <i class="fas fa-file-archive" style="margin-left:4px;font-size:10px;color:#8b5cf6"></i>
            ${sName}
            ${isLoaded ? '<span style="font-size:10px;color:#10b981;margin-right:4px">✓ טעונה</span>' : ''}
          </span>
          <span class="layer-size">${sizeMB} MB</span>
          ${!isLoaded ? `<button class="add-layer-btn" onclick="event.stopPropagation();app.loadSavedLayer('${escapedName}')" style="font-size:10px;padding:2px 6px"><i class="fas fa-download"></i> טען</button>` : ''}
          <button class="layer-action-btn delete" onclick="event.stopPropagation();app.deleteUploadedFile('${escapedName}')" title="מחק מהשרת"><i class="fas fa-trash-alt"></i></button>
        </div>`;
      }).join('');
      savedLayersHtml = `<div class="layer-group open plan-layer-group" style="border-right:3px solid #8b5cf6">
        <div class="layer-group-head open" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <i class="fas fa-chevron-left toggle"></i>
          <span><i class="fas fa-database" style="margin-left:4px;color:#8b5cf6"></i> שכבות שמורות</span>
          <span class="badge">${savedList.length}</span>
          <button class="dxf-upload-btn" onclick="event.stopPropagation();app.refreshSavedLayersList()" title="רענן רשימה" style="font-size:10px;padding:2px 6px"><i class="fas fa-sync-alt"></i></button>
          <button class="dxf-upload-btn" onclick="event.stopPropagation();app.triggerShpUpload()" title="העלה קובץ SHP/ZIP חדש" style="font-size:10px;padding:2px 6px"><i class="fas fa-plus"></i> הוסף</button>
        </div>
        <div class="layer-items">${savedItems}</div>
      </div>`;
    } else {
      savedLayersHtml = `<div class="layer-group plan-layer-group" style="border-right:3px solid #8b5cf6">
        <div class="layer-group-head" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <i class="fas fa-chevron-left toggle"></i>
          <span><i class="fas fa-database" style="margin-left:4px;color:#8b5cf6"></i> שכבות שמורות</span>
          <span class="badge">0</span>
          <button class="dxf-upload-btn" onclick="event.stopPropagation();app.triggerShpUpload()" style="font-size:10px;padding:2px 6px"><i class="fas fa-upload"></i> העלה ZIP/SHP</button>
        </div>
        <div class="layer-items"><div class="empty" style="padding:12px;font-size:12px">אין שכבות שמורות. העלה ZIP/SHP לשמירה קבועה.</div></div>
      </div>`;
    }
    html = savedLayersHtml + html;

    el.innerHTML = globalBar + (html || '<div class="empty"><i class="fas fa-layer-group"></i><p>לא נמצאו שכבות</p></div>');
  }

  /* ── Layer/Category Reordering ── */
  _getOrderedCategories(catEntries) {
    if (!this._categoryOrder.length) return catEntries;
    const catMap = new Map(catEntries);
    const ordered = [];
    // First add categories in saved order
    for (const name of this._categoryOrder) {
      if (catMap.has(name)) {
        ordered.push([name, catMap.get(name)]);
        catMap.delete(name);
      }
    }
    // Then add any new categories not in saved order
    for (const [name, layers] of catMap) {
      ordered.push([name, layers]);
    }
    return ordered;
  }

  _getOrderedLayers(cat, layers) {
    const savedOrder = this._layerOrder[cat];
    if (!savedOrder || !savedOrder.length) return layers;
    const layerMap = new Map(layers.map(l => [l.file, l]));
    const ordered = [];
    for (const file of savedOrder) {
      if (layerMap.has(file)) {
        ordered.push(layerMap.get(file));
        layerMap.delete(file);
      }
    }
    // Add any new layers not in saved order
    for (const [, l] of layerMap) {
      ordered.push(l);
    }
    return ordered;
  }

  moveCategory(catName, direction) {
    const cats = this.data?.layer_categories || {};
    const catEntries = Object.entries(cats);
    const ordered = this._getOrderedCategories(catEntries);
    const names = ordered.map(([n]) => n);
    const idx = names.indexOf(catName);
    if (idx === -1) return;
    const newIdx = idx + direction;
    if (newIdx < 0 || newIdx >= names.length) return;
    // Swap
    [names[idx], names[newIdx]] = [names[newIdx], names[idx]];
    this._categoryOrder = names;
    localStorage.setItem('categoryOrder', JSON.stringify(names));
    this.renderLayers();
  }

  moveLayerInCategory(catName, file, direction) {
    const cats = this.data?.layer_categories || {};
    const rawLayers = cats[catName];
    if (!rawLayers) return;
    const layers = this._getOrderedLayers(catName, rawLayers);
    const files = layers.map(l => l.file);
    const idx = files.indexOf(file);
    if (idx === -1) return;
    const newIdx = idx + direction;
    if (newIdx < 0 || newIdx >= files.length) return;
    // Swap
    [files[idx], files[newIdx]] = [files[newIdx], files[idx]];
    this._layerOrder[catName] = files;
    localStorage.setItem('layerOrder', JSON.stringify(this._layerOrder));
    this.renderLayers();
  }

  /* ── Rename & Delete (Categories + Layers) ── */
  _saveRenames() {
    localStorage.setItem('layerRenames', JSON.stringify(this._layerRenames));
  }
  _saveCatRenames() {
    localStorage.setItem('catRenames', JSON.stringify(this._catRenames));
  }
  _saveHiddenLayers() {
    localStorage.setItem('hiddenLayers', JSON.stringify([...this._hiddenLayers]));
  }
  _saveHiddenCategories() {
    localStorage.setItem('hiddenCategories', JSON.stringify([...this._hiddenCategories]));
  }

  renameCategory(catName) {
    const current = this._catRenames[catName] || catName;
    const newName = prompt('שם חדש לקטגוריה:', current);
    if (newName == null || newName.trim() === '') return;
    this._catRenames[catName] = newName.trim();
    this._saveCatRenames();
    this.renderLayers();
  }

  deleteCategory(catName) {
    const displayName = this._catRenames[catName] || catName;
    if (!confirm(`למחוק את הקטגוריה "${displayName}" ואת כל השכבות שבה?`)) return;
    // Turn off all layers in this category
    const cats = this.data?.layer_categories || {};
    const layers = cats[catName] || [];
    for (const l of layers) {
      if (this.activeLayers.has(l.file)) {
        const layer = this.activeLayers.get(l.file);
        this.map.removeLayer(layer);
        this.activeLayers.delete(l.file);
      }
    }
    this._hiddenCategories.add(catName);
    this._saveHiddenCategories();
    this.renderLayers();
  }

  renameGisLayer(file) {
    const defaultName = layerHeb(file.replace(/\.geojson$/, '').split('/').pop());
    const current = this._layerRenames[file] || defaultName;
    const newName = prompt('שם חדש לשכבה:', current);
    if (newName == null || newName.trim() === '') return;
    this._layerRenames[file] = newName.trim();
    this._saveRenames();
    this.renderLayers();
  }

  deleteGisLayer(file) {
    const displayName = this._layerRenames[file] || layerHeb(file.replace(/\.geojson$/, '').split('/').pop());
    if (!confirm(`להסתיר את השכבה "${displayName}"?`)) return;
    // Turn off layer if active
    if (this.activeLayers.has(file)) {
      const layer = this.activeLayers.get(file);
      this.map.removeLayer(layer);
      this.activeLayers.delete(file);
    }
    this._hiddenLayers.add(file);
    this._saveHiddenLayers();
    this.renderLayers();
  }

  renameDxfLayer(dxfId) {
    const info = this._dxfLayers.get(dxfId);
    if (!info) return;
    const current = this._layerRenames['dxf:'+dxfId] || info.name;
    const newName = prompt('שם חדש לשכבה:', current);
    if (newName == null || newName.trim() === '') return;
    this._layerRenames['dxf:'+dxfId] = newName.trim();
    info.name = newName.trim();
    this._saveRenames();
    this.renderLayers();
  }

  renamePlanLayer(planNumber) {
    const current = this._layerRenames['plan:'+planNumber] || planNumber;
    const newName = prompt('שם חדש לשכבת תכנית:', current);
    if (newName == null || newName.trim() === '') return;
    this._layerRenames['plan:'+planNumber] = newName.trim();
    this._saveRenames();
    this.renderLayers();
  }

  renameMMGLayer(key) {
    const info = this._mmgLayers.get(key);
    const current = this._layerRenames['mmg:'+key] || (info ? info.name : key);
    const newName = prompt('שם חדש לשכבה:', current);
    if (newName == null || newName.trim() === '') return;
    this._layerRenames['mmg:'+key] = newName.trim();
    if (info) info.name = newName.trim();
    this._saveRenames();
    this.renderLayers();
  }

  renameImageOverlay(imgId) {
    const info = this._imageOverlays.get(imgId);
    if (!info) return;
    const current = this._layerRenames['img:'+imgId] || info.name;
    const newName = prompt('שם חדש לשכבת תמונה:', current);
    if (newName == null || newName.trim() === '') return;
    this._layerRenames['img:'+imgId] = newName.trim();
    info.name = newName.trim();
    this._saveRenames();
    this.renderLayers();
  }

  renameDrawItem(drawId) {
    const item = this._drawItems.find(d => d.id === drawId);
    if (!item) return;
    const TYPE_NAMES = { polyline: 'קו', polygon: 'פוליגון', circle: 'עיגול', rectangle: 'מלבן', marker: 'סימן', text: 'טקסט' };
    const defaultName = `${TYPE_NAMES[item.type] || item.type} #${drawId}`;
    const current = this._layerRenames['draw:'+drawId] || defaultName;
    const newName = prompt('שם חדש לציור:', current);
    if (newName == null || newName.trim() === '') return;
    this._layerRenames['draw:'+drawId] = newName.trim();
    this._saveRenames();
    this.renderLayers();
  }

  restoreHiddenLayers() {
    if (!this._hiddenLayers.size && !this._hiddenCategories.size) {
      alert('אין שכבות או קטגוריות מוסתרות');
      return;
    }
    const count = this._hiddenLayers.size + this._hiddenCategories.size;
    if (!confirm(`לשחזר ${count} שכבות/קטגוריות מוסתרות?`)) return;
    this._hiddenLayers.clear();
    this._hiddenCategories.clear();
    this._saveHiddenLayers();
    this._saveHiddenCategories();
    this.renderLayers();
  }

  async toggleAllBaseLayers(turnOn) {
    if (turnOn) {
      if (this.tabaLayer && !this.map.hasLayer(this.tabaLayer)) this.tabaLayer.addTo(this.map);
      if (this.cadastreLayer && !this.map.hasLayer(this.cadastreLayer)) this.cadastreLayer.addTo(this.map);
      if (!this._migrashOn) { await this.loadMigrashLayer(); this._migrashOn = true; }
      // Parcels: turn on if they were loaded
      if (this._parcelsLayer && !this.map.hasLayer(this._parcelsLayer)) {
        this._parcelsLayer.addTo(this.map);
        if (this._parcelLabelsLayer) this._parcelLabelsLayer.addTo(this.map);
        this._parcelsOn = true;
      }
    } else {
      if (this.tabaLayer && this.map.hasLayer(this.tabaLayer)) this.map.removeLayer(this.tabaLayer);
      if (this.cadastreLayer && this.map.hasLayer(this.cadastreLayer)) this.map.removeLayer(this.cadastreLayer);
      if (this._migrashOn) {
        if (this._migrashLabelsLayer) { this.map.removeLayer(this._migrashLabelsLayer); this._migrashLabelsLayer = null; }
        if (this._migrashLayer) { this.map.removeLayer(this._migrashLayer); this._migrashLayer = null; }
        this._migrashOn = false;
      }
      // Parcels: turn off
      if (this._parcelsLayer && this.map.hasLayer(this._parcelsLayer)) {
        this.map.removeLayer(this._parcelsLayer);
        if (this._parcelLabelsLayer) this.map.removeLayer(this._parcelLabelsLayer);
        this._parcelsOn = false;
      }
    }
    this.renderLayers();
  }

  /* ── Parcels Layer Toggle ── */
  toggleParcelsLayer() {
    if (!this._parcelsLayer) return; // No parcels loaded
    if (this._parcelsOn && this.map.hasLayer(this._parcelsLayer)) {
      this.map.removeLayer(this._parcelsLayer);
      if (this._parcelLabelsLayer) this.map.removeLayer(this._parcelLabelsLayer);
      this._parcelsOn = false;
    } else {
      this._parcelsLayer.addTo(this.map);
      if (this._parcelLabelsLayer) this._parcelLabelsLayer.addTo(this.map);
      this._parcelsOn = true;
    }
    this.renderLayers();
  }

  /* ── Plan Layer Management ── */
  async togglePlanLayer(planNumber) {
    // If already added, remove it
    if (this._planLayers.has(planNumber)) {
      this.removePlanLayer(planNumber);
      return;
    }

    // Prefer precise MMG plan boundary when available (especially for 425-* detailed plans)
    let geoJson = null;
    let name = planNumber;
    let sourceLabel = '';
    try {
      const mmgLayers = this._mmgIndex?.[planNumber] || null;
      if (mmgLayers && mmgLayers.length) {
        const preferred = mmgLayers.find(l => l.name === 'MVT_GVUL') || mmgLayers.find(l => l.name === 'MVT_PLAN');
        if (preferred && preferred.file) {
          const res = await fetch(`/api/mmg/${encodeURIComponent(planNumber)}/${encodeURIComponent(preferred.file)}`);
          if (res.ok) {
            geoJson = await res.json();
            sourceLabel = `ממ\"ג (${preferred.name_heb || preferred.name})`;
          }
        }
      }
    } catch (e) {
      // fall back to TABA boundary
    }

    // Fallback: find the plan polygon in TABA layer
    if (!geoJson) {
      if (!this.tabaLayer) return;
      let planFeature = null;
      this.tabaLayer.eachLayer(layer => {
        const props = layer.feature?.properties || {};
        const n = props.pl_number || props.PL_NUMBER || props.PLAN_NUMBER || props.PL_NUMB || props.NUMB;
        if (String(n || '') === String(planNumber || '')) {
          planFeature = layer;
        }
      });

      if (!planFeature) {
        this.showToast('לא נמצא גבול תכנית במפה', 'warning');
        return;
      }

      geoJson = planFeature.feature;
      name = geoJson?.properties?.pl_name || geoJson?.properties?.PL_NAME || geoJson?.properties?.PLAN_NAME || planNumber;
      sourceLabel = 'תב\"ע (כללי)';
    }

    // Create a colored overlay of the plan boundary
    const PLAN_COLORS = ['#ef4444','#8b5cf6','#06b6d4','#10b981','#f97316','#ec4899','#6366f1','#14b8a6','#f59e0b','#84cc16'];
    const color = PLAN_COLORS[this._planLayers.size % PLAN_COLORS.length];
    const newLayer = L.geoJSON(geoJson, {
      // TABA is stored in ITM meters; MMG is stored as WGS84. This converter auto-detects.
      coordsToLatLng: itmToLatLng,
      style: { color: color, weight: 3, fillColor: color, fillOpacity: 0.2, dashArray: '6 3' }
    });
    newLayer.addTo(this.map);

    // Add label with plan number
    const bounds = newLayer.getBounds();
    const center = bounds.getCenter();
    const label = L.marker(center, {
      icon: L.divIcon({
        className: 'plan-label-icon',
        html: `<div style="background:${color};color:#fff;padding:2px 6px;border-radius:4px;font-size:11px;font-weight:bold;white-space:nowrap;text-shadow:0 1px 2px rgba(0,0,0,0.5)">${planNumber}</div>`,
        iconSize: [0, 0],
        iconAnchor: [-5, 10]
      })
    });
    label.addTo(this.map);
    this._planLayers.set(planNumber, { layer: newLayer, label: label, color: color, name: name });

    this.showToast(`תכנית ${planNumber} נוספה כשכבה${sourceLabel ? ' • ' + sourceLabel : ''}`, 'success');
    this.renderLayers();
    this.renderPlans();
  }

  togglePlanLayerVisibility(planNumber) {
    const info = this._planLayers.get(planNumber);
    if (!info) return;
    if (this.map.hasLayer(info.layer)) {
      this.map.removeLayer(info.layer);
      if (info.label) this.map.removeLayer(info.label);
    } else {
      info.layer.addTo(this.map);
      if (info.label) info.label.addTo(this.map);
    }
    this.renderLayers();
  }

  removePlanLayer(planNumber) {
    const info = this._planLayers.get(planNumber);
    if (!info) return;
    if (this.map.hasLayer(info.layer)) this.map.removeLayer(info.layer);
    if (info.label && this.map.hasLayer(info.label)) this.map.removeLayer(info.label);
    this._planLayers.delete(planNumber);
    this.showToast(`שכבת תכנית ${planNumber} הוסרה`, 'info');
    this.renderLayers();
    this.renderPlans();
  }

  removeAllPlanLayers() {
    for (const [planNum, info] of this._planLayers) {
      if (this.map.hasLayer(info.layer)) this.map.removeLayer(info.layer);
      if (info.label && this.map.hasLayer(info.label)) this.map.removeLayer(info.label);
    }
    this._planLayers.clear();
    this.showToast('כל שכבות התכניות הוסרו', 'info');
    this.renderLayers();
    this.renderPlans();
  }

  /* ── MMG Layer Management ── */
  showMMGLayers(planNumber) {
    if (!this._mmgIndex || !this._mmgIndex[planNumber]) return;
    const layers = this._mmgIndex[planNumber];
    const escapedPlan = planNumber.replace(/'/g, "\\'");

    // Build modal/popup with layer list
    const existing = document.getElementById('mmg-modal');
    if (existing) existing.remove();

    const modal = document.createElement('div');
    modal.id = 'mmg-modal';
    modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:9999;display:flex;align-items:center;justify-content:center';
    modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

    const layerItems = layers.map(l => {
      const key = `${planNumber}/${l.name}`;
      const isAdded = this._mmgLayers.has(key);
      return `<div style="display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid var(--border);direction:rtl">
        <div>
          <strong style="font-size:13px">${l.name_heb || l.name}</strong>
          <span style="font-size:11px;color:var(--text2);margin-right:8px">${l.features} אלמנטים</span>
        </div>
        <button class="add-layer-btn ${isAdded ? 'added' : ''}" onclick="app.toggleMMGLayer('${escapedPlan}','${l.name}','${l.file}','${(l.name_heb||l.name).replace(/'/g,"\\'")}');app.showMMGLayers('${escapedPlan}')" style="font-size:11px">
          <i class="fas ${isAdded ? 'fa-times' : 'fa-plus'}"></i> ${isAdded ? 'הסר' : 'הוסף'}
        </button>
      </div>`;
    }).join('');

    modal.innerHTML = `<div style="background:var(--bg);border-radius:12px;width:400px;max-height:70vh;overflow:auto;box-shadow:0 8px 32px rgba(0,0,0,0.3)">
      <div style="padding:16px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;direction:rtl">
        <div>
          <h3 style="margin:0;font-size:15px"><i class="fas fa-drafting-compass" style="color:#8b5cf6"></i> שכבות מ"מ"ג</h3>
          <div style="font-size:12px;color:var(--text2)">${planNumber}</div>
        </div>
        <div style="display:flex;gap:6px">
          <button class="add-layer-btn" onclick="app.addAllMMGLayers('${escapedPlan}');app.showMMGLayers('${escapedPlan}')" style="font-size:11px;background:#8b5cf6">
            <i class="fas fa-plus-circle"></i> הוסף הכל
          </button>
          <button onclick="document.getElementById('mmg-modal').remove()" style="background:none;border:none;cursor:pointer;font-size:18px;color:var(--text2)">&times;</button>
        </div>
      </div>
      <div>${layerItems}</div>
    </div>`;
    document.body.appendChild(modal);
  }

  async toggleMMGLayer(planNumber, layerName, fileName, nameHeb) {
    const key = `${planNumber}/${layerName}`;

    if (this._mmgLayers.has(key)) {
      // Remove
      const info = this._mmgLayers.get(key);
      if (this.map.hasLayer(info.layer)) this.map.removeLayer(info.layer);
      this._mmgLayers.delete(key);
      this.showToast(`שכבת ${nameHeb} הוסרה`, 'info');
      this.renderLayers();
      return;
    }

    // Load and add
    try {
      const res = await fetch(`/api/mmg/${planNumber}/${fileName}`);
      const geo = await res.json();
      if (!geo.features || !geo.features.length) {
        this.showToast('שכבה ריקה', 'warning');
        return;
      }

      const MMG_COLORS = ['#8b5cf6','#06b6d4','#10b981','#f97316','#ec4899','#ef4444','#6366f1','#14b8a6','#f59e0b','#84cc16'];
      const color = MMG_COLORS[this._mmgLayers.size % MMG_COLORS.length];

      const layer = L.geoJSON(geo, {
        style: { color: color, weight: 2, fillColor: color, fillOpacity: 0.15 },
        pointToLayer: (f, latlng) => L.circleMarker(latlng, { radius: 5, color: color, fillColor: color, fillOpacity: 0.7 }),
        onEachFeature: (f, layer) => {
          const props = f.properties || {};
          const popupLines = Object.entries(props).filter(([k,v]) => v && v !== '' && v !== 0).map(([k,v]) => `<div class="popup-row"><span class="k">${k}</span><span>${v}</span></div>`).join('');
          if (popupLines) layer.bindPopup(`<div class="popup-title">${nameHeb}</div>${popupLines}`);
        }
      });
      layer.addTo(this.map);

      this._mmgLayers.set(key, { layer, color, name: nameHeb, planNumber });
      this.showToast(`${nameHeb} (${planNumber}) נטען`, 'success');
      this.renderLayers();
    } catch(e) {
      console.error('MMG load error:', e);
      this.showToast('שגיאה בטעינת שכבה', 'error');
    }
  }

  async addAllMMGLayers(planNumber) {
    if (!this._mmgIndex || !this._mmgIndex[planNumber]) return;
    const layers = this._mmgIndex[planNumber];
    for (const l of layers) {
      const key = `${planNumber}/${l.name}`;
      if (!this._mmgLayers.has(key)) {
        await this.toggleMMGLayer(planNumber, l.name, l.file, l.name_heb || l.name);
      }
    }
  }

  removeAllMMGLayers() {
    for (const [key, info] of this._mmgLayers) {
      if (this.map.hasLayer(info.layer)) this.map.removeLayer(info.layer);
    }
    this._mmgLayers.clear();
    this.showToast('כל שכבות המ"מ"ג הוסרו', 'info');
    this.renderLayers();
  }

  toggleMMGLayerVisibility(key) {
    const info = this._mmgLayers.get(key);
    if (!info) return;
    if (this.map.hasLayer(info.layer)) {
      this.map.removeLayer(info.layer);
    } else {
      info.layer.addTo(this.map);
    }
    this.renderLayers();
  }

  removeMMGLayerByKey(key) {
    const info = this._mmgLayers.get(key);
    if (!info) return;
    if (this.map.hasLayer(info.layer)) this.map.removeLayer(info.layer);
    this._mmgLayers.delete(key);
    this.renderLayers();
  }

  /* ── Toggle All / Category Layers ── */
  async toggleAllLayers(turnOn) {
    // Base layers
    if (turnOn) {
      if (this.tabaLayer && !this.map.hasLayer(this.tabaLayer)) this.tabaLayer.addTo(this.map);
      if (this.cadastreLayer && !this.map.hasLayer(this.cadastreLayer)) this.cadastreLayer.addTo(this.map);
      if (!this._migrashOn) { await this.loadMigrashLayer(); this._migrashOn = true; }
      if (this._parcelsLayer && !this.map.hasLayer(this._parcelsLayer)) {
        this._parcelsLayer.addTo(this.map);
        if (this._parcelLabelsLayer) this._parcelLabelsLayer.addTo(this.map);
        this._parcelsOn = true;
      }
    } else {
      if (this.tabaLayer && this.map.hasLayer(this.tabaLayer)) this.map.removeLayer(this.tabaLayer);
      if (this.cadastreLayer && this.map.hasLayer(this.cadastreLayer)) this.map.removeLayer(this.cadastreLayer);
      if (this._migrashOn) {
        if (this._migrashLabelsLayer) { this.map.removeLayer(this._migrashLabelsLayer); this._migrashLabelsLayer = null; }
        if (this._migrashLayer) { this.map.removeLayer(this._migrashLayer); this._migrashLayer = null; }
        this._migrashOn = false;
      }
      if (this._parcelsLayer && this.map.hasLayer(this._parcelsLayer)) {
        this.map.removeLayer(this._parcelsLayer);
        if (this._parcelLabelsLayer) this.map.removeLayer(this._parcelLabelsLayer);
        this._parcelsOn = false;
      }
    }

    // GIS layers
    const cats = this.data?.layer_categories || {};
    for (const [cat, layers] of Object.entries(cats)) {
      for (const l of layers) {
        const isActive = this.activeLayers.has(l.file);
        if (turnOn && !isActive) {
          await this.toggleLayer(l.file);
        } else if (!turnOn && isActive) {
          this.map.removeLayer(this.activeLayers.get(l.file));
          this.activeLayers.delete(l.file);
          delete this.layerStyles[l.file];
        }
      }
    }
    this._colorPaletteOpen = null;
    this.updateLayerCount();
    this.renderLayers();
  }

  async toggleCategoryLayers(cat, turnOn) {
    const cats = this.data?.layer_categories || {};
    const layers = cats[cat];
    if (!layers) return;

    for (const l of layers) {
      const isActive = this.activeLayers.has(l.file);
      if (turnOn && !isActive) {
        await this.toggleLayer(l.file);
      } else if (!turnOn && isActive) {
        this.map.removeLayer(this.activeLayers.get(l.file));
        this.activeLayers.delete(l.file);
        delete this.layerStyles[l.file];
      }
    }
    this._colorPaletteOpen = null;
    this.updateLayerCount();
    this.renderLayers();
  }

  async toggleLayer(file, itemEl) {
    if (this.activeLayers.has(file)) {
      this.map.removeLayer(this.activeLayers.get(file));
      this.activeLayers.delete(file);
      delete this.layerStyles[file];
    } else {
      try {
        const res = await fetch('/data/gis_layers/' + file);
        const geo = await res.json();
        const COLORS = ['#ef4444','#8b5cf6','#06b6d4','#10b981','#f97316','#ec4899','#6366f1','#14b8a6'];
        const color = COLORS[this.activeLayers.size % COLORS.length];
        const opacity = 0.12;
        this.layerStyles[file] = { color, opacity, weight: 2 };
        const layer = L.geoJSON(geo, {
          coordsToLatLng: itmToLatLng,
          style: { color, weight: 2, fillOpacity: opacity, fillColor: color },
          pointToLayer: (f, ll) => L.circleMarker(ll, { radius: 5, fillColor: color, color, weight: 1, fillOpacity: Math.min(opacity + 0.5, 1) }),
          onEachFeature: (f, layer) => {
            const p = f.properties || {};
            const hebTitle = layerHeb(file.replace('.geojson',''));
            const rows = Object.entries(p).slice(0, 8).map(([k,v]) => `<div class="popup-row"><span class="k">${k}</span><span>${v}</span></div>`).join('');
            layer.bindPopup(`<div class="popup-title">${hebTitle}</div>${rows}`);
          }
        }).addTo(this.map);
        this.activeLayers.set(file, layer);
      } catch(e) { console.error('Layer load error:', e); }
    }
    this._colorPaletteOpen = null;
    this.updateLayerCount();
    this.renderLayers();
  }

  toggleBase(type) {
    if (type === 'taba') {
      if (this.tabaLayer && this.map.hasLayer(this.tabaLayer)) {
        this.map.removeLayer(this.tabaLayer);
      } else if (this.tabaLayer) {
        this.tabaLayer.addTo(this.map);
      }
    } else {
      if (this.cadastreLayer && this.map.hasLayer(this.cadastreLayer)) {
        this.map.removeLayer(this.cadastreLayer);
      } else if (this.cadastreLayer) {
        this.cadastreLayer.addTo(this.map);
      }
    }
    this.renderLayers();
  }

  toggleColorPalette(key) {
    this._colorPaletteOpen = this._colorPaletteOpen === key ? null : key;
    this.renderLayers();
  }

  changeLayerColor(key, color, isBase) {
    if (!this.layerStyles[key]) this.layerStyles[key] = {};
    this.layerStyles[key].color = color;
    const opacity = this.layerStyles[key].opacity;

    if (isBase) {
      const layer = key === 'taba' ? this.tabaLayer : this.cadastreLayer;
      if (layer) {
        layer.eachLayer(l => {
          if (l.setStyle) l.setStyle({ color, fillColor: color });
        });
      }
    } else {
      const layer = this.activeLayers.get(key);
      if (layer) {
        layer.eachLayer(l => {
          if (l.setStyle) l.setStyle({ color, fillColor: color });
          if (l.setRadius) l.setStyle({ fillColor: color, color });
        });
      }
    }
    this._colorPaletteOpen = null;
    this.renderLayers();
  }

  changeLayerOpacity(key, opacity, isBase) {
    if (!this.layerStyles[key]) this.layerStyles[key] = {};
    this.layerStyles[key].opacity = opacity;

    if (isBase) {
      const layer = key === 'taba' ? this.tabaLayer : this.cadastreLayer;
      if (layer) {
        layer.eachLayer(l => {
          if (l.setStyle) l.setStyle({ fillOpacity: opacity });
        });
      }
    } else {
      const layer = this.activeLayers.get(key);
      if (layer) {
        layer.eachLayer(l => {
          if (l.setStyle) l.setStyle({ fillOpacity: opacity });
        });
      }
    }
  }

  changeLayerWeight(key, weight, isBase) {
    if (!this.layerStyles[key]) this.layerStyles[key] = {};
    this.layerStyles[key].weight = weight;

    if (isBase) {
      const layer = key === 'taba' ? this.tabaLayer : this.cadastreLayer;
      if (layer) {
        layer.eachLayer(l => {
          if (l.setStyle) l.setStyle({ weight });
        });
      }
    } else {
      const layer = this.activeLayers.get(key);
      if (layer) {
        layer.eachLayer(l => {
          if (l.setStyle) l.setStyle({ weight });
        });
      }
    }
  }

  updateLayerCount() {
    const n = this.activeLayers.size;
    document.getElementById('mi-layers').textContent = n + 2; // +2 for base layers
    const badge = document.getElementById('layers-badge');
    if (n > 0) { badge.style.display = 'flex'; badge.textContent = n; }
    else { badge.style.display = 'none'; }
  }

  /* ── Stats ── */
  renderStats() {
    const el = document.getElementById('panel-content');
    if (!this.data) return;
    const s = this.data.stats;
    const srcStats = s.source_statistics || {};
    const ftDist = s.file_type_distribution || {};

    const maxSrc = Math.max(...Object.values(srcStats).map(v => v?.docs || 0), 1);
    const maxFt = Math.max(...Object.values(ftDist), 1);

    const srcLabels = {
      rsPlanDocs: 'מסמכי תכנית',
      rsPlanDocsAdd: 'מסמכים נוספים',
      rsDes: 'תיאורים',
      rsPlanDocsGen: 'מסמכים כלליים',
      rsPubDocs: 'מסמכי פרסום',
      rsMeetingsDocs: 'מסמכי ישיבות'
    };

    el.innerHTML = `
      <div class="stats-grid">
        <div class="stat-card"><div class="stat-val">${(s.total_plans||0).toLocaleString()}</div><div class="stat-lbl">תכניות</div></div>
        <div class="stat-card"><div class="stat-val">${(s.total_blocks||0).toLocaleString()}</div><div class="stat-lbl">גושים</div></div>
        <div class="stat-card"><div class="stat-val">${(s.total_parcels||0).toLocaleString()}</div><div class="stat-lbl">חלקות</div></div>
        <div class="stat-card"><div class="stat-val">${(s.total_documents||0).toLocaleString()}</div><div class="stat-lbl">מסמכים</div></div>
        <div class="stat-card"><div class="stat-val">${(s.total_layers||0).toLocaleString()}</div><div class="stat-lbl">שכבות GIS</div></div>
        <div class="stat-card"><div class="stat-val">${(s.total_cadastre_blocks||0).toLocaleString()}</div><div class="stat-lbl">גושי קדסטר</div></div>
      </div>
      <div class="stats-section">
        <h3>מסמכים לפי מקור</h3>
        ${Object.entries(srcStats).map(([k, v]) => `
          <div class="stat-bar">
            <span class="stat-bar-label">${srcLabels[k] || k}</span>
            <div class="stat-bar-track"><div class="stat-bar-fill" style="width:${((v?.docs||0)/maxSrc*100)}%"></div></div>
            <span class="stat-bar-val">${v?.docs || 0}</span>
          </div>
        `).join('')}
      </div>
      <div class="stats-section">
        <h3>מסמכים לפי סוג קובץ</h3>
        ${Object.entries(ftDist).sort((a,b)=>b[1]-a[1]).slice(0,8).map(([k, v]) => `
          <div class="stat-bar">
            <span class="stat-bar-label">${k.toUpperCase()}</span>
            <div class="stat-bar-track"><div class="stat-bar-fill" style="width:${(v/maxFt*100)}%"></div></div>
            <span class="stat-bar-val">${v}</span>
          </div>
        `).join('')}
      </div>
    `;
  }

  /* ── Complot ── */
  async renderComplot() {
    const el = document.getElementById('panel-content');
    if (!this.data) return;
    const cm = this.data.complot || {};

    const names = {
      GetTabaNumbers: 'מספרי תב"ע',
      GetTabaBuilding: 'בניינים',
      GetTabaStatus: 'סטטוס תכניות',
      GetContactInfo: 'פרטי קשר',
      GetBakashotInMeeting: 'בקשות בישיבה',
    };

    const icons = {
      GetTabaNumbers: 'fa-list-ol',
      GetTabaBuilding: 'fa-building',
      GetTabaStatus: 'fa-tasks',
      GetContactInfo: 'fa-address-card',
      GetBakashotInMeeting: 'fa-gavel',
    };

    el.innerHTML = `
      <div class="complot-cards">
        <div style="padding:0 0 8px;font-size:13px;color:var(--text2)">
          נתוני Complot - מערכת ניהול תכנון ובנייה<br>
          <small>מקור: handasi.complot.co.il</small>
        </div>
        ${Object.entries(cm).map(([k, v]) => `
          <div class="complot-card">
            <i class="fas ${icons[k] || 'fa-database'}"></i>
            <div class="info">
              <div class="title">${names[k] || k}</div>
              <div class="count">${v.toLocaleString()} רשומות</div>
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }

  /* ── Settings ── */
  renderSettings() {
    const el = document.getElementById('panel-content');
    el.innerHTML = `
      <div style="padding:16px">
        <h3 style="margin-bottom:12px;font-size:14px">שכבת רקע מפה</h3>
        <div style="font-size:13px;color:var(--text2);margin-bottom:12px">
          <i class="fas fa-info-circle"></i> ניתן להחליף מפת רקע דרך האייקון <i class="fas fa-layer-group"></i> בפינה הימנית העליונה של המפה
        </div>
        <h3 style="margin:16px 0 8px;font-size:14px">מערכת קואורדינטות</h3>
        <div style="font-size:12px;color:var(--text2);line-height:1.8">
          <div><i class="fas fa-globe" style="color:var(--accent)"></i> נתוני המקור: Israel TM Grid (EPSG:2039)</div>
          <div><i class="fas fa-exchange-alt" style="color:var(--accent)"></i> המרה אוטומטית ל-WGS84 (EPSG:4326) עם proj4js</div>
        </div>
        <h3 style="margin:16px 0 8px;font-size:14px">מידע</h3>
        <div style="font-size:12px;color:var(--text2);line-height:1.8">
          <div>פרויקט: גושים חלקות כפר חב"ד</div>
          <div>נתונים: iPlan, MAVAT, קדסטר, Complot, CBS, data.gov.il</div>
          <div>סה"כ: ~1.8 GB נתונים</div>
        </div>
      </div>
    `;
  }

  /* ── Advanced Search ── */
  renderAdvancedSearch() {
    this._searchMode = this._searchMode || 'parcel';
    const el = document.getElementById('panel-content');

    const tabs = `<div class="search-tabs">
      <button class="search-tab${this._searchMode==='parcel'?' active':''}" onclick="app.setSearchMode('parcel')">
        <i class="fas fa-th"></i> גוש / חלקה
      </button>
      <button class="search-tab${this._searchMode==='plan'?' active':''}" onclick="app.setSearchMode('plan')">
        <i class="fas fa-map"></i> תב"ע / מגרש
      </button>
      <button class="search-tab${this._searchMode==='address'?' active':''}" onclick="app.setSearchMode('address')">
        <i class="fas fa-map-marker-alt"></i> כתובת
      </button>
    </div>`;

    let form = '';
    if (this._searchMode === 'parcel') {
      form = `<div class="search-form">
        <div class="field"><label>מספר גוש</label><input type="number" id="s-gush" placeholder="לדוגמה: 6256" value="${this._sGush||''}" onkeydown="if(event.key==='Enter')app.searchParcel()"></div>
        <div class="field"><label>מספר חלקה (אופציונלי)</label><input type="number" id="s-helka" placeholder="לדוגמה: 43" value="${this._sHelka||''}" onkeydown="if(event.key==='Enter')app.searchParcel()"></div>
        <button class="search-btn" onclick="app.searchParcel()"><i class="fas fa-search"></i> חפש גוש / חלקה</button>
      </div>`;
    } else if (this._searchMode === 'plan') {
      form = `<div class="search-form">
        <div class="field"><label>מספר תב"ע או שם תכנית</label><input type="text" id="s-plan" placeholder='לדוגמה: 425-0117390 או "כפר חב"ד"' value="${this._sPlan||''}" onkeydown="if(event.key==='Enter')app.searchPlan()"></div>
        <div class="field"><label>מספר מגרש (אופציונלי)</label><input type="text" id="s-migrash" placeholder="לדוגמה: 100" value="${this._sMigrash||''}" onkeydown="if(event.key==='Enter')app.searchPlan()"></div>
        <button class="search-btn" onclick="app.searchPlan()"><i class="fas fa-search"></i> חפש תב"ע / מגרש</button>
      </div>`;
    } else {
      form = `<div class="search-form">
        <div class="field"><label>כתובת</label><input type="text" id="s-address" placeholder='לדוגמה: כפר חב"ד, רחוב הרב שניאורסון' value="${this._sAddress||''}" onkeydown="if(event.key==='Enter')app.searchAddress()"></div>
        <button class="search-btn" onclick="app.searchAddress()"><i class="fas fa-search"></i> חפש כתובת</button>
        <div style="margin-top:8px;font-size:11px;color:var(--text2)"><i class="fas fa-info-circle"></i> חיפוש כתובת באמצעות OpenStreetMap Nominatim</div>
      </div>`;
    }

    const results = this._searchResults || '';
    const historyHtml = this._renderSearchHistory();
    el.innerHTML = tabs + form + historyHtml + '<div id="search-results">' + results + '</div>';
  }

  _renderSearchHistory() {
    const favs = this._searchFavorites;
    const recents = this._searchHistory.slice(0, 10);
    if (!favs.length && !recents.length) return '';
    let html = '';
    if (favs.length) {
      html += `<div class="search-history-section open">
        <div class="search-history-header open" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <span><i class="fas fa-star" style="color:#f59e0b"></i> מועדפים (${favs.length})</span>
          <i class="fas fa-chevron-left toggle"></i>
        </div>
        <div class="search-history-items">
          ${favs.map((s, i) => this._renderHistoryItem(s, i, true)).join('')}
        </div>
      </div>`;
    }
    if (recents.length) {
      html += `<div class="search-history-section${favs.length ? '' : ' open'}">
        <div class="search-history-header${favs.length ? '' : ' open'}" onclick="this.parentElement.classList.toggle('open');this.classList.toggle('open')">
          <span><i class="fas fa-history"></i> חיפושים אחרונים (${recents.length})</span>
          <i class="fas fa-chevron-left toggle"></i>
        </div>
        <div class="search-history-items">
          ${recents.map((s, i) => this._renderHistoryItem(s, i, false)).join('')}
          <div class="search-history-clear" onclick="app.clearSearchHistory()"><i class="fas fa-trash-alt"></i> נקה היסטוריה</div>
        </div>
      </div>`;
    }
    return html;
  }

  _renderHistoryItem(entry, idx, isFav) {
    const iconMap = { parcel: 'fas fa-th', plan: 'fas fa-map', address: 'fas fa-map-marker-alt' };
    const icon = iconMap[entry.type] || 'fas fa-search';
    const isFavorited = this._searchFavorites.some(f => f.key === entry.key);
    const starClass = isFavorited ? 'starred' : '';
    return `<div class="search-history-item" onclick="app.replaySearch(${isFav ? "'fav'," + idx : "'hist'," + idx})">
      <div class="sh-icon ${entry.type}">
        <i class="${icon}"></i>
      </div>
      <span class="sh-label">${entry.label}</span>
      <span class="sh-star ${starClass}" onclick="event.stopPropagation();app.toggleSearchFavorite('${entry.key}')" title="${isFavorited ? 'הסר ממועדפים' : 'הוסף למועדפים'}">
        <i class="fas fa-star"></i>
      </span>
      ${isFav ? `<span class="sh-delete" onclick="event.stopPropagation();app.removeSearchFavorite(${idx})" title="הסר"><i class="fas fa-times"></i></span>` : ''}
    </div>`;
  }

  _addToSearchHistory(type, params, label) {
    const key = type + ':' + JSON.stringify(params);
    const entry = { type, params, label, key, ts: Date.now() };
    // Remove duplicate
    this._searchHistory = this._searchHistory.filter(h => h.key !== key);
    // Add to front
    this._searchHistory.unshift(entry);
    // Keep last 20
    this._searchHistory = this._searchHistory.slice(0, 20);
    localStorage.setItem('searchHistory', JSON.stringify(this._searchHistory));
  }

  toggleSearchFavorite(key) {
    const idx = this._searchFavorites.findIndex(f => f.key === key);
    if (idx >= 0) {
      this._searchFavorites.splice(idx, 1);
    } else {
      const entry = this._searchHistory.find(h => h.key === key) ||
                    this._searchFavorites.find(f => f.key === key);
      if (entry) this._searchFavorites.push({ ...entry });
    }
    localStorage.setItem('searchFavorites', JSON.stringify(this._searchFavorites));
    this.renderAdvancedSearch();
  }

  removeSearchFavorite(idx) {
    this._searchFavorites.splice(idx, 1);
    localStorage.setItem('searchFavorites', JSON.stringify(this._searchFavorites));
    this.renderAdvancedSearch();
  }

  clearSearchHistory() {
    this._searchHistory = [];
    localStorage.setItem('searchHistory', '[]');
    this.renderAdvancedSearch();
  }

  replaySearch(source, idx) {
    const entry = source === 'fav' ? this._searchFavorites[idx] : this._searchHistory[idx];
    if (!entry) return;
    this._searchMode = entry.type;
    if (entry.type === 'parcel') {
      this._sGush = entry.params.gush || '';
      this._sHelka = entry.params.helka || '';
      this.renderAdvancedSearch();
      setTimeout(() => this.searchParcel(), 50);
    } else if (entry.type === 'plan') {
      this._sPlan = entry.params.plan || '';
      this._sMigrash = entry.params.migrash || '';
      this.renderAdvancedSearch();
      setTimeout(() => this.searchPlan(), 50);
    } else if (entry.type === 'address') {
      this._sAddress = entry.params.address || '';
      this.renderAdvancedSearch();
      setTimeout(() => this.searchAddress(), 50);
    }
  }

  setSearchMode(mode) {
    this._searchMode = mode;
    this._searchResults = '';
    this.renderAdvancedSearch();
  }

  /* ── Parcel Search ── */
  async searchParcel() {
    const gush = document.getElementById('s-gush')?.value?.trim();
    const helka = document.getElementById('s-helka')?.value?.trim();
    this._sGush = gush; this._sHelka = helka;
    if (!gush) { this._searchResults = '<div class="empty"><i class="fas fa-info-circle"></i><p>יש להזין מספר גוש</p></div>'; this.renderAdvancedSearch(); return; }

    document.getElementById('search-results').innerHTML = '<div class="search-loading"><i class="fas fa-spinner fa-spin"></i> מחפש...</div>';
    try {
      const url = `/api/search/parcel?gush=${encodeURIComponent(gush)}${helka ? '&helka='+encodeURIComponent(helka) : ''}`;
      const res = await fetch(url);
      const data = await res.json();

      // Save to history
      const histLabel = helka ? `גוש ${gush} חלקה ${helka}` : `גוש ${gush}`;
      this._addToSearchHistory('parcel', { gush, helka }, histLabel);

      if (!data.found) {
        this._searchResults = `<div class="empty"><i class="fas fa-search"></i><p>${data.message || 'לא נמצא'}</p></div>`;
      } else if (data.helkot) {
        // Got a list of helkot for this gush
        const blockPlans = this.data?.blocks?.find(b => b.id === parseInt(gush));
        const favKey = 'parcel:' + JSON.stringify({gush, helka: ''});
        const isFav = this._searchFavorites.some(f => f.key === favKey);
        this._searchResults = `
          <div class="search-result" onclick="app.selectBlock(${gush})">
            <div class="search-result-head">
              <div class="search-result-icon parcel-icon"><i class="fas fa-th"></i></div>
              <div class="search-result-body">
                <div class="search-result-title">גוש ${gush}
                  <button class="search-fav-btn ${isFav?'starred':''}" onclick="event.stopPropagation();app.toggleSearchFavorite('${favKey}')" title="${isFav?'הסר ממועדפים':'הוסף למועדפים'}"><i class="fas fa-star"></i></button>
                </div>
                <div class="search-result-sub">
                  <span><i class="fas fa-puzzle-piece"></i> ${data.count} חלקות</span>
                  ${blockPlans ? `<span><i class="fas fa-file-alt"></i> ${blockPlans.plans_count} תכניות</span>` : ''}
                </div>
              </div>
            </div>
            <div class="search-result-actions">
              <button onclick="event.stopPropagation();app.selectBlock(${gush})"><i class="fas fa-crosshairs"></i> מרכז במפה</button>
            </div>
          </div>
          <div style="padding:10px 16px;font-size:12px;font-weight:600;color:var(--text2)">חלקות בגוש (לחץ לבחירה):</div>
          <div class="helka-list">${data.helkot.map(h => `<span class="helka-chip" onclick="app.searchParcelDirect(${gush},${h})">${h}</span>`).join('')}</div>`;
        // ── Auto-zoom to gush on map ──
        this.selectBlock(parseInt(gush));
      } else {
        // Got a specific parcel - use ITM coords for exact client-side conversion
        const itmX = data.itm_x || 0;
        const itmY = data.itm_y || 0;
        const favKey2 = 'parcel:' + JSON.stringify({gush: String(data.gush), helka: String(data.helka)});
        const isFav2 = this._searchFavorites.some(f => f.key === favKey2);
        this._searchResults = `
          <div class="search-result" onclick="app.zoomToParcel(${itmX},${itmY},${data.gush},${data.helka})">
            <div class="search-result-head">
              <div class="search-result-icon parcel-icon"><i class="fas fa-vector-square"></i></div>
              <div class="search-result-body">
                <div class="search-result-title">גוש ${data.gush} חלקה ${data.helka}
                  <button class="search-fav-btn ${isFav2?'starred':''}" onclick="event.stopPropagation();app.toggleSearchFavorite('${favKey2}')" title="${isFav2?'הסר ממועדפים':'הוסף למועדפים'}"><i class="fas fa-star"></i></button>
                </div>
                <div class="search-result-sub">
                  ${data.area ? `<span><i class="fas fa-ruler-combined"></i> ${data.area.toLocaleString()} מ"ר</span>` : ''}
                  ${data.status ? `<span><i class="fas fa-info-circle"></i> ${data.status}</span>` : ''}
                  ${data.locality ? `<span><i class="fas fa-map-marker-alt"></i> ${data.locality}</span>` : ''}
                  ${data.migrash ? `<span style="color:#10b981"><i class="fas fa-home"></i> מגרש ${data.migrash}</span>` : ''}
                  ${data.yeud ? `<span><i class="fas fa-tag"></i> ${data.yeud}</span>` : ''}
                  ${data.migrash_plan ? `<span><i class="fas fa-file-alt"></i> ${data.migrash_plan}</span>` : ''}
                  ${data.shetach_sqm ? `<span><i class="fas fa-ruler"></i> שטח מגרש: ${Number(data.shetach_sqm).toLocaleString()} מ"ר</span>` : ''}
                </div>
              </div>
            </div>
            <div class="search-result-actions">
              <button onclick="event.stopPropagation();app.zoomToParcel(${itmX},${itmY},${data.gush},${data.helka})"><i class="fas fa-crosshairs"></i> הצג במפה</button>
              <button onclick="event.stopPropagation();app.showBlockPlans(${data.gush})"><i class="fas fa-file-alt"></i> תכניות בגוש</button>
              <button onclick="event.stopPropagation();window.open('https://sdan.complot.co.il/gush2/#gush/${data.gush}/${data.helka}','_blank')"><i class="fas fa-external-link-alt"></i> קומפלוט</button>
            </div>
          </div>`;
        // ── Auto-zoom and highlight parcel on map ──
        this.zoomToParcel(itmX, itmY, data.gush, data.helka);
        this.highlightParcelOnMap(data.gush, data.helka);
      }
    } catch(e) {
      this._searchResults = '<div class="empty"><i class="fas fa-exclamation-triangle"></i><p>שגיאה בחיפוש</p></div>';
    }
    this.renderAdvancedSearch();
  }

  searchParcelDirect(gush, helka) {
    this._sGush = String(gush);
    this._sHelka = String(helka);
    // Update DOM inputs so searchParcel reads correct values
    const gi = document.getElementById('s-gush');
    const hi = document.getElementById('s-helka');
    if (gi) gi.value = this._sGush;
    if (hi) hi.value = this._sHelka;
    this.searchParcel();
  }

  zoomToParcel(itmXorLat, itmYorLng, gush, helka) {
    if (!itmXorLat || !itmYorLng) return;
    // If ITM coordinates (large values), convert client-side with same proj4js
    let lat, lng;
    if (itmXorLat > 1000 && itmYorLng > 1000) {
      const [cLng, cLat] = proj4('EPSG:2039', 'EPSG:4326', [itmXorLat, itmYorLng]);
      lat = cLat;
      lng = cLng;
    } else {
      lat = itmXorLat;
      lng = itmYorLng;
    }
    this.map.setView([lat, lng], 18);
    // Add/update marker
    if (this._searchMarker) this.map.removeLayer(this._searchMarker);
    this._searchMarker = L.marker([lat, lng]).addTo(this.map)
      .bindPopup(`<div class="popup-title">גוש ${gush} חלקה ${helka}</div>`)
      .openPopup();
    // Highlight block
    if (this.cadastreLayer) {
      this.cadastreLayer.eachLayer(layer => {
        const g = layer.feature?.properties?.GUSH_NUM;
        if (g && Math.round(g) === gush) {
          layer.setStyle({ color: '#ef4444', weight: 3, fillOpacity: 0.15, fillColor: '#ef4444', dashArray: null });
        } else {
          layer.setStyle({ color: '#f59e0b', weight: 1.5, fillOpacity: 0.03, fillColor: '#f59e0b', dashArray: '5,5' });
        }
      });
    }
  }

  showBlockPlans(gush) {
    this.switchPanel('data');
    this.currentTab = 'blocks';
    document.querySelectorAll('#data-tabs .tab').forEach(t => t.classList.toggle('active', t.dataset.tab === 'blocks'));
    this.selectBlock(gush);
  }

  /* ── Plan Search ── */
  async searchPlan() {
    const plan = document.getElementById('s-plan')?.value?.trim();
    const migrash = document.getElementById('s-migrash')?.value?.trim();
    this._sPlan = plan; this._sMigrash = migrash;
    if (!plan) { this._searchResults = '<div class="empty"><i class="fas fa-info-circle"></i><p>יש להזין מספר או שם תכנית</p></div>'; this.renderAdvancedSearch(); return; }

    document.getElementById('search-results').innerHTML = '<div class="search-loading"><i class="fas fa-spinner fa-spin"></i> מחפש...</div>';
    this._addToSearchHistory('plan', { plan, migrash }, plan);
    try {
      const res = await fetch(`/api/search/plan?q=${encodeURIComponent(plan)}`);
      const results = await res.json();

      if (!results.length) {
        this._searchResults = '<div class="empty"><i class="fas fa-search"></i><p>לא נמצאו תכניות</p></div>';
      } else {
        this._searchResults = `<div style="padding:10px 16px;font-size:12px;color:var(--text2)">${results.length} תכניות נמצאו</div>` +
          results.map(p => {
            const blocks = (p.blocks || []).map(b => `גוש ${b.block}`).join(', ');
            const parcelsInfo = (p.blocks || []).filter(b => b.parcels || b.parcels_partial).map(b => {
              let txt = `גוש ${b.block}: `;
              if (b.parcels) txt += `חלקות ${b.parcels}`;
              if (b.parcels_partial) txt += `${b.parcels ? ', ' : ''}חלקי ${b.parcels_partial}`;
              return txt;
            }).join(' | ');
            const hasGeo = p.lat && p.lng;
            return `<div class="search-result"${hasGeo ? ` onclick="app.zoomToPlan(${p.lat},${p.lng},'${(p.number||'').replace(/'/g,"\\'")}'"` : ''}>
              <div class="search-result-head">
                <div class="search-result-icon plan-icon"><i class="fas fa-map"></i></div>
                <div class="search-result-body">
                  <div class="search-result-title">${p.number || ''}</div>
                  <div style="font-size:12px;color:var(--text);margin-top:2px">${p.name || ''}</div>
                  <div class="search-result-sub">
                    ${p.status ? `<span><i class="fas fa-flag"></i> ${p.status}</span>` : ''}
                    ${p.area_dunam ? `<span><i class="fas fa-ruler-combined"></i> ${p.area_dunam} דונם</span>` : ''}
                    ${p.entity ? `<span><i class="fas fa-landmark"></i> ${p.entity}</span>` : ''}
                  </div>
                  ${blocks ? `<div style="font-size:11px;color:var(--text2);margin-top:4px"><i class="fas fa-th" style="font-size:10px"></i> ${blocks}</div>` : ''}
                  ${parcelsInfo ? `<div style="font-size:11px;color:var(--text2);margin-top:2px"><i class="fas fa-puzzle-piece" style="font-size:10px"></i> ${parcelsInfo}</div>` : ''}
                  ${p.landuse ? `<div style="font-size:11px;color:var(--text2);margin-top:2px"><i class="fas fa-building" style="font-size:10px"></i> ${p.landuse}</div>` : ''}
                </div>
              </div>
              <div class="search-result-actions">
                ${hasGeo ? `<button onclick="event.stopPropagation();app.zoomToPlan(${p.lat},${p.lng},'${(p.number||'').replace(/'/g,"\\'")}')"><i class="fas fa-crosshairs"></i> הצג במפה</button>` : ''}
                <button onclick="event.stopPropagation();app.expandPlan('${(p.number||'').replace(/'/g,"\\'")}')"><i class="fas fa-file-alt"></i> מסמכים</button>
                ${hasGeo ? `<button class="add-layer-btn${this._planLayers.has(p.number) ? ' added' : ''}" onclick="event.stopPropagation();app.togglePlanLayer('${(p.number||'').replace(/'/g,"\\'")}')"><i class="fas fa-layer-group"></i> ${this._planLayers.has(p.number) ? 'הסר שכבה' : 'הוסף כשכבה'}</button>` : ''}
                ${this._mmgIndex && this._mmgIndex[p.number] ? `<button class="add-layer-btn" onclick="event.stopPropagation();app.showMMGLayers('${(p.number||'').replace(/'/g,"\\'")}')" style="background:#8b5cf6"><i class="fas fa-drafting-compass"></i> מ"מ"ג (${this._mmgIndex[p.number].length})</button>` : ''}
              </div>
            </div>`;
          }).join('');
      }
    } catch(e) {
      this._searchResults = '<div class="empty"><i class="fas fa-exclamation-triangle"></i><p>שגיאה בחיפוש</p></div>';
    }
    this.renderAdvancedSearch();
  }

  zoomToPlan(lat, lng, number) {
    if (!lat || !lng) return;
    this.map.setView([lat, lng], 16);
    if (this._searchMarker) this.map.removeLayer(this._searchMarker);
    this._searchMarker = L.marker([lat, lng]).addTo(this.map)
      .bindPopup(`<div class="popup-title">${number}</div>`)
      .openPopup();
    // Highlight plan polygon in taba layer
    if (this.tabaLayer) {
      this.tabaLayer.eachLayer(layer => {
        const pn = layer.feature?.properties?.pl_number;
        if (pn === number) {
          layer.setStyle({ color: '#ef4444', weight: 3, fillOpacity: 0.2, fillColor: '#ef4444' });
          layer.openPopup();
        } else {
          layer.setStyle({ color: '#3b82f6', weight: 2, fillOpacity: 0.08, fillColor: '#3b82f6' });
        }
      });
    }
  }

  /* ── Toast Notifications ── */
  showToast(msg, type = 'info') {
    const colors = { success: '#10b981', warning: '#f59e0b', info: '#3b82f6', error: '#ef4444' };
    const icons = { success: 'fa-check-circle', warning: 'fa-exclamation-triangle', info: 'fa-info-circle', error: 'fa-times-circle' };
    const toast = document.createElement('div');
    toast.style.cssText = `position:fixed;bottom:24px;left:50%;transform:translateX(-50%);background:${colors[type]||colors.info};color:#fff;padding:10px 20px;border-radius:8px;font-size:13px;font-weight:600;z-index:10000;box-shadow:0 4px 12px rgba(0,0,0,0.3);display:flex;align-items:center;gap:8px;transition:opacity 0.3s`;
    toast.innerHTML = `<i class="fas ${icons[type]||icons.info}"></i> ${msg}`;
    document.body.appendChild(toast);
    setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 300); }, 2500);
  }

  /* ── Address Search ── */
  async searchAddress() {
    const address = document.getElementById('s-address')?.value?.trim();
    this._sAddress = address;
    if (!address) { this._searchResults = '<div class="empty"><i class="fas fa-info-circle"></i><p>יש להזין כתובת</p></div>'; this.renderAdvancedSearch(); return; }

    document.getElementById('search-results').innerHTML = '<div class="search-loading"><i class="fas fa-spinner fa-spin"></i> מחפש כתובת...</div>';
    this._addToSearchHistory('address', { address }, address);
    try {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&countrycodes=il&limit=8&accept-language=he`;
      const res = await fetch(url);
      const results = await res.json();

      if (!results.length) {
        this._searchResults = '<div class="empty"><i class="fas fa-search"></i><p>הכתובת לא נמצאה. נסה להוסיף "כפר חב\'ד" או "ישראל"</p></div>';
      } else {
        this._searchResults = `<div style="padding:10px 16px;font-size:12px;color:var(--text2)">${results.length} תוצאות</div>` +
          results.map(r => `
            <div class="search-result" onclick="app.zoomToAddress(${r.lat},${r.lon},'${(r.display_name||'').replace(/'/g,"\\'").substring(0,60)}')">
              <div class="search-result-head">
                <div class="search-result-icon address-icon"><i class="fas fa-map-marker-alt"></i></div>
                <div class="search-result-body">
                  <div class="search-result-title">${r.display_name?.split(',')[0] || ''}</div>
                  <div class="search-result-sub">
                    <span style="font-size:11px;max-width:100%;overflow:hidden;text-overflow:ellipsis">${r.display_name || ''}</span>
                  </div>
                </div>
              </div>
              <div class="search-result-actions">
                <button onclick="event.stopPropagation();app.zoomToAddress(${r.lat},${r.lon},'${(r.display_name||'').replace(/'/g,"\\'").substring(0,60)}')"><i class="fas fa-crosshairs"></i> הצג במפה</button>
              </div>
            </div>
          `).join('');
      }
    } catch(e) {
      this._searchResults = '<div class="empty"><i class="fas fa-exclamation-triangle"></i><p>שגיאה בחיפוש כתובת</p></div>';
    }
    this.renderAdvancedSearch();
  }

  zoomToAddress(lat, lng, label) {
    this.map.setView([lat, lng], 17);
    if (this._searchMarker) this.map.removeLayer(this._searchMarker);
    this._searchMarker = L.marker([lat, lng]).addTo(this.map)
      .bindPopup(`<div class="popup-title">${label}</div>`)
      .openPopup();
  }

  /* ── Search ── */
  onSearch(query) {
    this.searchQuery = query;
    this.docPage = 0;
    if (this.currentPanel === 'layers') {
      this.renderLayers();
    } else if (this.currentPanel === 'data') {
      this.renderTab();
    }
  }

  /* ── Sidebar Toggle ── */
  toggleSidebar() {
    const sb = document.getElementById('sidebar');
    sb.style.display = sb.style.display === 'none' ? 'flex' : 'none';
    setTimeout(() => this.map.invalidateSize(), 300);
  }

  /* ── DRAWING TOOLS ── */
  toggleDrawMode() {
    this._drawMode = !this._drawMode;
    const tb = document.getElementById('draw-toolbar');
    const btn = document.getElementById('draw-mode-btn');
    if (this._drawMode) {
      tb.classList.add('visible');
      btn.classList.add('active');
      // Turn off other tools
      if (this._measureMode) this.clearMeasure();
      if (this._coordPinMode) { this._coordPinMode = false; document.getElementById('coord-pin-btn')?.classList.remove('active'); const ov = document.getElementById('coord-pin-overlay'); if (ov) ov.style.display = 'none'; }
      if (!this._drawTool) this.setDrawTool('polyline');
    } else {
      tb.classList.remove('visible');
      btn.classList.remove('active');
      this._cancelDrawing();
      this.map.getContainer().style.cursor = '';
      document.getElementById('draw-props').style.display = 'none';
    }
  }

  setDrawTool(tool) {
    this._cancelDrawing();
    this._drawTool = tool;
    document.querySelectorAll('.draw-tb-btn[id^="dt-"]').forEach(b => b.classList.remove('active'));
    const el = document.getElementById('dt-' + tool);
    if (el) el.classList.add('active');
    this.map.getContainer().style.cursor = 'crosshair';
    if (tool === 'text') {
      this.map.getContainer().style.cursor = 'text';
    }
  }

  toggleSnap() {
    this._drawSnap = !this._drawSnap;
    document.getElementById('dt-snap')?.classList.toggle('active', this._drawSnap);
  }

  /* ── Snap Engine ── */
  _findSnapPoint(latlng) {
    if (!this._drawSnap) return null;
    const px = this.map.latLngToContainerPoint(latlng);
    let best = null, bestDist = this._snapDistance;

    // Collect all visible GeoJSON layers' vertices
    const check = (ll) => {
      const p = this.map.latLngToContainerPoint(ll);
      const d = Math.sqrt((p.x - px.x) ** 2 + (p.y - px.y) ** 2);
      if (d < bestDist) { bestDist = d; best = ll; }
    };

    // Check all layers on map
    this.map.eachLayer(layer => {
      if (layer instanceof L.Polyline && !(layer instanceof L.Rectangle)) {
        const lls = layer.getLatLngs();
        const flat = Array.isArray(lls[0]) ? lls.flat(2) : lls;
        flat.forEach(ll => { if (ll.lat !== undefined) check(ll); });
      } else if (layer instanceof L.CircleMarker || layer instanceof L.Marker) {
        check(layer.getLatLng());
      }
    });

    // Also check drawing temp points
    this._drawPoints.forEach(ll => check(ll));

    return best;
  }

  _showSnapIndicator(latlng) {
    const ind = document.getElementById('snap-indicator');
    if (!latlng) { ind.classList.remove('visible'); return; }
    const px = this.map.latLngToContainerPoint(latlng);
    const rect = this.map.getContainer().getBoundingClientRect();
    ind.style.left = px.x + 'px';
    ind.style.top = px.y + 'px';
    ind.classList.add('visible');
  }

  /* ── Draw Event Handlers ── */
  _onDrawClick(e) {
    if (!this._drawMode || !this._drawTool) return;
    let latlng = e.latlng;
    const snapped = this._findSnapPoint(latlng);
    if (snapped) latlng = snapped;

    const tool = this._drawTool;

    if (tool === 'marker') {
      this._placeDrawMarker(latlng);
      return;
    }
    if (tool === 'text') {
      this._placeDrawText(latlng);
      return;
    }
    if (tool === 'circle') {
      if (!this._drawCircleCenter) {
        this._drawCircleCenter = latlng;
        const cm = L.circleMarker(latlng, { radius: 4, color: this._drawColor, fillColor: this._drawColor, fillOpacity: 1, weight: 2 }).addTo(this.map);
        this._drawTempLayers.push(cm);
      } else {
        const r = this._drawCircleCenter.distanceTo(latlng);
        this._commitCircle(this._drawCircleCenter, r);
        this._cancelDrawing();
      }
      return;
    }
    if (tool === 'rectangle') {
      if (!this._drawRectStart) {
        this._drawRectStart = latlng;
        const cm = L.circleMarker(latlng, { radius: 4, color: this._drawColor, fillColor: this._drawColor, fillOpacity: 1, weight: 2 }).addTo(this.map);
        this._drawTempLayers.push(cm);
      } else {
        this._commitRectangle(this._drawRectStart, latlng);
        this._cancelDrawing();
      }
      return;
    }

    // polyline / polygon
    this._drawPoints.push(latlng);
    const cm = L.circleMarker(latlng, { radius: 4, color: this._drawColor, fillColor: '#fff', fillOpacity: 1, weight: 2 }).addTo(this.map);
    this._drawTempLayers.push(cm);

    if (this._drawPoints.length > 1) {
      const line = L.polyline([this._drawPoints[this._drawPoints.length - 2], latlng], {
        color: this._drawColor, weight: this._drawWeight, dashArray: '6,4'
      }).addTo(this.map);
      this._drawTempLayers.push(line);
    }
  }

  _onDrawMove(e) {
    if (!this._drawMode || !this._drawTool) return;
    const latlng = e.latlng;
    const snapped = this._findSnapPoint(latlng);
    this._showSnapIndicator(snapped);

    // Draw preview line/circle/rectangle
    if (this._drawPreview) { this.map.removeLayer(this._drawPreview); this._drawPreview = null; }

    const tool = this._drawTool;
    if ((tool === 'polyline' || tool === 'polygon') && this._drawPoints.length > 0) {
      const last = this._drawPoints[this._drawPoints.length - 1];
      const target = snapped || latlng;
      this._drawPreview = L.polyline([last, target], {
        color: this._drawColor, weight: this._drawWeight, dashArray: '4,4', opacity: 0.5
      }).addTo(this.map);
    }
    if (tool === 'circle' && this._drawCircleCenter) {
      const target = snapped || latlng;
      const r = this._drawCircleCenter.distanceTo(target);
      this._drawPreview = L.circle(this._drawCircleCenter, {
        radius: r, color: this._drawColor, weight: this._drawWeight,
        fillColor: this._drawColor, fillOpacity: 0.1, dashArray: '6,4'
      }).addTo(this.map);
    }
    if (tool === 'rectangle' && this._drawRectStart) {
      const target = snapped || latlng;
      this._drawPreview = L.rectangle([this._drawRectStart, target], {
        color: this._drawColor, weight: this._drawWeight,
        fillColor: this._drawColor, fillOpacity: 0.1, dashArray: '6,4'
      }).addTo(this.map);
    }
  }

  _onDrawDblClick(e) {
    if (!this._drawMode) return;
    L.DomEvent.stop(e);
    if (this._drawPoints.length >= 2) {
      this._finishDrawShape();
    }
  }

  _finishDrawShape() {
    if (this._drawPoints.length < 2) return;
    const tool = this._drawTool;
    if (tool === 'polyline') {
      this._commitPolyline([...this._drawPoints]);
    } else if (tool === 'polygon' && this._drawPoints.length >= 3) {
      this._commitPolygon([...this._drawPoints]);
    }
    this._cancelDrawing();
  }

  _cancelDrawing() {
    this._drawTempLayers.forEach(l => this.map.removeLayer(l));
    this._drawTempLayers = [];
    this._drawPoints = [];
    this._drawRectStart = null;
    this._drawCircleCenter = null;
    if (this._drawPreview) { this.map.removeLayer(this._drawPreview); this._drawPreview = null; }
    this._showSnapIndicator(null);
  }

  /* ── Commit Drawing Shapes ── */
  _commitPolyline(points) {
    const id = ++this._drawIdCounter;
    const layer = L.polyline(points, {
      color: this._drawColor, weight: this._drawWeight, opacity: 0.9
    }).addTo(this.map);
    // Calculate length
    let dist = 0;
    for (let i = 1; i < points.length; i++) dist += points[i - 1].distanceTo(points[i]);
    const label = dist > 1000 ? (dist / 1000).toFixed(2) + ' ק"מ' : Math.round(dist) + ' מ\'';
    layer.bindPopup(`<b>קו #${id}</b><br>אורך: ${label}<br><button class="coord-delete-btn" onclick="app.deleteDrawItem(${id})"><i class="fas fa-trash"></i> מחק</button>`);
    const item = { id, type: 'polyline', layer, latlngs: points, props: { color: this._drawColor, weight: this._drawWeight, length: dist } };
    this._drawItems.push(item);
    this.renderLayers();
  }

  _commitPolygon(points) {
    const id = ++this._drawIdCounter;
    const layer = L.polygon(points, {
      color: this._drawColor, weight: this._drawWeight,
      fillColor: this._drawColor, fillOpacity: this._drawFillOpacity
    }).addTo(this.map);
    // Calculate area
    const projected = points.map(p => proj4('EPSG:4326', 'EPSG:2039', [p.lng, p.lat]));
    let area = 0;
    for (let i = 0; i < projected.length; i++) {
      const j = (i + 1) % projected.length;
      area += projected[i][0] * projected[j][1];
      area -= projected[j][0] * projected[i][1];
    }
    area = Math.abs(area) / 2;
    const label = area > 10000 ? (area / 10000).toFixed(2) + ' דונם' : Math.round(area) + ' מ"ר';
    layer.bindPopup(`<b>פוליגון #${id}</b><br>שטח: ${label}<br><button class="coord-delete-btn" onclick="app.deleteDrawItem(${id})"><i class="fas fa-trash"></i> מחק</button>`);
    const item = { id, type: 'polygon', layer, latlngs: points, props: { color: this._drawColor, weight: this._drawWeight, area } };
    this._drawItems.push(item);
    this.renderLayers();
  }

  _commitCircle(center, radius) {
    const id = ++this._drawIdCounter;
    const layer = L.circle(center, {
      radius, color: this._drawColor, weight: this._drawWeight,
      fillColor: this._drawColor, fillOpacity: this._drawFillOpacity
    }).addTo(this.map);
    const rLabel = radius > 1000 ? (radius / 1000).toFixed(2) + ' ק"מ' : Math.round(radius) + ' מ\'';
    const area = Math.PI * radius * radius;
    const aLabel = area > 10000 ? (area / 10000).toFixed(2) + ' דונם' : Math.round(area) + ' מ"ר';
    layer.bindPopup(`<b>עיגול #${id}</b><br>רדיוס: ${rLabel}<br>שטח: ${aLabel}<br><button class="coord-delete-btn" onclick="app.deleteDrawItem(${id})"><i class="fas fa-trash"></i> מחק</button>`);
    const item = { id, type: 'circle', layer, latlngs: [center], props: { color: this._drawColor, radius, area } };
    this._drawItems.push(item);
    this.renderLayers();
  }

  _commitRectangle(corner1, corner2) {
    const id = ++this._drawIdCounter;
    const bounds = L.latLngBounds(corner1, corner2);
    const layer = L.rectangle(bounds, {
      color: this._drawColor, weight: this._drawWeight,
      fillColor: this._drawColor, fillOpacity: this._drawFillOpacity
    }).addTo(this.map);
    const sw = bounds.getSouthWest(), ne = bounds.getNorthEast();
    const pSw = proj4('EPSG:4326', 'EPSG:2039', [sw.lng, sw.lat]);
    const pNe = proj4('EPSG:4326', 'EPSG:2039', [ne.lng, ne.lat]);
    const w = Math.abs(pNe[0] - pSw[0]), h = Math.abs(pNe[1] - pSw[1]);
    const area = w * h;
    const aLabel = area > 10000 ? (area / 10000).toFixed(2) + ' דונם' : Math.round(area) + ' מ"ר';
    layer.bindPopup(`<b>מלבן #${id}</b><br>${Math.round(w)}×${Math.round(h)} מ'<br>שטח: ${aLabel}<br><button class="coord-delete-btn" onclick="app.deleteDrawItem(${id})"><i class="fas fa-trash"></i> מחק</button>`);
    const item = { id, type: 'rectangle', layer, latlngs: [corner1, corner2], props: { color: this._drawColor, area } };
    this._drawItems.push(item);
    this.renderLayers();
  }

  _placeDrawMarker(latlng) {
    const id = ++this._drawIdCounter;
    const ICONS = ['fa-map-marker-alt', 'fa-flag', 'fa-star', 'fa-exclamation-triangle', 'fa-home', 'fa-building', 'fa-tree', 'fa-parking'];
    const iconCls = ICONS[id % ICONS.length];
    const icon = L.divIcon({
      className: '',
      html: `<i class="fas ${iconCls}" style="color:${this._drawColor};font-size:24px;text-shadow:0 1px 3px rgba(0,0,0,.4)"></i>`,
      iconSize: [24, 24], iconAnchor: [12, 24], popupAnchor: [0, -24]
    });
    const marker = L.marker(latlng, { icon, draggable: true }).addTo(this.map);
    const itm = proj4('EPSG:4326', 'EPSG:2039', [latlng.lng, latlng.lat]);
    marker.bindPopup(`<b>סימן #${id}</b><br>WGS84: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}<br>ITM: ${itm[0].toFixed(1)}, ${itm[1].toFixed(1)}<br><button class="coord-delete-btn" onclick="app.deleteDrawItem(${id})"><i class="fas fa-trash"></i> מחק</button>`);
    const item = { id, type: 'marker', layer: marker, latlngs: [latlng], props: { color: this._drawColor, icon: iconCls } };
    this._drawItems.push(item);
    this.renderLayers();
  }

  _placeDrawText(latlng) {
    const text = prompt('הכנס טקסט:');
    if (!text) return;
    const id = ++this._drawIdCounter;
    const icon = L.divIcon({
      className: 'draw-shape-label',
      html: text,
      iconSize: null, iconAnchor: [0, 0]
    });
    const marker = L.marker(latlng, { icon, draggable: true }).addTo(this.map);
    marker.bindPopup(`<b>טקסט #${id}</b><br>"${text}"<br><button class="coord-delete-btn" onclick="app.deleteDrawItem(${id})"><i class="fas fa-trash"></i> מחק</button>`);
    const item = { id, type: 'text', layer: marker, latlngs: [latlng], props: { text, color: this._drawColor } };
    this._drawItems.push(item);
    this.renderLayers();
  }

  /* ── Drawing Management ── */
  deleteDrawItem(id) {
    const idx = this._drawItems.findIndex(i => i.id === id);
    if (idx === -1) return;
    this.map.removeLayer(this._drawItems[idx].layer);
    this._drawItems.splice(idx, 1);
    this.renderLayers();
  }

  undoLastDraw() {
    if (this._drawPoints.length > 0) {
      // Remove last point from current drawing
      this._drawPoints.pop();
      if (this._drawTempLayers.length > 0) {
        const last = this._drawTempLayers.pop();
        this.map.removeLayer(last);
      }
      if (this._drawTempLayers.length > 0 && this._drawPoints.length > 0) {
        const last = this._drawTempLayers.pop();
        this.map.removeLayer(last);
      }
      return;
    }
    // Remove last committed shape
    if (this._drawItems.length > 0) {
      const item = this._drawItems.pop();
      this.map.removeLayer(item.layer);
      this.renderLayers();
    }
  }

  clearAllDrawings() {
    if (this._drawItems.length === 0) return;
    if (!confirm('למחוק את כל הציורים?')) return;
    this._drawItems.forEach(i => this.map.removeLayer(i.layer));
    this._drawItems = [];
    this._cancelDrawing();
    this.renderLayers();
  }

  toggleDrawItemVisibility(id) {
    const item = this._drawItems.find(i => i.id === id);
    if (!item) return;
    if (this.map.hasLayer(item.layer)) this.map.removeLayer(item.layer);
    else item.layer.addTo(this.map);
    this.renderLayers();
  }

  zoomToDrawItem(id) {
    const item = this._drawItems.find(i => i.id === id);
    if (!item) return;
    if (item.layer.getBounds) {
      this.map.fitBounds(item.layer.getBounds(), { padding: [40, 40], maxZoom: 19 });
    } else if (item.layer.getLatLng) {
      this.map.setView(item.layer.getLatLng(), 18);
    }
  }

  /* ── IMAGE OVERLAY (Place image on map, drag/scale/rotate) ── */
  triggerImageOverlay() {
    document.getElementById('img-overlay-input').click();
  }

  handleImageOverlayUpload(input) {
    const file = input.files[0];
    if (!file) return;
    input.value = '';
    const reader = new FileReader();
    reader.onload = (ev) => this._addImageOverlay(ev.target.result, file.name);
    reader.readAsDataURL(file);
  }

  _addImageOverlay(dataUrl, name) {
    const id = ++this._imageOverlayIdCounter;
    const center = this.map.getCenter();
    const viewBounds = this.map.getBounds();
    const latSpan = (viewBounds.getNorth() - viewBounds.getSouth()) * 0.3;
    const lngSpan = (viewBounds.getEast() - viewBounds.getWest()) * 0.3;
    const sw = L.latLng(center.lat - latSpan / 2, center.lng - lngSpan / 2);
    const ne = L.latLng(center.lat + latSpan / 2, center.lng + lngSpan / 2);
    const bounds = L.latLngBounds(sw, ne);

    const overlay = L.imageOverlay(dataUrl, bounds, {
      opacity: 0.7, interactive: true, zIndex: 650
    }).addTo(this.map);

    const info = {
      overlay, bounds, rotation: 0, locked: false,
      name: name || `תמונה ${id}`, opacity: 0.7, markers: []
    };
    this._imageOverlays.set(id, info);
    this._activeImageOverlayId = id;

    // Wait for image element to render, then set up handles & drag
    overlay.on('load', () => {
      this._createImageHandles(id);
      this._setupImageDrag(id);
      this._showImageOverlayCtrl(id);
    });
    // Fallback if already loaded
    setTimeout(() => {
      if (info.markers.length === 0) {
        this._createImageHandles(id);
        this._setupImageDrag(id);
        this._showImageOverlayCtrl(id);
      }
    }, 300);
    this.renderLayers();
  }

  _createImageHandles(id) {
    const info = this._imageOverlays.get(id);
    if (!info) return;
    info.markers.forEach(m => this.map.removeLayer(m));
    info.markers = [];

    const bounds = info.overlay.getBounds();
    const sw = bounds.getSouthWest(), ne = bounds.getNorthEast();
    const nw = L.latLng(ne.lat, sw.lng), se = L.latLng(sw.lat, ne.lng);

    [{pos:nw,cls:'corner-nw',idx:0},{pos:ne,cls:'corner-ne',idx:1},{pos:se,cls:'corner-se',idx:2},{pos:sw,cls:'corner-sw',idx:3}].forEach(c => {
      const icon = L.divIcon({ className: `img-overlay-handle ${c.cls}`, iconSize: [14,14], iconAnchor: [7,7] });
      const marker = L.marker(c.pos, { icon, draggable: !info.locked, zIndexOffset: 2000 }).addTo(this.map);
      marker._cornerIdx = c.idx;
      marker.on('drag', () => this._onCornerDrag(id, marker));
      marker.on('dragend', () => this._updateHandlePositions(id));
      info.markers.push(marker);
    });

    // Rotate handle above top edge
    const rotPos = L.latLng(ne.lat + (ne.lat - sw.lat) * 0.08, (sw.lng + ne.lng) / 2);
    const rotIcon = L.divIcon({ className: 'img-overlay-handle rotate', iconSize: [12,12], iconAnchor: [6,6] });
    const rotMarker = L.marker(rotPos, { icon: rotIcon, draggable: !info.locked, zIndexOffset: 2100 }).addTo(this.map);
    rotMarker._isRotate = true;
    rotMarker.on('drag', () => this._onRotateDrag(id, rotMarker));
    rotMarker.on('dragend', () => this._updateHandlePositions(id));
    info.markers.push(rotMarker);
  }

  _onCornerDrag(id, marker) {
    const info = this._imageOverlays.get(id);
    if (!info || info.locked) return;
    const idx = marker._cornerIdx, p = marker.getLatLng();
    const b = info.overlay.getBounds(), sw = b.getSouthWest(), ne = b.getNorthEast();
    let newSw, newNe;
    if (idx === 0) { newSw = L.latLng(sw.lat, p.lng); newNe = L.latLng(p.lat, ne.lng); }
    else if (idx === 1) { newSw = sw; newNe = p; }
    else if (idx === 2) { newSw = L.latLng(p.lat, sw.lng); newNe = L.latLng(ne.lat, p.lng); }
    else { newSw = p; newNe = ne; }
    const nb = L.latLngBounds(newSw, newNe);
    info.overlay.setBounds(nb);
    info.bounds = nb;
    this._updateHandlePositions(id);
  }

  _onRotateDrag(id, rotMarker) {
    const info = this._imageOverlays.get(id);
    if (!info || info.locked) return;
    const center = info.overlay.getBounds().getCenter();
    const rp = rotMarker.getLatLng();
    const deg = Math.atan2(rp.lng - center.lng, rp.lat - center.lat) * 180 / Math.PI;
    info.rotation = deg;
    const el = info.overlay.getElement();
    if (el) { el.style.transformOrigin = 'center center'; el.style.transform = `rotate(${deg}deg)`; }
  }

  _updateHandlePositions(id) {
    const info = this._imageOverlays.get(id);
    if (!info) return;
    const b = info.overlay.getBounds(), sw = b.getSouthWest(), ne = b.getNorthEast();
    const positions = [L.latLng(ne.lat, sw.lng), ne, L.latLng(sw.lat, ne.lng), sw];
    info.markers.forEach(m => {
      if (m._isRotate) m.setLatLng(L.latLng(ne.lat + (ne.lat - sw.lat) * 0.08, (sw.lng + ne.lng) / 2));
      else if (m._cornerIdx !== undefined) m.setLatLng(positions[m._cornerIdx]);
    });
  }

  _setupImageDrag(id) {
    const info = this._imageOverlays.get(id);
    if (!info) return;
    const el = info.overlay.getElement();
    if (!el) { setTimeout(() => this._setupImageDrag(id), 100); return; }
    el.style.cursor = 'move';
    el.classList.add('leaflet-image-overlay-active');

    el.addEventListener('mousedown', (e) => {
      if (info.locked) return;
      if (e.shiftKey) { this._startShiftRotate(id, e); return; }
      e.stopPropagation(); e.preventDefault();
      this.map.dragging.disable();
      const startLL = this.map.mouseEventToLatLng(e);
      const startBounds = L.latLngBounds(info.overlay.getBounds().getSouthWest(), info.overlay.getBounds().getNorthEast());
      const onMove = (e2) => {
        const cur = this.map.mouseEventToLatLng(e2);
        const dlat = cur.lat - startLL.lat, dlng = cur.lng - startLL.lng;
        const nb = L.latLngBounds(
          L.latLng(startBounds.getSouthWest().lat + dlat, startBounds.getSouthWest().lng + dlng),
          L.latLng(startBounds.getNorthEast().lat + dlat, startBounds.getNorthEast().lng + dlng)
        );
        info.overlay.setBounds(nb); info.bounds = nb;
        this._updateHandlePositions(id);
      };
      const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); this.map.dragging.enable(); };
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });

    el.addEventListener('click', (e) => { e.stopPropagation(); this._activeImageOverlayId = id; this._showImageOverlayCtrl(id); });
  }

  _startShiftRotate(id, e) {
    const info = this._imageOverlays.get(id);
    if (!info) return;
    e.stopPropagation(); e.preventDefault();
    this.map.dragging.disable();
    const centerPx = this.map.latLngToContainerPoint(info.overlay.getBounds().getCenter());
    const startAngle = Math.atan2(e.clientY - centerPx.y, e.clientX - centerPx.x);
    const startRot = info.rotation || 0;
    const onMove = (e2) => {
      const cur = Math.atan2(e2.clientY - centerPx.y, e2.clientX - centerPx.x);
      info.rotation = startRot + (cur - startAngle) * 180 / Math.PI;
      const el = info.overlay.getElement();
      if (el) { el.style.transformOrigin = 'center center'; el.style.transform = `rotate(${info.rotation}deg)`; }
    };
    const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); this.map.dragging.enable(); };
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  }

  _showImageOverlayCtrl(id) {
    const ctrl = document.getElementById('img-overlay-ctrl');
    const info = this._imageOverlays.get(id);
    if (!info) { ctrl.style.display = 'none'; return; }
    ctrl.style.display = 'block';
    this._activeImageOverlayId = id;
    const lockBtn = document.getElementById('img-lock-btn');
    if (info.locked) { lockBtn.innerHTML = '<i class="fas fa-lock"></i> נעול'; lockBtn.classList.add('primary'); }
    else { lockBtn.innerHTML = '<i class="fas fa-lock-open"></i> שחרור'; lockBtn.classList.remove('primary'); }
    const slider = ctrl.querySelector('input[type=range]');
    if (slider) { slider.value = Math.round(info.opacity * 100); slider.nextElementSibling.textContent = Math.round(info.opacity * 100) + '%'; }
    for (const [oid, oinfo] of this._imageOverlays) {
      const el = oinfo.overlay.getElement();
      if (el) el.classList.toggle('leaflet-image-overlay-active', oid === id);
    }
  }

  setImageOverlayOpacity(val) {
    const info = this._imageOverlays.get(this._activeImageOverlayId);
    if (info) { info.opacity = val; info.overlay.setOpacity(val); }
  }

  toggleImageOverlayLock() {
    const info = this._imageOverlays.get(this._activeImageOverlayId);
    if (!info) return;
    info.locked = !info.locked;
    info.markers.forEach(m => { if (info.locked) m.dragging.disable(); else m.dragging.enable(); });
    const el = info.overlay.getElement();
    if (el) el.style.cursor = info.locked ? 'default' : 'move';
    this._showImageOverlayCtrl(this._activeImageOverlayId);
  }

  fitImageOverlay() {
    const info = this._imageOverlays.get(this._activeImageOverlayId);
    if (info) this.map.fitBounds(info.overlay.getBounds(), { padding: [40, 40] });
  }

  resetImageOverlayRotation() {
    const info = this._imageOverlays.get(this._activeImageOverlayId);
    if (!info) return;
    info.rotation = 0;
    const el = info.overlay.getElement();
    if (el) el.style.transform = '';
  }

  removeActiveImageOverlay() {
    const id = this._activeImageOverlayId;
    const info = this._imageOverlays.get(id);
    if (!info) return;
    info.markers.forEach(m => this.map.removeLayer(m));
    this.map.removeLayer(info.overlay);
    this._imageOverlays.delete(id);
    this._activeImageOverlayId = null;
    document.getElementById('img-overlay-ctrl').style.display = 'none';
    this.renderLayers();
  }

  removeAllImageOverlays() {
    for (const [, info] of this._imageOverlays) {
      info.markers.forEach(m => this.map.removeLayer(m));
      this.map.removeLayer(info.overlay);
    }
    this._imageOverlays.clear();
    this._activeImageOverlayId = null;
    document.getElementById('img-overlay-ctrl').style.display = 'none';
    this.renderLayers();
  }

  toggleImageOverlayVisibility(id) {
    const info = this._imageOverlays.get(id);
    if (!info) return;
    if (this.map.hasLayer(info.overlay)) {
      this.map.removeLayer(info.overlay);
      info.markers.forEach(m => this.map.removeLayer(m));
    } else {
      info.overlay.addTo(this.map);
      this._createImageHandles(id);
    }
    this.renderLayers();
  }

  selectImageOverlay(id) {
    this._activeImageOverlayId = id;
    this._showImageOverlayCtrl(id);
  }

  /* ── DXF Upload & Display ── */
  triggerDxfUpload() {
    document.getElementById('dxf-file-input').click();
  }

  async handleDxfUpload(input) {
    const file = input.files[0];
    if (!file) return;
    input.value = ''; // Reset so same file can be re-uploaded

    this._dxfUploading = true;
    this.renderLayers();

    const ext = file.name.split('.').pop().toLowerCase();
    const isDwg = ext === 'dwg';
    const endpoint = isDwg ? '/api/dwg/upload' : '/api/dxf/upload';

    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('crs', 'ITM'); // Default: Israeli TM Grid

      const res = await fetch(endpoint, { method: 'POST', body: formData });
      const geojson = await res.json();

      if (geojson.error) {
        if (geojson.oda_missing) {
          const msg =
            `⚠️ לא ניתן לפתוח DWG — ODA File Converter לא מותקן בשרת.\n\n` +
            `${geojson.instructions}\n\n` +
            `לחלופין: פתח את הקובץ ב-AutoCAD/FreeCAD ושמור כ-DXF ואז העלה מחדש.`;
          alert(msg);
        } else {
          alert(`שגיאה בקריאת ${isDwg ? 'DWG' : 'DXF'}: ` + geojson.error);
        }
        this._dxfUploading = false;
        this.renderLayers();
        return;
      }

      const id = ++this._dxfIdCounter;
      const name = geojson._filename || file.name;
      const COLORS = ['#8b5cf6','#06b6d4','#ef4444','#10b981','#f97316','#ec4899','#6366f1','#14b8a6'];
      const color = COLORS[id % COLORS.length];

      // Determine coordinate conversion
      const isItm = geojson._crs === 'EPSG:2039';

      // Build Leaflet layer
      const layer = L.geoJSON(geojson, {
        coordsToLatLng: isItm ? itmToLatLng : undefined,
        style: (feature) => {
          const p = feature.properties || {};
          return {
            color: color,
            weight: 2,
            fillOpacity: 0.12,
            fillColor: color,
            dashArray: p.type === 'ARC' ? '4,4' : null
          };
        },
        pointToLayer: (feature, latlng) => {
          const p = feature.properties || {};
          if (p.text) {
            return L.marker(latlng, {
              icon: L.divIcon({
                className: 'dxf-text-label',
                html: `<span style="font-size:10px;color:${color};white-space:nowrap;text-shadow:0 0 3px #fff,0 0 3px #fff">${p.text}</span>`,
                iconSize: null,
                iconAnchor: [0, 0]
              })
            });
          }
          return L.circleMarker(latlng, {
            radius: 4, fillColor: color, color, weight: 1.5, fillOpacity: 0.8
          });
        },
        onEachFeature: (feature, layer) => {
          const p = feature.properties || {};
          const rows = Object.entries(p)
            .filter(([k]) => k !== 'sub')
            .map(([k, v]) => `<div class="popup-row"><span class="k">${k}</span><span>${v}</span></div>`)
            .join('');
          layer.bindPopup(`<div class="popup-title">DXF: ${name}</div>${rows}`);
        },
        filter: (feature) => true // Will be used for layer filtering
      }).addTo(this.map);

      // Get DXF layer names from geojson metadata
      const dxfLayerNames = geojson._dxfLayers || [];
      const visibleDxfLayers = new Set(dxfLayerNames);

      this._dxfLayers.set(id, {
        layer,
        name,
        color,
        geojson,
        dxfLayerNames,
        visibleDxfLayers,
        isItm
      });

      // Zoom to the loaded layer
      if (layer.getBounds().isValid()) {
        this.map.fitBounds(layer.getBounds(), { padding: [30, 30] });
      }

      const ec = geojson._entity_counts || {};
      const summary = Object.entries(ec).map(([k, v]) => `${k}: ${v}`).join(', ');
      console.log(`DXF loaded: ${name} — ${geojson._total_features} features (${summary})`);
      if (geojson._errors?.length) console.warn('DXF parse errors:', geojson._errors);

    } catch(e) {
      alert('שגיאה בהעלאת DXF: ' + e.message);
      console.error('DXF upload error:', e);
    }

    this._dxfUploading = false;
    this.updateLayerCount();
    this.renderLayers();
  }

  /* ── SHP/ZIP Upload & Display ── */
  triggerShpUpload() {
    document.getElementById('shp-file-input').click();
  }

  /* ── Planning Data Helpers ── */
  _getPlanningCategory(yeudDesc) {
    if (!yeudDesc) return 'אחר';
    const desc = yeudDesc.trim();
    for (const [cat, cfg] of Object.entries(this._planningCategories)) {
      if (cat === 'אחר') continue;
      for (const kw of cfg.keywords) {
        if (desc.includes(kw)) return cat;
      }
    }
    return 'אחר';
  }

  _isPlanningData(geojson) {
    // Check if this GeoJSON contains planning data by looking for key fields
    const sample = geojson.features?.slice(0, 5) || [];
    return sample.some(f => f.properties && ('YeudDesc' in f.properties || 'TabaYeud' in f.properties));
  }

  _buildPlanningPopup(feature, layerName) {
    const p = feature.properties || {};
    const cat = this._getPlanningCategory(p.YeudDesc);
    const catCfg = this._planningCategories[cat] || this._planningCategories['אחר'];
    
    let html = `<div class="planning-popup">`;
    html += `<div class="planning-popup-header">`;
    html += `<span class="planning-cat-badge" style="background:${catCfg.color}"><i class="fas ${catCfg.icon}"></i> ${cat}</span>`;
    if (p.YeudDesc) html += `<strong>${p.YeudDesc}</strong>`;
    html += `</div>`;

    // Planning information rows
    const fields = [
      { key: 'TabaYeud', label: 'תב"ע ייעוד' },
      { key: 'YeudDesc', label: 'תיאור ייעוד' },
      { key: 'TabaMigra', label: 'תב"ע מגרש' },
      { key: 'Migrash', label: 'מגרש' },
      { key: 'HelkaArea', label: 'שטח (מ"ר)', format: v => `<span class="planning-area-badge">${Number(v).toLocaleString()} מ"ר</span>` },
      { key: 'bikoret', label: 'ביקורת' },
      { key: 'OBJECTID', label: 'מזהה' }
    ];

    for (const f of fields) {
      const v = p[f.key];
      if (v === null || v === undefined || v === '') continue;
      const display = f.format ? f.format(v) : v;
      html += `<div class="popup-row"><span class="k">${f.label}</span><span class="v">${display}</span></div>`;
    }

    // Links
    const linkFields = [
      { key: 'GushHelka', label: 'גוש חלקה', icon: 'fa-external-link-alt' },
      { key: 'ToSite', label: 'אתר', icon: 'fa-globe' }
    ];
    const hasLinks = linkFields.some(lf => p[lf.key] && String(p[lf.key]).startsWith('http'));
    if (hasLinks) {
      html += `<div class="plan-links">`;
      for (const lf of linkFields) {
        if (p[lf.key] && String(p[lf.key]).startsWith('http')) {
          html += `<a href="${p[lf.key]}" target="_blank"><i class="fas ${lf.icon}"></i> ${lf.label}</a>`;
        }
      }
      html += `</div>`;
    }

    // Any remaining properties not already shown
    const shownKeys = new Set([...fields.map(f=>f.key), ...linkFields.map(f=>f.key)]);
    const extra = Object.entries(p).filter(([k,v]) => !shownKeys.has(k) && v !== null && v !== '' && !String(v).startsWith('http'));
    if (extra.length) {
      html += `<div style="margin-top:6px;border-top:1px solid #eee;padding-top:4px">`;
      for (const [k,v] of extra) {
        html += `<div class="popup-row"><span class="k">${k}</span><span class="v">${v}</span></div>`;
      }
      html += `</div>`;
    }

    html += `</div>`;
    return html;
  }

  _createPlanningLayer(geojson, name, id) {
    // Count features per category
    const catCounts = {};
    for (const f of (geojson.features || [])) {
      const cat = this._getPlanningCategory(f.properties?.YeudDesc);
      catCounts[cat] = (catCounts[cat] || 0) + 1;
    }

    const visibleCategories = new Set(Object.keys(catCounts));

    const layer = L.geoJSON(geojson, {
      style: (feature) => {
        const cat = this._getPlanningCategory(feature.properties?.YeudDesc);
        const cfg = this._planningCategories[cat] || this._planningCategories['אחר'];
        return {
          color: cfg.color,
          weight: 1.5,
          fillOpacity: 0.3,
          fillColor: cfg.color
        };
      },
      pointToLayer: (feature, latlng) => {
        const cat = this._getPlanningCategory(feature.properties?.YeudDesc);
        const cfg = this._planningCategories[cat] || this._planningCategories['אחר'];
        return L.circleMarker(latlng, { radius: 5, fillColor: cfg.color, color: cfg.color, weight: 1.5, fillOpacity: 0.8 });
      },
      filter: (feature) => {
        const cat = this._getPlanningCategory(feature.properties?.YeudDesc);
        const info = this._dxfLayers.get(id);
        return info ? info.visibleCategories.has(cat) : true;
      },
      onEachFeature: (feature, lyr) => {
        lyr.bindPopup(this._buildPlanningPopup(feature, name), { maxWidth: 400, className: 'planning-popup-wrapper' });
        
        // Highlight on hover
        lyr.on('mouseover', function() {
          this.setStyle({ weight: 3, fillOpacity: 0.5 });
          if (typeof this.bringToFront === 'function') this.bringToFront();
        });
        lyr.on('mouseout', function() {
          const cat2 = app._getPlanningCategory(feature.properties?.YeudDesc);
          const cfg2 = app._planningCategories[cat2] || app._planningCategories['אחר'];
          this.setStyle({ weight: 1.5, fillOpacity: 0.3 });
        });
      }
    }).addTo(this.map);

    return { layer, catCounts, visibleCategories };
  }

  togglePlanningCategory(dxfId, category) {
    const info = this._dxfLayers.get(dxfId);
    if (!info || !info.isPlanning) return;
    
    if (info.visibleCategories.has(category)) {
      info.visibleCategories.delete(category);
    } else {
      info.visibleCategories.add(category);
    }

    // Rebuild the layer with new filter
    const wasOnMap = this.map.hasLayer(info.layer);
    this.map.removeLayer(info.layer);
    
    const result = this._createPlanningLayer(info.geojson, info.name, dxfId);
    info.layer = result.layer;
    
    if (!wasOnMap) {
      this.map.removeLayer(info.layer);
    }
    
    this.renderLayers();
    this._renderPlanningLegend(dxfId);
  }

  toggleAllPlanningCategories(dxfId, show) {
    const info = this._dxfLayers.get(dxfId);
    if (!info || !info.isPlanning) return;
    
    if (show) {
      for (const cat of Object.keys(info.catCounts)) {
        info.visibleCategories.add(cat);
      }
    } else {
      info.visibleCategories.clear();
    }

    const wasOnMap = this.map.hasLayer(info.layer);
    this.map.removeLayer(info.layer);
    const result = this._createPlanningLayer(info.geojson, info.name, dxfId);
    info.layer = result.layer;
    if (!wasOnMap) this.map.removeLayer(info.layer);

    this.renderLayers();
    this._renderPlanningLegend(dxfId);
  }

  _renderPlanningLegend(dxfId) {
    const info = this._dxfLayers.get(dxfId);
    const existingLegend = document.getElementById(`planning-legend-${dxfId}`);
    
    if (!info || !info.isPlanning || !this.map.hasLayer(info.layer)) {
      if (existingLegend) existingLegend.remove();
      return;
    }
    
    if (!this._planningLegendVisible.get(dxfId)) {
      if (existingLegend) existingLegend.remove();
      return;
    }

    const sortedCats = Object.entries(info.catCounts)
      .sort((a, b) => b[1] - a[1]);

    let html = `<div class="planning-legend" id="planning-legend-${dxfId}">`;
    html += `<div class="planning-legend-title">
      <span><i class="fas fa-palette"></i> מקרא: ${info.name}</span>
      <button onclick="app.togglePlanningLegendVisibility(${dxfId})" title="סגור"><i class="fas fa-times"></i></button>
    </div>`;
    html += `<div style="display:flex;gap:4px;margin-bottom:6px">
      <button onclick="app.toggleAllPlanningCategories(${dxfId},true)" style="flex:1;padding:3px;border:1px solid var(--border);border-radius:4px;background:#fff;cursor:pointer;font-size:11px">הכל</button>
      <button onclick="app.toggleAllPlanningCategories(${dxfId},false)" style="flex:1;padding:3px;border:1px solid var(--border);border-radius:4px;background:#fff;cursor:pointer;font-size:11px">אף אחד</button>
    </div>`;
    
    for (const [cat, count] of sortedCats) {
      const cfg = this._planningCategories[cat] || this._planningCategories['אחר'];
      const isOn = info.visibleCategories.has(cat);
      html += `<div class="planning-legend-item${isOn ? '' : ' off'}" onclick="app.togglePlanningCategory(${dxfId},'${cat}')">
        <div class="planning-legend-swatch" style="background:${cfg.color}"></div>
        <span class="planning-legend-label">${cat}</span>
        <span class="planning-legend-count">${count}</span>
      </div>`;
    }
    html += `</div>`;

    if (existingLegend) {
      existingLegend.outerHTML = html;
    } else {
      this.map.getContainer().insertAdjacentHTML('beforeend', html);
    }
  }

  togglePlanningLegendVisibility(dxfId) {
    const isVisible = this._planningLegendVisible.get(dxfId) || false;
    this._planningLegendVisible.set(dxfId, !isVisible);
    this._renderPlanningLegend(dxfId);
  }

  async handleShpUpload(input) {
    const file = input.files[0];
    if (!file) return;
    input.value = '';

    // Show CRS selection dialog
    const crsChoice = prompt('בחר מערכת קואורדינטות:\n1. רשת ישראל (ITM) - ברירת מחדל\n2. גיאוגרפי (WGS84)\n3. UTM 36N\n4. Web Mercator\n\nהקש מספר (1-4):', '1');
    if (crsChoice === null) return;
    const crsMap = {'1': 'ITM', '2': 'WGS84', '3': 'UTM', '4': 'WEBMERCATOR'};
    const selectedCrs = crsMap[crsChoice.trim()] || 'ITM';

    this._dxfUploading = true;
    this.renderLayers();

    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('crs', selectedCrs);

      const res = await fetch('/api/shp/upload', { method: 'POST', body: formData });
      const geojson = await res.json();

      if (geojson.error) {
        alert('שגיאה בקריאת Shapefile: ' + geojson.error);
        this._dxfUploading = false;
        this.renderLayers();
        return;
      }

      const id = ++this._dxfIdCounter;
      const name = geojson._layer_name || geojson._filename || file.name;
      const savedName = geojson._saved_path ? geojson._saved_path.replace('data/uploads/', '').replace('.geojson', '') : null;
      
      this._addShpLayer(geojson, name, id, savedName);
      if (savedName) await this.refreshSavedLayersList();
      console.log(`SHP loaded: ${name} — ${geojson._total_features || geojson.features?.length || 0} features`);

    } catch(e) {
      alert('שגיאה בהעלאת Shapefile: ' + e.message);
      console.error('SHP upload error:', e);
    }

    this._dxfUploading = false;
    this.updateLayerCount();
    this.renderLayers();
  }

  _addShpLayer(geojson, name, id, savedName = null, fitMap = true) {
    const isPlanning = this._isPlanningData(geojson);
    
    if (isPlanning) {
      const result = this._createPlanningLayer(geojson, name, id);
      
      this._dxfLayers.set(id, {
        layer: result.layer,
        name,
        color: '#4caf50',
        geojson,
        dxfLayerNames: [],
        visibleDxfLayers: new Set(),
        isItm: false,
        isShp: true,
        isPlanning: true,
        catCounts: result.catCounts,
        visibleCategories: result.visibleCategories,
        savedName
      });

      this._planningLegendVisible.set(id, true);
      setTimeout(() => this._renderPlanningLegend(id), 100);

    } else {
      const COLORS = ['#8b5cf6','#06b6d4','#ef4444','#10b981','#f97316','#ec4899','#6366f1','#14b8a6'];
      const color = COLORS[id % COLORS.length];

      const layer = L.geoJSON(geojson, {
        style: { color, weight: 2, fillOpacity: 0.15, fillColor: color },
        pointToLayer: (feature, latlng) => L.circleMarker(latlng, { radius: 5, fillColor: color, color, weight: 1.5, fillOpacity: 0.8 }),
        onEachFeature: (feature, lyr) => {
          const p = feature.properties || {};
          const rows = Object.entries(p)
            .filter(([k,v]) => v !== null && v !== '' && !String(v).startsWith('http'))
            .map(([k,v]) => `<div class="popup-row"><span class="k">${k}</span><span>${v}</span></div>`).join('');
          const links = Object.entries(p)
            .filter(([k,v]) => String(v).startsWith('http'))
            .map(([k,v]) => `<div class="popup-row"><a href="${v}" target="_blank">${k}</a></div>`).join('');
          lyr.bindPopup(`<div class="popup-title">${name}</div>${rows}${links}`, {maxWidth: 350});
        }
      }).addTo(this.map);

      this._dxfLayers.set(id, {
        layer, name, color, geojson,
        dxfLayerNames: [], visibleDxfLayers: new Set(),
        isItm: false, isShp: true, isPlanning: false,
        savedName
      });
    }

    const info = this._dxfLayers.get(id);
    if (fitMap && info && info.layer.getBounds().isValid()) {
      this.map.fitBounds(info.layer.getBounds(), { padding: [30, 30] });
    }
  }

  async autoLoadSavedLayers() {
    try {
      const res = await fetch('/api/uploads/list');
      const files = await res.json();
      if (!files.length) return;
      for (const file of files) {
        const sName = file.name;
        // Skip if already loaded
        const alreadyLoaded = [...this._dxfLayers.values()].some(i => i.savedName === sName);
        if (alreadyLoaded) continue;
        try {
          const geoRes = await fetch(`/${file.path}`);
          const geojson = await geoRes.json();
          if (geojson.error || !geojson.features) continue;
          const id = ++this._dxfIdCounter;
          this._addShpLayer(geojson, sName, id, sName, false);
        } catch(e) { console.warn('Auto-load failed for', sName, e); }
      }
      this._savedLayersList = files; // cache for panel
      this.updateLayerCount();
      this.renderLayers();
    } catch(e) { console.warn('autoLoadSavedLayers error:', e); }
  }

  async loadSavedLayer(name) {
    // Load a single saved layer by its stem name
    const alreadyLoaded = [...this._dxfLayers.values()].some(i => i.savedName === name);
    if (alreadyLoaded) { alert('שכבה זו כבר טעונה'); return; }
    try {
      this._dxfUploading = true;
      this.renderLayers();
      const safe = name.replace(/[^\w\-.]/g, '_');
      const geoRes = await fetch(`/data/uploads/${safe}.geojson`);
      const geojson = await geoRes.json();
      const id = ++this._dxfIdCounter;
      this._addShpLayer(geojson, name, id, name);
      this._dxfUploading = false;
      this.updateLayerCount();
      this.renderLayers();
    } catch(e) {
      alert('שגיאה בטעינת שכבה: ' + e.message);
      this._dxfUploading = false;
      this.renderLayers();
    }
  }

  async deleteUploadedFile(name) {
    if (!confirm(`למחוק לצמיתות את הקובץ "${name}" מהשרת?`)) return;
    try {
      const safe = name.replace(/[^\w\-.]/g, '_');
      await fetch('/api/uploads/delete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: safe })
      });
      // Remove from map if loaded
      for (const [fid, info] of this._dxfLayers) {
        if (info.savedName === name) {
          if (this.map.hasLayer(info.layer)) this.map.removeLayer(info.layer);
          this._dxfLayers.delete(fid);
          break;
        }
      }
      this._savedLayersList = (this._savedLayersList || []).filter(f => f.name !== name);
      this.updateLayerCount();
      this.renderLayers();
    } catch(e) { alert('שגיאה במחיקה: ' + e.message); }
  }

  async refreshSavedLayersList() {
    try {
      const res = await fetch('/api/uploads/list');
      this._savedLayersList = await res.json();
      this.renderLayers();
    } catch(e) { console.warn('refreshSavedLayersList error:', e); }
  }

  async loadSavedLayers() {
    await this.refreshSavedLayersList();
    this.renderLayers();
  }

  /* ── SHP/DXF Layer Style Controls ── */
  toggleShpStylePanel(dxfId) {
    if (this._dxfStyleOpen.has(dxfId)) {
      this._dxfStyleOpen.delete(dxfId);
    } else {
      this._dxfStyleOpen.add(dxfId);
    }
    this.renderLayers();
  }

  _ensureShpStyle(dxfId) {
    const info = this._dxfLayers.get(dxfId);
    if (!info) return null;
    if (!info.style) {
      info.style = {
        fillColor: info.color || '#8b5cf6',
        fillOpacity: info.isPlanning ? 0.3 : 0.15,
        borderColor: info.color || '#8b5cf6',
        borderOpacity: 1,
        borderWeight: info.isPlanning ? 1.5 : 2
      };
    }
    return info;
  }

  _applyShpStyle(dxfId) {
    const info = this._dxfLayers.get(dxfId);
    if (!info || !info.style) return;
    const st = info.style;
    
    if (info.isPlanning) {
      // For planning layers, override all features with user style (ignoring category colors)
      info.layer.eachLayer(l => {
        if (l.setStyle) {
          l.setStyle({
            fillColor: st.fillColor,
            fillOpacity: st.fillOpacity,
            color: st.borderColor,
            opacity: st.borderOpacity,
            weight: st.borderWeight
          });
        }
      });
      info._userStyleOverride = true;
    } else {
      info.layer.eachLayer(l => {
        if (l.setStyle) {
          l.setStyle({
            fillColor: st.fillColor,
            fillOpacity: st.fillOpacity,
            color: st.borderColor,
            opacity: st.borderOpacity,
            weight: st.borderWeight
          });
        }
      });
    }
  }

  changeShpFillColor(dxfId, color) {
    const info = this._ensureShpStyle(dxfId);
    if (!info) return;
    info.style.fillColor = color;
    info.color = color; // Update the main color reference too
    this._applyShpStyle(dxfId);
  }

  changeShpFillOpacity(dxfId, opacity) {
    const info = this._ensureShpStyle(dxfId);
    if (!info) return;
    info.style.fillOpacity = opacity;
    this._applyShpStyle(dxfId);
  }

  changeShpBorderColor(dxfId, color) {
    const info = this._ensureShpStyle(dxfId);
    if (!info) return;
    info.style.borderColor = color;
    this._applyShpStyle(dxfId);
  }

  changeShpBorderOpacity(dxfId, opacity) {
    const info = this._ensureShpStyle(dxfId);
    if (!info) return;
    info.style.borderOpacity = opacity;
    this._applyShpStyle(dxfId);
  }

  changeShpBorderWeight(dxfId, weight) {
    const info = this._ensureShpStyle(dxfId);
    if (!info) return;
    info.style.borderWeight = weight;
    this._applyShpStyle(dxfId);
  }

  toggleDxfLayerVisibility(dxfId) {
    const info = this._dxfLayers.get(dxfId);
    if (!info) return;
    if (this.map.hasLayer(info.layer)) {
      this.map.removeLayer(info.layer);
    } else {
      info.layer.addTo(this.map);
    }
    // Update planning legend
    if (info.isPlanning) this._renderPlanningLegend(dxfId);
    this.updateLayerCount();
    this.renderLayers();
  }

  removeDxfLayer(dxfId) {
    const info = this._dxfLayers.get(dxfId);
    if (!info) return;
    this.map.removeLayer(info.layer);
    // Clean up planning legend
    if (info.isPlanning) {
      this._planningLegendVisible.delete(dxfId);
      const legend = document.getElementById(`planning-legend-${dxfId}`);
      if (legend) legend.remove();
    }
    this._dxfLayers.delete(dxfId);
    this.updateLayerCount();
    this.renderLayers();
  }

  removeAllDxfLayers() {
    for (const [dxfId, info] of this._dxfLayers) {
      this.map.removeLayer(info.layer);
      if (info.isPlanning) {
        const legend = document.getElementById(`planning-legend-${dxfId}`);
        if (legend) legend.remove();
      }
    }
    this._dxfLayers.clear();
    this._planningLegendVisible.clear();
    this.updateLayerCount();
    this.renderLayers();
  }

  toggleDxfSubLayer(dxfId, dxfLayerName) {
    const info = this._dxfLayers.get(dxfId);
    if (!info) return;

    if (info.visibleDxfLayers.has(dxfLayerName)) {
      info.visibleDxfLayers.delete(dxfLayerName);
    } else {
      info.visibleDxfLayers.add(dxfLayerName);
    }

    // Rebuild the Leaflet layer with filters
    this.map.removeLayer(info.layer);
    const visible = info.visibleDxfLayers;
    const newLayer = L.geoJSON(info.geojson, {
      coordsToLatLng: info.isItm ? itmToLatLng : undefined,
      style: () => ({
        color: info.color,
        weight: 2,
        fillOpacity: 0.12,
        fillColor: info.color
      }),
      pointToLayer: (feature, latlng) => {
        const p = feature.properties || {};
        if (p.text) {
          return L.marker(latlng, {
            icon: L.divIcon({
              className: 'dxf-text-label',
              html: `<span style="font-size:10px;color:${info.color};white-space:nowrap;text-shadow:0 0 3px #fff,0 0 3px #fff">${p.text}</span>`,
              iconSize: null,
              iconAnchor: [0, 0]
            })
          });
        }
        return L.circleMarker(latlng, {
          radius: 4, fillColor: info.color, color: info.color, weight: 1.5, fillOpacity: 0.8
        });
      },
      onEachFeature: (feature, layer) => {
        const p = feature.properties || {};
        const rows = Object.entries(p)
          .filter(([k]) => k !== 'sub')
          .map(([k, v]) => `<div class="popup-row"><span class="k">${k}</span><span>${v}</span></div>`)
          .join('');
        layer.bindPopup(`<div class="popup-title">DXF: ${info.name}</div>${rows}`);
      },
      filter: (feature) => visible.has(feature.properties?.layer || '')
    }).addTo(this.map);

    info.layer = newLayer;
    this.renderLayers();
  }

  /* ── Advanced Measurement Dialog ── */
  toggleMeasureDialog() {
    this._measureDialogOpen = !this._measureDialogOpen;
    const dlg = document.getElementById('measure-dialog');
    if (dlg) dlg.classList.toggle('visible', this._measureDialogOpen);
    document.getElementById('measure-dialog-btn')?.classList.toggle('active', this._measureDialogOpen);
    if (!this._measureDialogOpen) {
      this._cancelMeasureTool();
    }
    this._renderMeasureList();
  }

  closeMeasureDialog() {
    this._measureDialogOpen = false;
    document.getElementById('measure-dialog')?.classList.remove('visible');
    document.getElementById('measure-dialog-btn')?.classList.remove('active');
    this._cancelMeasureTool();
  }

  setMeasureTool(tool) {
    // Turn off existing modes
    if (this._drawMode) {
      this._drawMode = false;
      this._cancelDrawing();
      document.getElementById('draw-toolbar')?.classList.remove('visible');
      document.getElementById('draw-mode-btn')?.classList.remove('active');
    }
    if (this._coordPinMode) {
      this._coordPinMode = false;
      document.getElementById('coord-pin-btn')?.classList.remove('active');
    }
    if (this._measureMode) this.clearMeasure();

    if (this._measureToolActive === tool) {
      this._cancelMeasureTool();
      return;
    }

    this._cancelMeasureTool();
    this._measureToolActive = tool;
    this.map.getContainer().style.cursor = 'crosshair';

    // Highlight active tool button
    ['mt-line','mt-area','mt-dimension','mt-sketch'].forEach(id => {
      document.getElementById(id)?.classList.remove('active');
    });
    const btnId = { line:'mt-line', area:'mt-area', dimension:'mt-dimension', sketch:'mt-sketch' }[tool];
    document.getElementById(btnId)?.classList.add('active');

    if (tool === 'sketch') {
      this._sketchPhase = 'polygon';
      this._sketchPoints = [];
    }
  }

  _cancelMeasureTool() {
    this._measureToolActive = null;
    this._dimPoints = [];
    this._sketchPhase = null;
    this._sketchPoints = [];
    this._sketchTempLayers.forEach(l => this.map.removeLayer(l));
    this._sketchTempLayers = [];
    this.map.getContainer().style.cursor = '';
    ['mt-line','mt-area','mt-dimension','mt-sketch'].forEach(id => {
      document.getElementById(id)?.classList.remove('active');
    });
    const tooltip = document.getElementById('measure-tooltip');
    if (tooltip) tooltip.style.display = 'none';
  }

  _onAdvancedMeasureClick(e) {
    if (!this._measureToolActive) return;
    let latlng = e.latlng;
    if (this._drawSnap) {
      const snap = this._findSnapPoint(latlng);
      if (snap) latlng = snap;
    }

    if (this._measureToolActive === 'line') {
      this._onMeasureLineClick(latlng);
    } else if (this._measureToolActive === 'area') {
      this._onMeasureAreaClick(latlng);
    } else if (this._measureToolActive === 'dimension') {
      this._onDimensionClick(latlng);
    } else if (this._measureToolActive === 'sketch') {
      this._onSketchClick(latlng);
    }
  }

  _onAdvancedMeasureMove(e) {
    if (!this._measureToolActive) return;
    if (this._drawSnap) {
      const snap = this._findSnapPoint(e.latlng);
      if (snap) this._showSnapIndicator(snap); else this._showSnapIndicator(null);
    }
    const tooltip = document.getElementById('measure-tooltip');
    
    if (this._measureToolActive === 'line' && this._measurePoints.length > 0) {
      const last = this._measurePoints[this._measurePoints.length - 1];
      const d = last.distanceTo(e.latlng);
      const lbl = d > 1000 ? (d/1000).toFixed(1) + ' ק"מ' : Math.round(d) + ' מ\'';
      tooltip.style.display = 'block';
      const pt = this.map.latLngToContainerPoint(e.latlng);
      tooltip.style.left = (pt.x + 15) + 'px';
      tooltip.style.top = (pt.y - 10) + 'px';
      tooltip.textContent = lbl;
    } else if (this._measureToolActive === 'dimension' && this._dimPoints.length === 1) {
      const d = this._dimPoints[0].distanceTo(e.latlng);
      const p1 = proj4('EPSG:4326', 'EPSG:2039', [this._dimPoints[0].lng, this._dimPoints[0].lat]);
      const p2 = proj4('EPSG:4326', 'EPSG:2039', [e.latlng.lng, e.latlng.lat]);
      const dist = Math.sqrt(Math.pow(p2[0]-p1[0],2) + Math.pow(p2[1]-p1[1],2));
      const lbl = dist > 1000 ? (dist/1000).toFixed(2) + ' ק"מ' : dist.toFixed(1) + ' מ\'';
      tooltip.style.display = 'block';
      const pt = this.map.latLngToContainerPoint(e.latlng);
      tooltip.style.left = (pt.x + 15) + 'px';
      tooltip.style.top = (pt.y - 10) + 'px';
      tooltip.textContent = lbl;
    } else if (this._measureToolActive === 'sketch' && this._sketchPhase === 'polygon' && this._sketchPoints.length > 0) {
      tooltip.style.display = 'block';
      const pt = this.map.latLngToContainerPoint(e.latlng);
      tooltip.style.left = (pt.x + 15) + 'px';
      tooltip.style.top = (pt.y - 10) + 'px';
      tooltip.textContent = this._sketchPoints.length < 3 ? 'לחץ להוספת נקודה' : 'דאבל-קליק לסיום';
    } else {
      tooltip.style.display = 'none';
    }
  }

  _onAdvancedMeasureDblClick(e) {
    if (!this._measureToolActive) return;
    if (this._measureToolActive === 'line' && this._measurePoints.length >= 2) {
      this._finishMeasureLine();
    } else if (this._measureToolActive === 'area' && this._measurePoints.length >= 3) {
      this._finishMeasureArea();
    } else if (this._measureToolActive === 'sketch' && this._sketchPhase === 'polygon' && this._sketchPoints.length >= 3) {
      this._finishSketchPolygon();
    }
  }

  /* ── Measure Line Tool ── */
  _onMeasureLineClick(latlng) {
    this._measurePoints.push(latlng);
    const marker = L.circleMarker(latlng, {
      radius: 5, fillColor: '#3b82f6', color: '#fff', weight: 2, fillOpacity: 1
    }).addTo(this.map);
    this._measureLayers.push(marker);

    if (this._measurePoints.length > 1) {
      const pts = this._measurePoints;
      const i = pts.length - 1;
      const line = L.polyline([pts[i-1], pts[i]], {
        color: '#3b82f6', weight: 3, dashArray: '8,6'
      }).addTo(this.map);
      this._measureLayers.push(line);

      // Segment label
      const mid = L.latLng((pts[i-1].lat + pts[i].lat)/2, (pts[i-1].lng + pts[i].lng)/2);
      const p1 = proj4('EPSG:4326', 'EPSG:2039', [pts[i-1].lng, pts[i-1].lat]);
      const p2 = proj4('EPSG:4326', 'EPSG:2039', [pts[i].lng, pts[i].lat]);
      const segDist = Math.sqrt(Math.pow(p2[0]-p1[0],2) + Math.pow(p2[1]-p1[1],2));
      const segLabel = segDist > 1000 ? (segDist/1000).toFixed(2) + ' ק"מ' : segDist.toFixed(1) + ' מ\'';
      const dimMarker = L.marker(mid, {
        icon: L.divIcon({ className: 'dim-label', html: segLabel, iconSize: null, iconAnchor: [0, -8] }),
        interactive: false
      }).addTo(this.map);
      this._measureLayers.push(dimMarker);
    }
  }

  _finishMeasureLine() {
    if (this._measurePoints.length < 2) return;
    const pts = [...this._measurePoints];
    
    // Calculate total distance in ITM
    let totalDist = 0;
    const projected = pts.map(p => proj4('EPSG:4326', 'EPSG:2039', [p.lng, p.lat]));
    for (let i = 1; i < projected.length; i++) {
      totalDist += Math.sqrt(Math.pow(projected[i][0]-projected[i-1][0],2) + Math.pow(projected[i][1]-projected[i-1][1],2));
    }
    const totalLabel = totalDist > 1000 ? (totalDist/1000).toFixed(2) + ' ק"מ' : totalDist.toFixed(1) + ' מ\'';

    // Total label at end
    const totalMarker = L.popup({ closeButton: false, autoClose: false, closeOnClick: false, className: 'measure-popup' })
      .setLatLng(pts[pts.length-1])
      .setContent(`<strong>סה"כ: ${totalLabel}</strong>`)
      .addTo(this.map);
    this._measureLayers.push(totalMarker);

    // Save
    const id = ++this._measureIdCounter;
    const name = prompt('שם המדידה:', `קו מדידה ${id}`) || `קו מדידה ${id}`;
    this._savedMeasurements.push({
      id, type: 'line', name, value: totalDist,
      unit: totalDist > 1000 ? 'ק"מ' : 'מ\'',
      displayValue: totalLabel,
      layers: [...this._measureLayers],
      latlngs: pts
    });

    this._measurePoints = [];
    this._measureLayers = [];
    this._renderMeasureList();
  }

  /* ── Measure Area Tool ── */
  _onMeasureAreaClick(latlng) {
    this._measurePoints.push(latlng);
    const marker = L.circleMarker(latlng, {
      radius: 5, fillColor: '#10b981', color: '#fff', weight: 2, fillOpacity: 1
    }).addTo(this.map);
    this._measureLayers.push(marker);

    if (this._measurePoints.length >= 3) {
      // Redraw polygon
      if (this._measurePolygon) this.map.removeLayer(this._measurePolygon);
      this._measurePolygon = L.polygon(this._measurePoints, {
        color: '#10b981', weight: 2, fillOpacity: 0.15, fillColor: '#10b981', dashArray: '8,6'
      }).addTo(this.map);
      this._measureLayers.push(this._measurePolygon);
    } else if (this._measurePoints.length === 2) {
      const line = L.polyline(this._measurePoints, {
        color: '#10b981', weight: 2, dashArray: '8,6'
      }).addTo(this.map);
      this._measureLayers.push(line);
    }
  }

  _finishMeasureArea() {
    if (this._measurePoints.length < 3) return;
    const pts = [...this._measurePoints];

    // Calculate area (shoelace)
    const projected = pts.map(p => proj4('EPSG:4326', 'EPSG:2039', [p.lng, p.lat]));
    let area = 0;
    for (let i = 0; i < projected.length; i++) {
      const j = (i + 1) % projected.length;
      area += projected[i][0] * projected[j][1];
      area -= projected[j][0] * projected[i][1];
    }
    area = Math.abs(area) / 2;

    // Calculate perimeter
    let perimeter = 0;
    for (let i = 0; i < projected.length; i++) {
      const j = (i + 1) % projected.length;
      perimeter += Math.sqrt(Math.pow(projected[j][0]-projected[i][0],2) + Math.pow(projected[j][1]-projected[i][1],2));
    }
    const areaLabel = area > 10000 ? (area/10000).toFixed(2) + ' דונם' : Math.round(area) + ' מ"ר';
    const perimLabel = perimeter > 1000 ? (perimeter/1000).toFixed(2) + ' ק"מ' : Math.round(perimeter) + ' מ\'';

    // Final polygon
    if (this._measurePolygon) this.map.removeLayer(this._measurePolygon);
    const polygon = L.polygon(pts, {
      color: '#10b981', weight: 2, fillOpacity: 0.2, fillColor: '#10b981'
    }).addTo(this.map);
    this._measureLayers.push(polygon);

    // Area label at center
    const center = polygon.getBounds().getCenter();
    const areaMarker = L.marker(center, {
      icon: L.divIcon({ className: 'dim-label-area', html: `${areaLabel}<br><span style="font-size:10px;font-weight:400">היקף: ${perimLabel}</span>`, iconSize: null }),
      interactive: false
    }).addTo(this.map);
    this._measureLayers.push(areaMarker);

    // Edge dimension labels
    for (let i = 0; i < pts.length; i++) {
      const j = (i + 1) % pts.length;
      const mid = L.latLng((pts[i].lat+pts[j].lat)/2, (pts[i].lng+pts[j].lng)/2);
      const edgeDist = Math.sqrt(Math.pow(projected[j][0]-projected[i][0],2) + Math.pow(projected[j][1]-projected[i][1],2));
      const edgeLabel = edgeDist.toFixed(1) + ' מ\'';
      const edgeMarker = L.marker(mid, {
        icon: L.divIcon({ className: 'dim-label', html: edgeLabel, iconSize: null, iconAnchor: [0, -6] }),
        interactive: false
      }).addTo(this.map);
      this._measureLayers.push(edgeMarker);
    }

    // Save
    const id = ++this._measureIdCounter;
    const name = prompt('שם המדידה:', `שטח ${id}`) || `שטח ${id}`;
    this._savedMeasurements.push({
      id, type: 'area', name, value: area, perimeter,
      unit: area > 10000 ? 'דונם' : 'מ"ר',
      displayValue: areaLabel,
      displayPerimeter: perimLabel,
      layers: [...this._measureLayers],
      latlngs: pts
    });

    this._measurePoints = [];
    this._measureLayers = [];
    this._measurePolygon = null;
    this._renderMeasureList();
  }

  /* ── Dimension Line Tool ── */
  _onDimensionClick(latlng) {
    this._dimPoints.push(latlng);
    const marker = L.circleMarker(latlng, {
      radius: 5, fillColor: '#f59e0b', color: '#fff', weight: 2, fillOpacity: 1
    }).addTo(this.map);
    this._measureLayers.push(marker);

    if (this._dimPoints.length === 2) {
      this._commitDimension(this._dimPoints[0], this._dimPoints[1]);
      this._dimPoints = [];
    }
  }

  _commitDimension(p1, p2) {
    const layers = [];

    // Project to ITM for accurate measurement
    const itm1 = proj4('EPSG:4326', 'EPSG:2039', [p1.lng, p1.lat]);
    const itm2 = proj4('EPSG:4326', 'EPSG:2039', [p2.lng, p2.lat]);
    const dist = Math.sqrt(Math.pow(itm2[0]-itm1[0],2) + Math.pow(itm2[1]-itm1[1],2));
    const label = dist > 1000 ? (dist/1000).toFixed(2) + ' ק"מ' : dist.toFixed(2) + ' מ\'';

    // Draw dimension line with end ticks
    const mainLine = L.polyline([p1, p2], {
      color: '#f59e0b', weight: 2.5, dashArray: '6,4'
    }).addTo(this.map);
    layers.push(mainLine);

    // End-point markers (small ticks perpendicular to the line)
    const m1 = L.circleMarker(p1, { radius: 4, fillColor: '#f59e0b', color: '#fff', weight: 2, fillOpacity: 1 }).addTo(this.map);
    const m2 = L.circleMarker(p2, { radius: 4, fillColor: '#f59e0b', color: '#fff', weight: 2, fillOpacity: 1 }).addTo(this.map);
    layers.push(m1, m2);

    // Label at midpoint
    const mid = L.latLng((p1.lat+p2.lat)/2, (p1.lng+p2.lng)/2);
    const dimLabel = L.marker(mid, {
      icon: L.divIcon({
        className: 'dim-label',
        html: `<i class="fas fa-arrows-alt-h" style="font-size:9px;margin-left:3px"></i> ${label}`,
        iconSize: null, iconAnchor: [0, -10]
      }),
      interactive: false
    }).addTo(this.map);
    layers.push(dimLabel);

    // Save
    const id = ++this._measureIdCounter;
    this._savedMeasurements.push({
      id, type: 'dimension', name: `מידה ${id}`,
      value: dist,
      unit: dist > 1000 ? 'ק"מ' : 'מ\'',
      displayValue: label,
      layers: [...this._measureLayers, ...layers],
      latlngs: [p1, p2]
    });

    this._measureLayers = [];
    this._renderMeasureList();
  }

  /* ── Sketch (תמחון) Tool ── */
  _onSketchClick(latlng) {
    if (this._sketchPhase === 'polygon') {
      this._sketchPoints.push(latlng);
      const marker = L.circleMarker(latlng, {
        radius: 5, fillColor: '#6366f1', color: '#fff', weight: 2, fillOpacity: 1
      }).addTo(this.map);
      this._sketchTempLayers.push(marker);

      if (this._sketchPoints.length >= 2) {
        const pts = this._sketchPoints;
        const line = L.polyline([pts[pts.length-2], pts[pts.length-1]], {
          color: '#6366f1', weight: 2, dashArray: '6,4'
        }).addTo(this.map);
        this._sketchTempLayers.push(line);
      }
    } else if (this._sketchPhase === 'dimensions') {
      // Adding dimension lines to the sketch
      this._dimPoints.push(latlng);
      const marker = L.circleMarker(latlng, {
        radius: 4, fillColor: '#f59e0b', color: '#fff', weight: 2, fillOpacity: 1
      }).addTo(this.map);
      this._sketchTempLayers.push(marker);

      if (this._dimPoints.length === 2) {
        this._addSketchDimension(this._dimPoints[0], this._dimPoints[1]);
        this._dimPoints = [];
      }
    }
  }

  _finishSketchPolygon() {
    if (this._sketchPoints.length < 3) return;
    const pts = [...this._sketchPoints];

    // Draw final polygon
    const polygon = L.polygon(pts, {
      color: '#6366f1', weight: 2.5, fillOpacity: 0.08, fillColor: '#6366f1'
    }).addTo(this.map);
    this._sketchTempLayers.push(polygon);
    this._sketchPolygonLayer = polygon;

    // Calculate area
    const projected = pts.map(p => proj4('EPSG:4326', 'EPSG:2039', [p.lng, p.lat]));
    let area = 0;
    for (let i = 0; i < projected.length; i++) {
      const j = (i + 1) % projected.length;
      area += projected[i][0] * projected[j][1];
      area -= projected[j][0] * projected[i][1];
    }
    area = Math.abs(area) / 2;
    const areaLabel = area > 10000 ? (area/10000).toFixed(2) + ' דונם' : Math.round(area) + ' מ"ר';

    // Add edge dimension labels automatically
    for (let i = 0; i < pts.length; i++) {
      const j = (i + 1) % pts.length;
      const mid = L.latLng((pts[i].lat+pts[j].lat)/2, (pts[i].lng+pts[j].lng)/2);
      const edgeDist = Math.sqrt(Math.pow(projected[j][0]-projected[i][0],2) + Math.pow(projected[j][1]-projected[i][1],2));
      const edgeLabel = edgeDist.toFixed(1) + ' מ\'';
      const edgeMarker = L.marker(mid, {
        icon: L.divIcon({ className: 'dim-label', html: edgeLabel, iconSize: null, iconAnchor: [0, -8] }),
        interactive: false
      }).addTo(this.map);
      this._sketchTempLayers.push(edgeMarker);
    }

    // Area label at center
    const center = polygon.getBounds().getCenter();
    const areaMarker = L.marker(center, {
      icon: L.divIcon({ className: 'dim-label-area', html: `שטח: ${areaLabel}`, iconSize: null }),
      interactive: false
    }).addTo(this.map);
    this._sketchTempLayers.push(areaMarker);

    // Switch to dimension-adding phase
    this._sketchPhase = 'dimensions';
    this._dimPoints = [];

    // Update tool button text
    const btn = document.getElementById('mt-sketch');
    if (btn) btn.innerHTML = '<i class="fas fa-arrows-alt-h"></i> הוסף מידות (Enter לסיום)';

    // Listen for Enter to finish
    this._sketchKeyHandler = (e) => {
      if (e.key === 'Enter') {
        this._finishSketch(pts, area);
      }
    };
    document.addEventListener('keydown', this._sketchKeyHandler);
  }

  _addSketchDimension(p1, p2) {
    const itm1 = proj4('EPSG:4326', 'EPSG:2039', [p1.lng, p1.lat]);
    const itm2 = proj4('EPSG:4326', 'EPSG:2039', [p2.lng, p2.lat]);
    const dist = Math.sqrt(Math.pow(itm2[0]-itm1[0],2) + Math.pow(itm2[1]-itm1[1],2));
    const label = dist.toFixed(1) + ' מ\'';

    const line = L.polyline([p1, p2], {
      color: '#f59e0b', weight: 2, dashArray: '4,4'
    }).addTo(this.map);
    this._sketchTempLayers.push(line);

    const mid = L.latLng((p1.lat+p2.lat)/2, (p1.lng+p2.lng)/2);
    const dimMarker = L.marker(mid, {
      icon: L.divIcon({ className: 'dim-label', html: `<i class="fas fa-arrows-alt-h" style="font-size:8px;margin-left:2px"></i> ${label}`, iconSize: null, iconAnchor: [0, -8] }),
      interactive: false
    }).addTo(this.map);
    this._sketchTempLayers.push(dimMarker);
  }

  _finishSketch(pts, area) {
    if (this._sketchKeyHandler) {
      document.removeEventListener('keydown', this._sketchKeyHandler);
      this._sketchKeyHandler = null;
    }

    const areaLabel = area > 10000 ? (area/10000).toFixed(2) + ' דונם' : Math.round(area) + ' מ"ר';
    const id = ++this._measureIdCounter;
    const name = prompt('שם התמחון:', `תמחון ${id}`) || `תמחון ${id}`;

    this._savedMeasurements.push({
      id, type: 'sketch', name,
      value: area,
      unit: area > 10000 ? 'דונם' : 'מ"ר',
      displayValue: areaLabel,
      layers: [...this._sketchTempLayers],
      latlngs: pts
    });

    this._sketchTempLayers = [];
    this._sketchPoints = [];
    this._sketchPhase = null;
    this._sketchPolygonLayer = null;
    this._dimPoints = [];

    // Reset button
    const btn = document.getElementById('mt-sketch');
    if (btn) btn.innerHTML = '<i class="fas fa-pencil-ruler"></i> תמחון';

    this._cancelMeasureTool();
    this._renderMeasureList();
  }

  /* ── Measurement List Rendering ── */
  _renderMeasureList() {
    const container = document.getElementById('measure-list');
    if (!container) return;

    if (this._savedMeasurements.length === 0) {
      container.innerHTML = `<div class="mdlg-empty">
        <i class="fas fa-ruler" style="font-size:24px;color:var(--border);display:block;margin-bottom:8px"></i>
        לחץ על כלי למעלה להתחיל מדידה<br>
        <span style="font-size:11px;color:#999">
          <b>קו</b> - מדידת מרחק בין נקודות<br>
          <b>שטח</b> - מדידת שטח פוליגון<br>
          <b>מידה</b> - קו מידה בין 2 נקודות<br>
          <b>תמחון</b> - סמן שטח + מידות סביבו
        </span>
      </div>`;
      return;
    }

    const icons = { line: 'fa-ruler', area: 'fa-ruler-combined', dimension: 'fa-arrows-alt-h', sketch: 'fa-pencil-ruler' };
    const colors = { line: '#3b82f6', area: '#10b981', dimension: '#f59e0b', sketch: '#6366f1' };
    const typeNames = { line: 'קו', area: 'שטח', dimension: 'מידה', sketch: 'תמחון' };

    let html = '';
    for (const m of this._savedMeasurements) {
      const icon = icons[m.type] || 'fa-ruler';
      const color = colors[m.type] || '#999';
      let valText = m.displayValue;
      if (m.type === 'area' && m.displayPerimeter) {
        valText += ` (${m.displayPerimeter})`;
      }
      html += `<div class="mdlg-item" onclick="app.zoomToMeasurement(${m.id})">
        <div class="mdlg-icon" style="color:${color}"><i class="fas ${icon}"></i></div>
        <span class="mdlg-name" title="${m.name}">${m.name}</span>
        <span class="mdlg-val">${valText}</span>
        <button class="mdlg-del" onclick="event.stopPropagation();app.deleteMeasurement(${m.id})" title="מחק"><i class="fas fa-trash"></i></button>
      </div>`;
    }
    container.innerHTML = html;
  }

  zoomToMeasurement(id) {
    const m = this._savedMeasurements.find(x => x.id === id);
    if (!m || !m.latlngs.length) return;
    if (m.latlngs.length === 1) {
      this.map.setView(m.latlngs[0], 18);
    } else {
      this.map.fitBounds(L.latLngBounds(m.latlngs), { padding: [40, 40] });
    }
  }

  deleteMeasurement(id) {
    const idx = this._savedMeasurements.findIndex(x => x.id === id);
    if (idx === -1) return;
    const m = this._savedMeasurements[idx];
    m.layers.forEach(l => this.map.removeLayer(l));
    this._savedMeasurements.splice(idx, 1);
    this._renderMeasureList();
  }

  clearAllMeasurements() {
    if (this._savedMeasurements.length && !confirm('למחוק את כל המדידות?')) return;
    for (const m of this._savedMeasurements) {
      m.layers.forEach(l => this.map.removeLayer(l));
    }
    this._savedMeasurements = [];
    this._cancelMeasureTool();
    this._renderMeasureList();
  }

  exportMeasurements() {
    if (!this._savedMeasurements.length) { alert('אין מדידות לייצוא'); return; }
    const typeNames = { line: 'קו', area: 'שטח', dimension: 'מידה', sketch: 'תמחון' };
    let csv = 'שם,סוג,ערך,יחידות\n';
    for (const m of this._savedMeasurements) {
      csv += `"${m.name}","${typeNames[m.type] || m.type}","${m.displayValue}","${m.unit}"\n`;
    }
    const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `measurements_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  /* ── Measure Tool (existing basic) ── */
  toggleMeasure(mode) {
    // Turn off coord pin mode if active
    if (this._coordPinMode) {
      this._coordPinMode = false;
      document.getElementById('coord-pin-btn')?.classList.remove('active');
      const overlay = document.getElementById('coord-pin-overlay');
      if (overlay) overlay.style.display = 'none';
    }
    // Turn off draw mode if active
    if (this._drawMode) {
      this._drawMode = false;
      this._cancelDrawing();
      document.getElementById('draw-toolbar')?.classList.remove('visible');
      document.getElementById('draw-mode-btn')?.classList.remove('active');
    }
    if (this._measureMode === mode) {
      this._measureMode = null;
      this.map.getContainer().style.cursor = '';
      document.getElementById('measure-distance-btn').classList.remove('active');
      document.getElementById('measure-area-btn').classList.remove('active');
      return;
    }
    this.clearMeasure();
    this._measureMode = mode;
    this.map.getContainer().style.cursor = 'crosshair';
    document.getElementById('measure-distance-btn').classList.toggle('active', mode === 'distance');
    document.getElementById('measure-area-btn').classList.toggle('active', mode === 'area');
  }

  _onMeasureClick(e) {
    if (!this._measureMode) return;
    // Snap support for measure tool
    let latlng = e.latlng;
    if (this._drawSnap) {
      const snapped = this._findSnapPoint(latlng);
      if (snapped) latlng = snapped;
    }
    this._measurePoints.push(latlng);

    // Add a circle marker at the clicked point
    const marker = L.circleMarker(latlng, {
      radius: 5, fillColor: '#ef4444', color: '#fff', weight: 2, fillOpacity: 1
    }).addTo(this.map);
    this._measureLayers.push(marker);

    if (this._measurePoints.length > 1) {
      const pts = this._measurePoints;
      if (this._measureMode === 'distance') {
        // Draw line between last two points
        const line = L.polyline([pts[pts.length-2], pts[pts.length-1]], {
          color: '#ef4444', weight: 3, dashArray: '8,6'
        }).addTo(this.map);
        this._measureLayers.push(line);

        // Show total distance
        let totalDist = 0;
        for (let i = 1; i < pts.length; i++) {
          totalDist += pts[i-1].distanceTo(pts[i]);
        }
        const label = totalDist > 1000 ? (totalDist/1000).toFixed(2) + ' ק"מ' : Math.round(totalDist) + ' מ\'';
        // Update or create label
        if (this._measureLabel) this.map.removeLayer(this._measureLabel);
        this._measureLabel = L.popup({ closeButton: false, autoClose: false, closeOnClick: false, className: 'measure-popup' })
          .setLatLng(pts[pts.length-1])
          .setContent(`<strong>מרחק: ${label}</strong>`)
          .addTo(this.map);
        this._measureLayers.push(this._measureLabel);
      } else if (this._measureMode === 'area' && pts.length >= 3) {
        // Draw polygon
        if (this._measurePolygon) this.map.removeLayer(this._measurePolygon);
        this._measurePolygon = L.polygon(pts, {
          color: '#ef4444', weight: 2, fillOpacity: 0.15, fillColor: '#ef4444', dashArray: '8,6'
        }).addTo(this.map);
        this._measureLayers.push(this._measurePolygon);

        // Compute area using Shoelace formula on projected coordinates
        const projected = pts.map(p => proj4('EPSG:4326', 'EPSG:2039', [p.lng, p.lat]));
        let area = 0;
        for (let i = 0; i < projected.length; i++) {
          const j = (i + 1) % projected.length;
          area += projected[i][0] * projected[j][1];
          area -= projected[j][0] * projected[i][1];
        }
        area = Math.abs(area) / 2;
        const label = area > 10000 ? (area/10000).toFixed(2) + ' דונם' : Math.round(area) + ' מ"ר';
        if (this._measureLabel) this.map.removeLayer(this._measureLabel);
        const center = this._measurePolygon.getBounds().getCenter();
        this._measureLabel = L.popup({ closeButton: false, autoClose: false, closeOnClick: false, className: 'measure-popup' })
          .setLatLng(center)
          .setContent(`<strong>שטח: ${label}</strong>`)
          .addTo(this.map);
        this._measureLayers.push(this._measureLabel);
      }
    }
  }

  _onMeasureMove(e) {
    if (!this._measureMode || !this._measurePoints.length) return;
    /* Show snap indicator while measuring */
    if (this._drawSnap) {
      const snap = this._findSnapPoint(e.latlng);
      if (snap) { this._showSnapIndicator(snap); } else { this._showSnapIndicator(null); }
    }
    const tooltip = document.getElementById('measure-tooltip');
    const lastPt = this._measurePoints[this._measurePoints.length - 1];
    const dist = lastPt.distanceTo(e.latlng);
    const label = dist > 1000 ? (dist/1000).toFixed(2) + ' ק"מ' : Math.round(dist) + ' מ\'';
    tooltip.style.display = 'block';
    const mapRect = this.map.getContainer().getBoundingClientRect();
    const point = this.map.latLngToContainerPoint(e.latlng);
    tooltip.style.left = (point.x + 15) + 'px';
    tooltip.style.top = (point.y - 10) + 'px';
    tooltip.textContent = label;
  }

  clearMeasure() {
    this._measureMode = null;
    this._measurePoints = [];
    this._measureLayers.forEach(l => this.map.removeLayer(l));
    this._measureLayers = [];
    this._measureLabel = null;
    this._measurePolygon = null;
    this.map.getContainer().style.cursor = '';
    document.getElementById('measure-distance-btn')?.classList.remove('active');
    document.getElementById('measure-area-btn')?.classList.remove('active');
    const tooltip = document.getElementById('measure-tooltip');
    if (tooltip) tooltip.style.display = 'none';
  }

  /* ── Coordinate Pin Tool ── */
  toggleCoordPin() {
    // Turn off measure mode if active
    if (this._measureMode) this.clearMeasure();
    this._coordPinMode = !this._coordPinMode;
    this.map.getContainer().style.cursor = this._coordPinMode ? 'crosshair' : '';
    document.getElementById('coord-pin-btn')?.classList.toggle('active', this._coordPinMode);
    // Show/hide transparent overlay to intercept clicks above all layers
    const overlay = document.getElementById('coord-pin-overlay');
    if (overlay) {
      overlay.style.display = this._coordPinMode ? 'block' : 'none';
    }
  }

  _initCoordPinOverlay() {
    const overlay = document.getElementById('coord-pin-overlay');
    if (!overlay) return;
    overlay.addEventListener('click', (evt) => {
      if (!this._coordPinMode) return;
      // Convert DOM click position to map latlng
      const rect = this.map.getContainer().getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      let latlng = this.map.containerPointToLatLng(L.point(x, y));
      if (this._drawSnap) { const s = this._findSnapPoint(latlng); if (s) latlng = s; }
      this._placeCoordPin(latlng);
    });
    // Allow scroll-zoom and drag through the overlay
    overlay.addEventListener('wheel', (evt) => { overlay.style.pointerEvents = 'none'; setTimeout(() => { if (this._coordPinMode) overlay.style.pointerEvents = 'auto'; }, 50); }, { passive: true });
    overlay.addEventListener('mousedown', (evt) => {
      if (evt.button !== 0) return; // Only intercept left-click
      // Track if this is a drag vs click
      const startX = evt.clientX, startY = evt.clientY;
      let dragged = false;
      const onMove = (e2) => {
        if (Math.abs(e2.clientX - startX) > 3 || Math.abs(e2.clientY - startY) > 3) {
          dragged = true;
          overlay.style.pointerEvents = 'none';
        }
      };
      const onUp = () => {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        setTimeout(() => { if (this._coordPinMode) overlay.style.pointerEvents = 'auto'; }, 50);
      };
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  _placeCoordPin(latlng) {
    const lat = latlng.lat;
    const lng = latlng.lng;
    const itm = proj4('EPSG:4326', 'EPSG:2039', [lng, lat]);
    const id = ++this._coordPinIdCounter;

    const pinIcon = L.divIcon({
      className: 'coord-pin-icon',
      html: `<i class="fas fa-map-pin" style="color:#ef4444;font-size:22px;text-shadow:0 1px 3px rgba(0,0,0,.4)"></i>`,
      iconSize: [22, 22],
      iconAnchor: [11, 22],
      popupAnchor: [0, -22]
    });

    const marker = L.marker(latlng, { icon: pinIcon, draggable: true }).addTo(this.map);

    const popupContent = this._buildCoordPinPopup(lat, lng, itm, id);
    marker.bindPopup(popupContent, { maxWidth: 280, className: 'coord-pin-popup-wrap' });
    marker.openPopup();

    // Update popup on drag
    marker.on('dragend', () => {
      const pos = marker.getLatLng();
      const newItm = proj4('EPSG:4326', 'EPSG:2039', [pos.lng, pos.lat]);
      marker.setPopupContent(this._buildCoordPinPopup(pos.lat, pos.lng, newItm, id));
      this._saveCoordPins();
    });

    this._coordPins.push({ id, marker, latlng });
    this._saveCoordPins();
  }

  _onCoordPinClick(e) {
    // Fallback: if overlay somehow misses, still handle via map click
    if (!this._coordPinMode) return;
    let latlng = e.latlng;
    if (this._drawSnap) { const s = this._findSnapPoint(latlng); if (s) latlng = s; }
    this._placeCoordPin(latlng);
  }

  _buildCoordPinPopup(lat, lng, itm, id) {
    return `<div class="coord-pin-popup">
      <div class="coord-line"><span class="coord-label">WGS84:</span> <span class="coord-value">${lat.toFixed(6)}, ${lng.toFixed(6)}</span></div>
      <div class="coord-line"><span class="coord-label">ITM X:</span> <span class="coord-value">${itm[0].toFixed(1)}</span></div>
      <div class="coord-line"><span class="coord-label">ITM Y:</span> <span class="coord-value">${itm[1].toFixed(1)}</span></div>
      <div class="coord-actions">
        <button class="coord-copy-btn" onclick="app._copyCoordPin(${id})"><i class="fas fa-copy"></i> העתק</button>
        <button class="coord-delete-btn" onclick="app._deleteCoordPin(${id})"><i class="fas fa-trash"></i> מחק</button>
      </div>
    </div>`;
  }

  _copyCoordPin(id) {
    const pin = this._coordPins.find(p => p.id === id);
    if (!pin) return;
    const pos = pin.marker.getLatLng();
    const itm = proj4('EPSG:4326', 'EPSG:2039', [pos.lng, pos.lat]);
    const text = `WGS84: ${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)}\nITM: ${itm[0].toFixed(1)}, ${itm[1].toFixed(1)}`;
    navigator.clipboard.writeText(text).then(() => {
      // Show brief feedback
      const btn = document.querySelector(`.coord-copy-btn`);
      if (btn) { btn.textContent = '✓ הועתק'; setTimeout(() => { btn.innerHTML = '<i class="fas fa-copy"></i> העתק'; }, 1200); }
    });
  }

  _deleteCoordPin(id) {
    const idx = this._coordPins.findIndex(p => p.id === id);
    if (idx === -1) return;
    this.map.removeLayer(this._coordPins[idx].marker);
    this._coordPins.splice(idx, 1);
    this._saveCoordPins();
  }

  clearCoordPins() {
    this._coordPins.forEach(p => this.map.removeLayer(p.marker));
    this._coordPins = [];
    this._coordPinIdCounter = 0;
    this._saveCoordPins();
    this._coordPinMode = false;
    this.map.getContainer().style.cursor = '';
    document.getElementById('coord-pin-btn')?.classList.remove('active');
    const overlay = document.getElementById('coord-pin-overlay');
    if (overlay) overlay.style.display = 'none';
  }

  _saveCoordPins() {
    const data = this._coordPins.map(p => {
      const pos = p.marker.getLatLng();
      return { id: p.id, lat: pos.lat, lng: pos.lng };
    });
    localStorage.setItem('coordPins', JSON.stringify(data));
  }

  _loadSavedCoordPins() {
    try {
      const saved = JSON.parse(localStorage.getItem('coordPins') || '[]');
      if (!Array.isArray(saved) || !saved.length) return;
      // Pins will be re-created after map is initialized — defer
      this._pendingCoordPins = saved;
    } catch(e) {}
  }

  _restoreCoordPins() {
    if (!this._pendingCoordPins) return;
    for (const s of this._pendingCoordPins) {
      const itm = proj4('EPSG:4326', 'EPSG:2039', [s.lng, s.lat]);
      const id = ++this._coordPinIdCounter;

      const pinIcon = L.divIcon({
        className: 'coord-pin-icon',
        html: `<i class="fas fa-map-pin" style="color:#ef4444;font-size:22px;text-shadow:0 1px 3px rgba(0,0,0,.4)"></i>`,
        iconSize: [22, 22],
        iconAnchor: [11, 22],
        popupAnchor: [0, -22]
      });

      const latlng = L.latLng(s.lat, s.lng);
      const marker = L.marker(latlng, { icon: pinIcon, draggable: true }).addTo(this.map);
      marker.bindPopup(this._buildCoordPinPopup(s.lat, s.lng, itm, id), { maxWidth: 280, className: 'coord-pin-popup-wrap' });

      marker.on('dragend', () => {
        const pos = marker.getLatLng();
        const newItm = proj4('EPSG:4326', 'EPSG:2039', [pos.lng, pos.lat]);
        marker.setPopupContent(this._buildCoordPinPopup(pos.lat, pos.lng, newItm, id));
        this._saveCoordPins();
      });

      this._coordPins.push({ id, marker, latlng });
    }
    this._pendingCoordPins = null;
  }

  /* ── Export View ── */
  async exportView() {
    // Use leaflet-image or canvas screenshot
    try {
      const canvas = document.createElement('canvas');
      const mapEl = this.map.getContainer();
      const rect = mapEl.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      const ctx = canvas.getContext('2d');

      // Use html2canvas-like approach by grabbing the map tiles
      const tiles = mapEl.querySelectorAll('.leaflet-tile');
      const pane = mapEl.querySelector('.leaflet-map-pane');
      const transform = getComputedStyle(pane).transform;

      // Simpler: open print dialog
      window.print();
    } catch(e) {
      // Fallback: open print dialog
      window.print();
    }
  }
}

const app = new GushHelkaApp();

/* ═══════════════════════════════════════════════════════════════
   ADVANCED DOCUMENT VIEWER
   Supports: PDF (rendered via pdf.js), images, JSON, HTML, KML (mini-map),
             DOCX (mammoth.js), and all other formats (info + download).
   ═══════════════════════════════════════════════════════════════ */
const docViewer = (() => {
  let _overlay, _content, _titleEl, _planEl, _zoomEl, _loading, _sidebar, _thumbsEl;
  let _docs = [];           // filtered doc list for navigation
  let _currentIdx = -1;
  let _scale = 1;
  let _rotation = 0;
  let _pdfDoc = null;
  let _pdfPages = [];
  let _pdfjsLib = null;
  let _pdfjsLoaded = false;
  let _sidebarOpen = false;

  function init() {
    _overlay = document.getElementById('doc-viewer');
    _content = document.getElementById('viewer-content');
    _titleEl = document.getElementById('viewer-title');
    _planEl = document.getElementById('viewer-plan');
    _zoomEl = document.getElementById('viewer-zoom');
    _loading = document.getElementById('viewer-loading');
    _sidebar = document.getElementById('viewer-sidebar');
    _thumbsEl = document.getElementById('viewer-thumbs');

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if (!_overlay.classList.contains('open')) return;
      if (e.key === 'Escape') { close(); e.preventDefault(); }
      else if (e.key === 'ArrowRight') { prevDoc(); e.preventDefault(); }
      else if (e.key === 'ArrowLeft') { nextDoc(); e.preventDefault(); }
      else if (e.key === '+' || e.key === '=') { zoomIn(); e.preventDefault(); }
      else if (e.key === '-') { zoomOut(); e.preventDefault(); }
      else if (e.key === 'r' || e.key === 'R') { rotateCW(); e.preventDefault(); }
      else if (e.key === 'f' || e.key === 'F') { toggleFullscreen(); e.preventDefault(); }
    });

    // Mouse wheel zoom
    _content?.addEventListener('wheel', e => {
      if (!_overlay.classList.contains('open')) return;
      e.preventDefault();
      if (e.deltaY < 0) zoomIn(0.1);
      else zoomOut(0.1);
    }, { passive: false });
  }

  async function loadPdfJs() {
    if (_pdfjsLoaded) return _pdfjsLib;
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
      script.onload = () => {
        _pdfjsLib = window.pdfjsLib;
        _pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        _pdfjsLoaded = true;
        resolve(_pdfjsLib);
      };
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  function open(docInfo, docsList) {
    if (!_overlay) init();
    _docs = docsList || [];
    _currentIdx = _docs.findIndex(d => d._idx === docInfo._idx);
    if (_currentIdx < 0) {
      _docs = [docInfo];
      _currentIdx = 0;
    }
    _scale = 1;
    _rotation = 0;
    _overlay.classList.add('open');
    document.body.style.overflow = 'hidden';
    renderDoc(docInfo);
  }

  function close() {
    _overlay.classList.remove('open');
    document.body.style.overflow = '';
    _pdfDoc = null;
    _pdfPages = [];
    _content.innerHTML = '<div class="viewer-loading" id="viewer-loading" style="display:none"><i class="fas fa-spinner"></i></div>';
    _loading = document.getElementById('viewer-loading');
    _thumbsEl.innerHTML = '';
    if (document.fullscreenElement) document.exitFullscreen();
  }

  function renderDoc(doc) {
    const ft = (doc.FILE_TYPE || doc.type || '').trim().toLowerCase();
    const name = doc.DOC_NAME || doc.name || 'מסמך';
    const plan = doc.plan || '';
    const idx = doc._idx;
    const hasFile = doc._has_file;

    _titleEl.textContent = name;
    _planEl.textContent = plan ? `תכנית ${plan}` : '';
    _zoomEl.textContent = Math.round(_scale * 100) + '%';

    // Reset
    _pdfDoc = null;
    _pdfPages = [];
    _content.innerHTML = '<div class="viewer-loading" id="viewer-loading"><i class="fas fa-spinner"></i></div>';
    _loading = document.getElementById('viewer-loading');
    _thumbsEl.innerHTML = '';
    _sidebar.classList.remove('open');
    _sidebarOpen = false;

    if (!hasFile && idx !== undefined) {
      showInfo(doc, 'הקובץ לא נמצא בדיסק המקומי');
      return;
    }

    const fileUrl = `/api/documents/file/${idx}`;

    if (ft === 'pdf') {
      renderPdf(fileUrl, doc);
    } else if (['jpg', 'jpeg', 'png', 'gif', 'svg', 'bmp', 'webp', 'tiff', 'tif'].includes(ft)) {
      renderImage(fileUrl, doc);
    } else if (ft === 'json' || ft === 'geojson') {
      renderJson(fileUrl, doc);
    } else if (ft === 'html' || ft === 'htm') {
      renderHtml(fileUrl, doc);
    } else if (ft === 'kml') {
      renderKml(fileUrl, doc);
    } else {
      // Non-viewable: show info panel with download
      showInfo(doc);
    }
  }

  /* ── PDF Rendering ── */
  async function renderPdf(url, doc) {
    try {
      const lib = await loadPdfJs();
      _pdfDoc = await lib.getDocument(url).promise;
      const numPages = _pdfDoc.numPages;

      _content.innerHTML = '<div class="viewer-pdf-container" id="pdf-container"></div>';
      const container = document.getElementById('pdf-container');

      // Render all pages
      _pdfPages = [];
      for (let i = 1; i <= numPages; i++) {
        const page = await _pdfDoc.getPage(i);
        const viewport = page.getViewport({ scale: 1.5 * _scale, rotation: _rotation });

        const wrapper = document.createElement('div');
        wrapper.className = 'pdf-page-wrapper';
        wrapper.id = `pdf-page-${i}`;
        wrapper.dataset.page = i;

        const canvas = document.createElement('canvas');
        canvas.className = 'pdf-page';
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        wrapper.appendChild(canvas);
        container.appendChild(wrapper);

        const ctx = canvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport }).promise;
        _pdfPages.push({ page, canvas, wrapper });
      }

      // Build thumbnails
      buildThumbnails(numPages);

      // Page indicator
      if (numPages > 1) {
        const indicator = document.createElement('div');
        indicator.className = 'viewer-page-indicator';
        indicator.id = 'pdf-page-indicator';
        indicator.textContent = `${numPages} עמודים`;
        _content.appendChild(indicator);

        // Scroll-based page tracking
        container.addEventListener('scroll', () => {
          const rect = container.getBoundingClientRect();
          for (let i = 0; i < _pdfPages.length; i++) {
            const wr = _pdfPages[i].wrapper.getBoundingClientRect();
            if (wr.top <= rect.top + rect.height / 2 && wr.bottom >= rect.top) {
              document.getElementById('pdf-page-indicator').textContent = `עמוד ${i + 1} מתוך ${numPages}`;
              // Update active thumb
              document.querySelectorAll('.vs-thumb').forEach((th, ti) => {
                th.classList.toggle('active', ti === i);
              });
              break;
            }
          }
        });
      }
    } catch (e) {
      console.error('PDF render error:', e);
      showInfo(doc, 'שגיאה בטעינת PDF: ' + e.message);
    }
  }

  async function buildThumbnails(numPages) {
    _thumbsEl.innerHTML = '';
    for (let i = 1; i <= Math.min(numPages, 50); i++) {
      const page = await _pdfDoc.getPage(i);
      const vp = page.getViewport({ scale: 0.3 });
      const canvas = document.createElement('canvas');
      canvas.width = vp.width;
      canvas.height = vp.height;
      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport: vp }).promise;

      const thumb = document.createElement('div');
      thumb.className = 'vs-thumb' + (i === 1 ? ' active' : '');
      thumb.onclick = () => scrollToPage(i);
      thumb.appendChild(canvas);
      const label = document.createElement('div');
      label.className = 'vs-thumb-label';
      label.textContent = `עמוד ${i}`;
      thumb.appendChild(label);
      _thumbsEl.appendChild(thumb);
    }
  }

  function scrollToPage(num) {
    const el = document.getElementById(`pdf-page-${num}`);
    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  /* ── Image Rendering ── */
  function renderImage(url, doc) {
    const img = new Image();
    img.onload = () => {
      _content.innerHTML = '';
      img.style.transform = `scale(${_scale}) rotate(${_rotation}deg)`;
      img.style.transformOrigin = 'center center';
      img.style.cursor = 'zoom-in';
      img.id = 'viewer-image';
      _content.appendChild(img);

      // Click to zoom
      img.onclick = () => {
        if (_scale < 3) { _scale *= 1.5; } else { _scale = 1; }
        img.style.transform = `scale(${_scale}) rotate(${_rotation}deg)`;
        _zoomEl.textContent = Math.round(_scale * 100) + '%';
      };
    };
    img.onerror = () => showInfo(doc, 'שגיאה בטעינת תמונה');
    img.src = url;
  }

  /* ── JSON Rendering ── */
  async function renderJson(url, doc) {
    try {
      const res = await fetch(url);
      const text = await res.text();
      const formatted = syntaxHighlightJson(text);
      _content.innerHTML = `<div class="viewer-json-container">${formatted}</div>`;
    } catch (e) {
      showInfo(doc, 'שגיאה בטעינת JSON');
    }
  }

  function syntaxHighlightJson(raw) {
    try {
      const obj = JSON.parse(raw);
      raw = JSON.stringify(obj, null, 2);
    } catch {}
    return raw.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
      .replace(/"(\\u[a-fA-F0-9]{4}|\\[^u]|[^\\"])*"\s*:/g, m => `<span class="json-key">${m}</span>`)
      .replace(/"(\\u[a-fA-F0-9]{4}|\\[^u]|[^\\"])*"/g, m => `<span class="json-str">${m}</span>`)
      .replace(/\b(-?\d+\.?\d*([eE][+-]?\d+)?)\b/g, '<span class="json-num">$1</span>')
      .replace(/\b(true|false)\b/g, '<span class="json-bool">$1</span>')
      .replace(/\bnull\b/g, '<span class="json-null">null</span>');
  }

  /* ── HTML Rendering ── */
  function renderHtml(url, doc) {
    _content.innerHTML = `<iframe src="${url}" style="width:100%;height:100%;border:none;background:#fff"></iframe>`;
  }

  /* ── KML Rendering ── */
  async function renderKml(url, doc) {
    try {
      const res = await fetch(url);
      const text = await res.text();
      _content.innerHTML = `<div class="viewer-kml-map" id="kml-map-container"></div>`;

      const kmlMap = L.map('kml-map-container').setView([31.99, 34.85], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap'
      }).addTo(kmlMap);

      // Parse KML as XML and extract coordinates
      const parser = new DOMParser();
      const xml = parser.parseFromString(text, 'text/xml');
      const placemarks = xml.querySelectorAll('Placemark');
      const bounds = L.latLngBounds();
      let hasFeatures = false;

      placemarks.forEach(pm => {
        const name = pm.querySelector('name')?.textContent || '';
        const desc = pm.querySelector('description')?.textContent || '';

        // Points
        const pointCoords = pm.querySelector('Point > coordinates');
        if (pointCoords) {
          const [lng, lat] = pointCoords.textContent.trim().split(',').map(Number);
          if (lat && lng) {
            L.marker([lat, lng]).addTo(kmlMap).bindPopup(`<b>${name}</b><br>${desc}`);
            bounds.extend([lat, lng]);
            hasFeatures = true;
          }
        }

        // LineStrings and Polygons
        const coordsEls = pm.querySelectorAll('coordinates');
        coordsEls.forEach(ce => {
          if (ce.parentElement.tagName === 'Point') return;
          const coords = ce.textContent.trim().split(/\s+/).map(c => {
            const [lng, lat] = c.split(',').map(Number);
            return lat && lng ? [lat, lng] : null;
          }).filter(Boolean);
          if (coords.length > 2) {
            const isPolygon = pm.querySelector('Polygon');
            if (isPolygon) {
              L.polygon(coords, { color: '#e11d48', weight: 2 }).addTo(kmlMap).bindPopup(`<b>${name}</b>`);
            } else {
              L.polyline(coords, { color: '#2563eb', weight: 3 }).addTo(kmlMap).bindPopup(`<b>${name}</b>`);
            }
            coords.forEach(c => bounds.extend(c));
            hasFeatures = true;
          }
        });
      });

      if (hasFeatures && bounds.isValid()) {
        kmlMap.fitBounds(bounds, { padding: [30, 30] });
      }

      setTimeout(() => kmlMap.invalidateSize(), 200);
    } catch (e) {
      showInfo(doc, 'שגיאה בטעינת KML: ' + e.message);
    }
  }

  /* ── Info Panel (non-viewable formats) ── */
  function showInfo(doc, errorMsg) {
    const ft = (doc.FILE_TYPE || doc.type || '').trim().toLowerCase();
    const name = doc.DOC_NAME || doc.name || 'מסמך';
    const plan = doc.plan || '';
    const pages = doc.DOC_PAGES || '';
    const date = doc.EDITING_DATE || doc.INTERNAL_OPEN_DATE || '';
    const source = doc.source || '';
    const rubric = doc.RUB_DESC || '';
    const idx = doc._idx;

    const formatLabels = {
      pdf: 'PDF - קובץ מסמך', dwg: 'DWG - AutoCAD', dxf: 'DXF - שרטוט',
      doc: 'DOC - Word', docx: 'DOCX - Word', xls: 'XLS - Excel',
      xlsx: 'XLSX - Excel', zip: 'ZIP - ארכיון', kml: 'KML - גיאוגרפי',
      shp: 'SHP - Shapefile', pptx: 'PPTX - PowerPoint', msg: 'MSG - Outlook',
      jpg: 'JPG - תמונה', png: 'PNG - תמונה', html: 'HTML - דף אינטרנט',
      json: 'JSON - נתונים', geojson: 'GeoJSON - נתונים גיאוגרפיים'
    };

    const iconMap = {
      pdf: 'fa-file-pdf', dwg: 'fa-drafting-compass', dxf: 'fa-drafting-compass',
      doc: 'fa-file-word', docx: 'fa-file-word', xls: 'fa-file-excel',
      xlsx: 'fa-file-excel', zip: 'fa-file-archive', kml: 'fa-globe',
      shp: 'fa-vector-square', pptx: 'fa-file-powerpoint', msg: 'fa-envelope',
      jpg: 'fa-file-image', png: 'fa-file-image', html: 'fa-code',
      json: 'fa-brackets-curly', geojson: 'fa-brackets-curly'
    };

    const formatName = formatLabels[ft] || ft.toUpperCase();
    const icon = iconMap[ft] || 'fa-file';

    let html = `<div class="viewer-info-panel">
      <div style="text-align:center;margin-bottom:16px">
        <i class="fas ${icon}" style="font-size:48px;color:var(--accent);margin-bottom:12px;display:block"></i>
        <h3>${name}</h3>
      </div>
      ${errorMsg ? `<div style="background:#fef2f2;color:#dc2626;padding:10px 16px;border-radius:8px;margin-bottom:16px;text-align:center;font-size:13px"><i class="fas fa-exclamation-triangle"></i> ${errorMsg}</div>` : ''}
      <div class="info-row"><span class="k">סוג קובץ</span><span class="v">${formatName}</span></div>
      ${plan ? `<div class="info-row"><span class="k">תכנית</span><span class="v">${plan}</span></div>` : ''}
      ${rubric ? `<div class="info-row"><span class="k">קטגוריה</span><span class="v">${rubric}</span></div>` : ''}
      ${source ? `<div class="info-row"><span class="k">מקור</span><span class="v">${source}</span></div>` : ''}
      ${pages ? `<div class="info-row"><span class="k">עמודים</span><span class="v">${pages}</span></div>` : ''}
      ${date ? `<div class="info-row"><span class="k">תאריך</span><span class="v">${date}</span></div>` : ''}`;

    if (doc._has_file) {
      html += `<div style="text-align:center">
        <button class="dl-btn" onclick="docViewer.download()"><i class="fas fa-download"></i> הורד קובץ</button>
      </div>`;
    }

    // Suggestions for non-viewable formats
    if (['dwg', 'dxf'].includes(ft)) {
      html += `<div style="margin-top:16px;padding:12px;background:rgba(255,255,255,.05);border-radius:8px;font-size:12px;color:#94a3b8">
        <i class="fas fa-info-circle"></i> קבצי DWG ניתן לפתוח ב-AutoCAD, <a href="https://viewer.autodesk.com" target="_blank" style="color:#7dd3fc">Autodesk Viewer</a> (חינמי), או <a href="https://www.sharecad.org" target="_blank" style="color:#7dd3fc">ShareCAD</a>.
      </div>`;
    } else if (['doc', 'docx', 'xls', 'xlsx', 'pptx'].includes(ft)) {
      html += `<div style="margin-top:16px;padding:12px;background:rgba(255,255,255,.05);border-radius:8px;font-size:12px;color:#94a3b8">
        <i class="fas fa-info-circle"></i> ניתן לפתוח ב-Microsoft Office, LibreOffice, או <a href="https://docs.google.com" target="_blank" style="color:#7dd3fc">Google Docs</a>.
      </div>`;
    }

    html += '</div>';
    _content.innerHTML = html;
  }

  /* ── Zoom / Rotation ── */
  function zoomIn(step = 0.25) {
    _scale = Math.min(_scale + step, 5);
    applyTransform();
  }

  function zoomOut(step = 0.25) {
    _scale = Math.max(_scale - step, 0.25);
    applyTransform();
  }

  function fitWidth() {
    _scale = 1;
    _rotation = 0;
    applyTransform();
    // Re-render PDF at new scale if applicable
    if (_pdfDoc) {
      const doc = _docs[_currentIdx];
      if (doc) renderDoc(doc);
    }
  }

  function rotateCW() {
    _rotation = (_rotation + 90) % 360;
    applyTransform();
  }

  function applyTransform() {
    _zoomEl.textContent = Math.round(_scale * 100) + '%';
    // For images
    const img = document.getElementById('viewer-image');
    if (img) {
      img.style.transform = `scale(${_scale}) rotate(${_rotation}deg)`;
    }
    // For PDF pages
    const pdfContainer = document.getElementById('pdf-container');
    if (pdfContainer) {
      pdfContainer.style.transform = `scale(${_scale})`;
      pdfContainer.style.transformOrigin = 'top center';
    }
  }

  /* ── Navigation ── */
  function prevDoc() {
    if (_docs.length < 2 || _currentIdx <= 0) return;
    _currentIdx--;
    _scale = 1;
    _rotation = 0;
    renderDoc(_docs[_currentIdx]);
  }

  function nextDoc() {
    if (_docs.length < 2 || _currentIdx >= _docs.length - 1) return;
    _currentIdx++;
    _scale = 1;
    _rotation = 0;
    renderDoc(_docs[_currentIdx]);
  }

  /* ── Sidebar ── */
  function toggleSidebar() {
    _sidebarOpen = !_sidebarOpen;
    _sidebar.classList.toggle('open', _sidebarOpen);
    document.getElementById('viewer-sidebar-btn')?.classList.toggle('active', _sidebarOpen);
  }

  /* ── Download ── */
  function download() {
    const doc = _docs[_currentIdx];
    if (!doc || !doc._has_file) return;
    const url = `/api/documents/file/${doc._idx}`;
    const a = document.createElement('a');
    a.href = url;
    a.download = (doc.DOC_NAME || 'document') + '.' + (doc.FILE_TYPE || '').trim().toLowerCase();
    a.click();
  }

  /* ── Print ── */
  function printDoc() {
    const doc = _docs[_currentIdx];
    if (!doc || !doc._has_file) return;
    const ft = (doc.FILE_TYPE || '').trim().toLowerCase();
    if (ft === 'pdf') {
      const url = `/api/documents/file/${doc._idx}`;
      const win = window.open(url, '_blank');
      setTimeout(() => win?.print(), 1000);
    } else {
      window.print();
    }
  }

  /* ── Fullscreen ── */
  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      _overlay.requestFullscreen().catch(() => {});
    } else {
      document.exitFullscreen();
    }
  }

  return {
    init, open, close,
    zoomIn, zoomOut, fitWidth, rotateCW,
    prevDoc, nextDoc,
    toggleSidebar, toggleFullscreen,
    download, print: printDoc,
  };
})();

// Initialize viewer when DOM is ready
document.addEventListener('DOMContentLoaded', () => docViewer.init());
</script>
</body>
</html>
